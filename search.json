[{"title":"🔥Vue2渲染基础-虚拟DOM","path":"//posts/vue2-vnode.html","content":"专栏第六篇-虚拟节点以及createElement函数 在前面的文章中，我们介绍了Vue初始化的一系列操作。 可以Vue终归只是为了画页面。 后面的章节就带着大家来解析渲染相关的逻辑，一步一步解析Vue是如何将模板挂载到页面上的。 但是在解析渲染之前，我们先来了解一下Vue框架渲染的基础-虚拟 DOM。 一、渲染器的渲染流程在讨论虚拟节点之前，我们先来了解一下浏览器渲染的流程。 当浏览器接收到一个 HTML 文件后，JavaScript 引擎与浏览器的渲染引擎随即开始运行。 从渲染引擎的角度来看，它首先会把 HTML 文件解析为一个 DOM 树。 与此同时，浏览器会识别并加载 CSS 样式，然后将其与 DOM 树合并，形成一个渲染树。 在有了渲染树之后，渲染引擎会计算所有元素的位置信息，最后通过绘制操作，在屏幕上呈现出最终的内容。 JavaScript 引擎和渲染引擎虽然处于两个独立的线程之中，然而 JavaScript 引擎却能够触发渲染引擎开始工作。 当我们借助脚本去更改元素的位置或者外观时，JavaScript 引擎会运用与 DOM 相关的 API 方法来操作 DOM 对象。 此时渲染引擎便开始运作，渲染引擎会触发回流或者重绘操作。 我们来了解下回流以及重绘的概念： 回流：当我们对DOM的修改引发了元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制出来，这个过程称为回流。 重绘：当我们对DOM的修改只单纯改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程称为重绘。 很显然，回流比起重绘更加消耗性能。 通过了解浏览器基本的渲染机制，我们不难联想到，当不断地通过 JavaScript 修改 DOM 时，很容易在不经意间触发渲染引擎的回流或者重绘，而这种操作所带来的性能开销是非常巨大的。 因此，为了降低性能开销，我们需要做的是尽可能地减少对 DOM 的操作。 虚拟节点就是在这种情况下孕育而生。 二. 缓冲层-虚拟DOM虚拟 DOM （Virtual DOM 以下简称 VDOM）是为了解决频繁操作 DOM 所引发的性能问题而产生的产物。 VDOM是把页面的状态抽象成 JS 对象的形式呈现。 从本质上来说，它处于 JS 与真实 DOM 之间，起着中间层的作用。 当我们需要使用 JS 脚本进行大批量的 DOM 操作时，会优先在虚拟 VDOM 这个 JS 对象上进行操作。 最后，通过对比找出将要改动的部分，并将这些改动通知并更新到真实的 DOM 上。 尽管最终仍然是对真实的 DOM 进行操作，然而虚拟 DOM 能够将多个改动合并为一个批量操作。 这样做可以减少 DOM 重排的次数，进而缩短生成渲染树以及进行绘制所花费的时间。 我们来看一下一个真实的 DOM 具体包含了哪些内容。 浏览器将真实的 DOM 设计得极为复杂。 它不但包含了自身的属性描述，如大小、位置等定义，还囊括了 DOM 所拥有的浏览器事件等内容。 正是由于其如此复杂的结构，我们频繁地去操作 DOM 或多或少会给浏览器带来性能方面的问题。 而作为数据与真实 DOM 之间的一层缓冲，虚拟 DOM 只是用于映射到真实 DOM 进行渲染，所以并不需要包含操作 DOM 的方法。 它只需在对象中重点关注几个属性就可以了。 三、 VNode12345678910111213141516171819// 真实DOM&lt;div id=&quot;app&quot;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;// 真实DOM对应的JS对象(VNode)&#123; tag:&#x27;div&#x27;, data:&#123; id:&#x27;app&#x27; &#125;, children:[&#123; tag:&#x27;span&#x27;, children:[ &#123; tag:undefined, text:&#x27;Hello World&#x27; &#125; ] &#125;]&#125; 通过上面的例子我们可以看出来每一个 DOM节点 都可以使用一个 VNode 来表示。 在 Vue内部，使用 VNode 这个构造函数去描述一个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export default class VNode &#123; tag?: string data: VNodeData | undefined children?: Array&lt;VNode&gt; | null text?: string elm: Node | undefined ns?: string context?: Component // rendered in this component&#x27;s scope key: string | number | undefined componentOptions?: VNodeComponentOptions componentInstance?: Component // component instance parent: VNode | undefined | null // component placeholder node // strictly internal raw: boolean // contains raw HTML? (server only) isStatic: boolean // hoisted static node isRootInsert: boolean // necessary for enter transition check isComment: boolean // empty comment placeholder? isCloned: boolean // is a cloned node? isOnce: boolean // is a v-once node? asyncFactory?: Function // async component factory function asyncMeta: Object | void isAsyncPlaceholder: boolean ssrContext?: Object | void fnContext: Component | void // real context vm for functional nodes fnOptions?: ComponentOptions | null // for SSR caching devtoolsMeta?: Object | null // used to store functional render context for devtools fnScopeId?: string | null // functional scope id support isComponentRootElement?: boolean | null // for SSR directives constructor( tag?: string, data?: VNodeData, children?: Array&lt;VNode&gt; | null, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child(): Component | void &#123; return this.componentInstance &#125;&#125; 我们可以使用 new 关键字来创建一个 VNode。 12345678// 创建一个div的 vnodenew VNode(&#x27;div&#x27;,&#123;&#125;,&#x27;Hello World&#x27;)// 创建一个有子节点的 vnodenew VNode(&#x27;div&#x27;,&#123;&#125;,[ new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;1&#x27;), new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;2&#x27;), new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;3&#x27;)]) VNode这个构造函数上有非常多的属性，这里我们先列举四个常用的属性：tag、data、children、text。 其余属性在我们后面的解析中会一一进行解析。 3.1 tag属性tag表示创建的虚拟节点的标签名称。 决定了最终会渲染成什么样的 DOM元素。 tag可以是 HTML 元素，比如字符串span、'div'。 也可以是一个组件引用，同样可以是一个动态标签。 123456789101112// 编译前（普通节点）&lt;div&gt;&lt;/div&gt; // 编译后VNode &#123; tag:&quot;div&quot;&#125;// 编译前（组件节点）&lt;CustomComponent&gt;&lt;/CustomComponent&gt; // 编译后VNode &#123; tag:&quot;CustomComponent&quot;&#125; 3.2 data属性data 参数通常是一个对象，包含了用于描述 VNode 的各种属性和配置信息。 data 参数可以由以下几种构成： attrs:表示元素的上静态属性，如src、alt等。 staicClass:表示元素上的静态css类。 style:表示元素上的内联样式。 on:表示元素上的事件监听器。 slot:表示作用域插槽或普通插槽的位置。 props:表示传递组件的 props 数据。 directives:表示添加的自定义的行为，如 v-model、v-show等。 key:表示组件唯一标识。 3.3 childrenchildren 参数是指定一个 VNode（虚拟节点）的子节点内容。 这个参数可以包含多种类型的数据，用于描述子节点的结构和内容。 3.4 text我们知道并不是每个节点都有tag的，比如文字节点就没有tag。 在Vue中，文字也代表一个vnode。 123456// 编译前&quot;我是&quot; // 编译后VNode &#123; text:&quot;我是&quot;&#125; 3.1.5 elm我们知道在渲染时会根据 VNode 创建DOM元素。 渲染后每个VNode节点都有对应的真实 DOM元素。 而这个 elm 就指向这个真实 DOM元素。 四. createElement函数经过上面的学习，我们知道虚拟DOM就是一个JS对象，只不过他有很多属性。 所示说创建一个虚拟DOM也绝不是什么难事，但是 Vue 框架给我们提供了一个函数createElement。 这个函数可以更方便的帮我们生成虚拟 DOM，在其中磨平了一些细节。 它被定义在 src/core/vdom/create-element.js 中： 4.1 createElement在开发时的使用场景了解createElement的使用场景有哪些对看源码是有一定的帮助的。 有场景带入源码才知道对应的逻辑是在做什么，否则你光看源码，对于一些逻辑你是无法看懂的。 4.1.1 webpack编译时使用Vue框架底层渲染时会调用实例上的_render方法，这个 render方法实际上就是调用了实例选项上的 render方法。 1vm._render =&gt; vm.$options.render 你可能会有些困惑，因为平时我们都是使用.vue文件进行单页面开发，没有写过什么 render方法啊，那这个 render方法是怎么来的呢？ 其实我们平时编写的 template模板标签在 webpack预编译阶段会变成一个创建vnode的函数。 比如我们在模版中编写一个简单的字符串： 123&lt;template&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/template&gt; .vue文件在webpack预编译时会解析成一个对象，而模板部分则会编译成 render函数。 所以平时我们import Test from &quot;./Test&quot;，这里的Test打印出来是一个对象。 我们再看一下这里编译的 render方法，发现没有使用 createElement函数来创建节点，而使用了_c。 那么这里的_c代表什么？ _c实际上是在 vue初始化时在initRender方法中注入的，本质上也就是调用了 createElement。 12// 第六个参数代表是否需要规范化子节点 这里表示不需要 因为 webpack 预编译时会编译子节点vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 4.1.2 用户自定义render方法我们知道.vue文件会被解析成一个对象的形式。 所以我们也可以自己写一个 js文件，自己定义 render方法。Vue提供了这种能力。 我们一般会这么自定义函数。 1234567&#123; render:(h)=&gt;&#123; return &#123; h(&#x27;div&#x27;,&#x27;hello world&#x27;) &#125; &#125;&#125; 而源码中会将 vm.$createElement传入 render方法中。 12345try &#123; vnode = render.call(vm._renderProxy, vm.$createElement)&#125; catch (e: any) &#123; ///&#125; 所以这里的 vm.$createElement就是h函数，也就是创建 VNode的函数。 $createElement和_c一样也是在vue初始化时在initRender方法中注入的。 12// 第六个参数是 true 表示需要处理子节点为 VNode节点vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) _c和$createElement的不同之处是$createElement中对于 createElement的第六个参数传递的值不同。 4.2 createElement函数解析123456789101112131415161718export function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType)&#125; createElement的参数分别是： 第一个参数为context：表示上下文，一般这里传递的是vue实例vm。 第二个参数为 tag：表示创建的虚拟节点的标签。 第三个参数为 data：表示创建的虚拟节点的数据。 第四个参数为 children：表示虚拟节点的子节点。 第五个参数为 normalizationType：这个参数决定规范化的类型。 第六个参数为 alwaysNormalize：表示是否规范化子节点。 createElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 _createElement。 4.2.1 对第二个参数做兼容1234// 存在 data的情况createElement(context,&#x27;div&#x27;,&#123;style:&#123;color:&quot;red&quot;&#125;&#125;,&#x27;hello world&#x27;) // 不存在 data的情况createElement(context,&#x27;div&#x27;,null,&#x27;hello world&#x27;) 如上，第三个参数表示 data，第四个参数表示children。 而很多时候，我们不需要传递 data属性，但是由于参数顺序的原因，依旧需要传递一个空对象来进行占位。 这个时候函数内部对这个参数进行了兼容处理。 判断如果第三个参数是数组或者原始类型（字符串，数字等），则将其第三个参数视为是传递的子节点。 同时将data置为undefined，normalizationType使用第四个参数。 因此我们可以这么调用，不用再使用一个占位符了。 12// 不存在 data的情况 不需要传递 data进行占位createElement(context,&#x27;div&#x27;,&#x27;hello world&#x27;) 4.2.2 对children的规范化由于VNode实际上是一个树状结构，每一个VNode可能会有若干个子节点，这些子节点应该也是 VNode 的类型。 _createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。 normalizationType的值有 2 种： SIMPLE_NORMALIZE：值为 1，表示简单处理子节点 ALWAYS_NORMALIZE：值为 2，表示递归处理所有子节点 需要注意的是对于用户手动创建render方法，normalizationType一直为ALWAYS_NORMALIZE。表示需要规范处理子节点。 因为用户有可能不是很熟悉 createElement的使用方式和 Vue的渲染机制导致一些错误情况的发生，如下： 12345678// 如果不进行处理，在渲染过程中极有可能会产生问题render(h)&#123; return h(&#x27;ul&#x27;,[ &quot;苹果&quot;, &quot;香蕉&quot;, &quot;梨&quot; ])&#125; 这里根据 normalizationType 的不同，分别调用了normalizeChildren(children) 和 simpleNormalizeChildren(children)方法。 它们的定义都在 src/core/vdom/helpers/normalzie-children.js 中： 4.2.2.1 simpleNormalizeChildren1234567891011121314151617181920// The template compiler attempts to minimize the need for normalization by// statically analyzing the template at compile time.//// For plain HTML markup, normalization can be completely skipped because the// generated render function is guaranteed to return Array&lt;VNode&gt;. There are// two cases where extra normalization is needed:// 1. When the children contains components - because a functional component// may return an Array instead of a single root. In this case, just a simple// normalization is needed - if any child is an Array, we flatten the whole// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep// because functional components already normalize their own children.export function simpleNormalizeChildren(children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (isArray(children[i])) &#123; return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125; 当 normalizationType 为 SIMPLE_NORMALIZE 时，才会调用simpleNormalizeChildren方法。 那么 normalizationType 何时才会是 SIMPLE_NORMALIZE呢？ 我们知道用户自定义 render函数的时候，normalizationType恒为ALWAYS_NORMALIZE，所以只有是在编译的时候在_c中才会将值变成 SIMPLE_NORMALIZE。 理论上编译生成的children都已经是 VNode类型了，不需要处理了才对。 但是有一种情况需要考虑，就是函数组件返回的是一个数组而不是一个根节点， 1234567export default &#123; functional: true, props: [&#x27;items&#x27;], render(h, &#123; props &#125;) &#123; return props.items.map(item =&gt; h(&#x27;li&#x27;, item)); &#125;&#125;; 此时需要将数组打平成一级。 4.2.2.2 normalizeChildren递归处理子节点1234567export function normalizeChildren(children: any): Array&lt;VNode&gt; | undefined &#123; return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : undefined&#125; normalizeChildren用在用户自定义render时对 children进行规范化，因为编译时已经将 children 都规范化为了createElement创建函数。 Vue允许用户把children写成基础类型用来创建单个简单的文本节点，对应这种场景，vue会调用 createTextVNode创建一个文本节点的 VNode，并且会转化成数组的形式。 1234567891011121314151617// 用户自定义 render函数export default &#123; render:function(h)&#123; return h(&#x27;div&#x27;,&#x27;Hello World&#x27;) &#125;&#125;// 生成的 VNodeVNode &#123; tag:&#x27;div&#x27;, // 将文字转化成了children数组 children:[ VNode &#123; tag: undefined, text: &#x27;Hello World&#x27; &#125; ]&#125; 如果 children是一个数组，需要递归处理 children，遍历每一个子节点，将每一个子节点转化为标准的 VNode，其中这个转化操作是使用normalizeArrayChildren函数来完成的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function normalizeArrayChildren( children: any, nestedIndex?: string): Array&lt;VNode&gt; &#123; const res: VNode[] = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) &#123; c = children[i] if (isUndef(c) || typeof c === &#x27;boolean&#x27;) continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (isArray(c)) &#123; if (c.length &gt; 0) &#123; c = normalizeArrayChildren(c, `$&#123;nestedIndex || &#x27;&#x27;&#125;_$&#123;i&#125;`) // merge adjacent text nodes if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) &#123; res[lastIndex] = createTextVNode(last.text + c[0].text) c.shift() &#125; res.push.apply(res, c) &#125; &#125; else if (isPrimitive(c)) &#123; if (isTextNode(last)) &#123; // merge adjacent text nodes // this is necessary for SSR hydration because text nodes are // essentially merged when rendered to HTML strings res[lastIndex] = createTextVNode(last.text + c) &#125; else if (c !== &#x27;&#x27;) &#123; // convert primitive to vnode res.push(createTextVNode(c)) &#125; &#125; else &#123; if (isTextNode(c) &amp;&amp; isTextNode(last)) &#123; // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) &#125; else &#123; // default key for nested array children (likely generated by v-for) if ( isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex) ) &#123; c.key = `__vlist$&#123;nestedIndex&#125;_$&#123;i&#125;__` &#125; res.push(c) &#125; &#125; &#125; return res&#125; 该函数的主要逻辑就是遍历children数组，获取每一项的数据类型，然后做相应处理。 如果是未定义&#x2F;null&#x2F;布尔值，直接跳过，不进行处理。 如果是数组类型，则递归调用normalizeArrayChildren。 如果是基础类型，则通过 createTextVNode方法转换成 VNode类型。 如果不是上面三种类型，则表示已经是 VNode类型了。 需要注意的是在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 text 节点，会把它们合并成一个 text 节点。 4.2.2.3 总结经过对 children的统一处理，现在 VNode已经是一个规范化的 VNode节点了。 4.3 VNode的创建经过兼容处理和 children规范化处理后，就可以创建VNode了。 4.3.1 非组件 VNode当 tag为字符串，且不是注册组件，则直接调用 VNode来创建 VNode。 tag是字符串一般有 2 种情况： 普通的HTML标签 1234567// 模板编译前&lt;template&gt; &lt;div&gt;Hello World&lt;/div&gt;&lt;/template&gt;// 模板编译后// _v表示createTextVNode 用作创建子节点_c(&#x27;div&#x27;,[_v(&#x27;Hello World&#x27;)]) 组件类型 1234567// 模板编译前&lt;template&gt; &lt;Component /&gt;&lt;/template&gt;// 模板编译后// _v表示createTextVNode 用作创建子节点_c(&#x27;Component&#x27;) 4.3.2 组件 VNode当 tag不是字符串或者字符串是注册组件的关键字，则表示需要创建一个组件VNode。此时调用 createComponent来创建组件VNode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110export function createComponent( Ctor: typeof Component | Function | ComponentOptions | void, data: VNodeData | undefined, context: Component, children?: Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor as typeof Component) &#125; // if at this stage it&#x27;s not a constructor or an async component factory, // reject. if (typeof Ctor !== &#x27;function&#x27;) &#123; if (__DEV__) &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component let asyncFactory // @ts-expect-error if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder(asyncFactory, data, context, children, tag) &#125; &#125; data = data || &#123;&#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor as typeof Component) // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; // @ts-expect-error transformModel(Ctor.options, data) &#125; // extract props // @ts-expect-error const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component // @ts-expect-error if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent( Ctor as typeof Component, propsData, data, context, children ) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier // so it gets processed during parent component patch. data.on = data.nativeOn // @ts-expect-error if (isTrue(Ctor.options.abstract)) &#123; // abstract components do not keep anything // other than props &amp; listeners &amp; slot // work around flow const slot = data.slot data = &#123;&#125; if (slot) &#123; data.slot = slot &#125; &#125; // install component management hooks onto the placeholder node installComponentHooks(data) // return a placeholder vnode // @ts-expect-error const name = getComponentName(Ctor.options) || tag const vnode = new VNode( // @ts-expect-error `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`, data, undefined, undefined, undefined, context, // @ts-expect-error &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode&#125; 创建组件 VNode时，会在 VNode新增一些组件特有的属性： 使用 Vue.extend生成一个子类构造器，会挂载到 VNode的componentsOptions属性的 Ctor上。 处理异步组件 处理 model 注入一些 hooks 等 4.4 createElement函数的优势createElement函数的意义在于它提供了一种更方便、更简洁且更具可读性的方式来创建vnode，相比直接编写 VNode 具有以下好处： 4.4.1 直观的参数形式使用createElement函数可以通过直观的参数来描述虚拟节点的属性。 相比之下，直接编写 VNode 对象时，需要手动构建一个包含多个属性的 JavaScript 对象，可能会导致代码较为冗长和复杂，降低了可读性和可维护性。 4.4.2 统一的创建方式在项目中使用createElement函数可以确保虚拟节点的创建方式一致。 直接编写 VNode 对象可能会导致不同的开发者采用不同的方式来构建虚拟节点，从而降低了代码的一致性和可维护性。 4.4.3 动态属性和条件判断createElement函数可以接收动态的参数，允许在运行时根据条件来决定虚拟节点的属性。例如，可以根据数据的变化动态地添加或修改属性，或者根据条件判断来决定是否创建某个子节点。 直接编写 VNode 对象时，要实现类似的动态行为可能需要更多的代码和逻辑处理，增加了代码的复杂性。 五、总结为了避免重复操作真实 DOM 所带来的性能消耗，vue框架引入了虚拟 DOM。 虚拟 DOM本质上就是一个具有特有属性的一个 JS对象。 为了实现创建虚拟 DOM 的一致性，vue提供了一个方法 createElement 用来方便快捷的生成虚拟 DOM。"},{"title":"🔥Vue2初始化时都干了什么事","path":"//posts/vue2-init.html","content":"专栏第四篇-初始化干了什么事 &emsp;&emsp;上一节中我们知道 Vue就是一个构造函数，在使用 Vue的时候需要实例化 Vue，这一章我们就来看看在实例化的时候内部做了一些什么操作。 零、调用了_init方法123456function Vue()&#123; if(!this instanceof Vue)&#123; return warn(&quot;必须使用 new 关键字来实例化&quot;) &#125; this._init();&#125; 除了在构造函数内部对是否使用 new 关键字进行判断。 还在校验过后调用了_init方法。 从 init 这个名字不难看出，肯定在内部做了一些初始化的操作。 该方法是在Vue被引入时调用 initMixin 方法在Vue上注入的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let uid = 0;export function initMixin(Vue)&#123; Vue.prototype._init = function (options?: Record&lt;string, any&gt;) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to mark this as a Vue instance without having to do instanceof // check vm._isVue = true // avoid instances from being observed vm.__v_skip = true // effect scope vm._scope = new EffectScope(true /* detached */) // #13134 edge case where a child component is manually created during the // render of a parent component vm._scope.parent = undefined vm._scope._vm = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options as any) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (__DEV__) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;, undefined, false /* setContext */) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 接下来我们会详细解释下每一步中具体都做了什么。 一、vm._uid12345let uid = 0;Vue.prototype.init=function()&#123; vm._uid = uid++&#125; 在_init方法的第一行可以看到在实例上挂载了一个vm._uid属性。 每个Vue实例都会有一个唯一的_uid（Unique Identifier，唯一标识符。 这个标识符是在 Vue 实例创建时由一个递增的计数器生成的，其主要用途是在内部处理中提供唯一性。 尤其是在涉及到实例间的比较或者跟踪的时候。 二、追踪初始化消耗时间123456789101112// _init 函数刚执行时let startTag, endTagif (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag)&#125;// _init 函数初始化逻辑完成if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(endTag) measure(`vue $&#123;vm._uid&#125; init`, startTag, endTag)&#125; 2.1 覆盖默认配置我们知道在 Vue 可以覆盖默认配置。 12// 开启 vue性能配置Vue.config.performance = true; 那么 vue 是如何做到的呢？ core/config.js文件是vue的默认配置文件。 12345// core/config.jsexport default &#123; // 默认不开启perf performance: false&#125; Vue被引入时，在 initGlobalAPI方法中给 Vue设置了 config属性。 12345678910111213141516import config from &#x27;../config&#x27;export function initGlobalAPI(Vue)&#123; // 省略部分代码 const configDef = &#123;&#125;; configDef.get = () =&gt; config; if (__DEV__) &#123; configDef.set = () =&gt; &#123; warn( &#x27;不要替换Vue.配置对象，而是设置单独的字段&#x27; ) &#125; &#125; Object.defineProperty(Vue,&#x27;config&#x27;,configDef);&#125; 而引入的config就是Vue的默认配置文件，其导出内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293export default &#123; /** * Option merge strategies (used in core/util/options) */ // $flow-disable-line optionMergeStrategies: Object.create(null), /** * Whether to suppress warnings. */ silent: false, /** * Show production mode tip message on boot? */ productionTip: __DEV__, /** * Whether to enable devtools */ devtools: __DEV__, /** * Whether to record perf */ performance: false, /** * Error handler for watcher errors */ errorHandler: null, /** * Warn handler for watcher warns */ warnHandler: null, /** * Ignore certain custom elements */ ignoredElements: [], /** * Custom user key aliases for v-on */ // $flow-disable-line keyCodes: Object.create(null), /** * Check if a tag is reserved so that it cannot be registered as a * component. This is platform-dependent and may be overwritten. */ isReservedTag: no, /** * Check if an attribute is reserved so that it cannot be used as a component * prop. This is platform-dependent and may be overwritten. */ isReservedAttr: no, /** * Check if a tag is an unknown element. * Platform-dependent. */ isUnknownElement: no, /** * Get the namespace of an element */ getTagNamespace: noop, /** * Parse the real tag name for the specific platform. */ parsePlatformTagName: identity, /** * Check if an attribute must be bound using property, e.g. value * Platform-dependent. */ mustUseProp: no, /** * Perform updates asynchronously. Intended to be used by Vue Test Utils * This will significantly reduce performance if set to false. */ async: true, /** * Exposed for legacy reasons */ _lifecycleHooks: LIFECYCLE_HOOKS&#125; as unknown as Config 根据上面的配置可以知道 Vue.config获取的就是config文件中中配置的内容。 export或export default一个对象时，对象本身在外部脚本中是不能修改的。但是对象的属性在外部脚本中都是可以修改的。 所以你可以通过Vue.config.xxx = xxx 来设置配置或者覆盖默认的配置。 2.2 mark函数 &amp; measure函数mark函数 和 measure函数是vue中进行性能检测的函数。 函数位于core/util/perf文件中。 123456789101112131415161718192021222324// 判断是否在浏览器中import &#123; inBrowser &#125; from &#x27;./env&#x27;export let markexport let measure// 只有在开发环境中才会设置 mark 和 measureif (__DEV__) &#123; const perf = inBrowser &amp;&amp; window.performance if ( perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures ) &#123; mark = tag =&gt; perf.mark(tag) measure = (name, startTag, endTag) =&gt; &#123; perf.measure(name, startTag, endTag) perf.clearMarks(startTag) perf.clearMarks(endTag) &#125; &#125;&#125; 实际上就是调用了window.performance相关的 api： performance.mark：主要用于创建标记 performance.measure： 主要用于记录两个标记的时间间隔 performance.clearMarks： 用于清除标记 123456789window.performance.mark(&quot;_start&quot;)for(let i=0;i&lt;10000;i++)&#123; console.log();&#125;window.performance.mark(&quot;_end&quot;)window.performance.measure(&quot;timestamp&quot;,&quot;_start&quot;,&quot;_end&quot;)// 可以获取直接间隔window.performance.getEntriesByName(&quot;timestamp&quot;)[0] 可以使用getEntriesByName获取两个标记期间代码执行的时间。 从而这里通过这个方法可以获取到初始化_init函数执行的时机。 2.3 总结在 _init 函数开始时打一个名为“vue-perf-start”的标记。 然后在逻辑处理结束后打一个名为“vue-perf-end”的标记。 最后通过measure函数设置一个 measure 对象，里面包含两个标记之间的间隔时间。 这个间隔时间就可以看成这个实例初始化花费的时间，以此来评测性能。 三. vm._isVue123Vue.prototype.init=function()&#123; vm._isVue = true&#125; 每个 vue实例 在初始时都会设置_isVue变量。 这个变量可以在内部&#x2F;扩展插件中判断当前对象是否是一个有效的 vue实例。 四、vm.__v_skip123Vue.prototype.init=function()&#123; vm.__v_skip = true&#125; 在初始化时将该变量设置为 true。 这个变量用于指示Vue的相应是系统跳过对该对象的观测。 当一个对象被标记为 __v_skip &#x3D; true 时，Vue 不会对这个对象进行深度观测，这意味着对象内部的属性变化将不会触发视图更新。 五、合并选项123456789101112if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options as any)&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm )&#125; 第五步是执行合并 options的操作，那么这个 options是什么呢？可以说 Vue中的大部分内容都是基于 options来完成的，这个 options中存储了用户传入的选项以及一些内置的 Vue选项。 由于options在 Vue中比较重要，关于这一块我们后面会专门开一篇文章来详细解释。 在这篇专栏中具体说明了合并选项：第五篇专栏 六、设置数据代理检测12345if (__DEV__) &#123; initProxy(vm)&#125;else &#123; vm._renderProxy = vm&#125; 这里的目的是在开发环境下给vm设置代理，从而达到开发时提示的功能，这个我们后续也会单开一篇文章进行说明。 七、vm._self &#x3D; vm123Vue.prototype.init=function()&#123; vm._self = vm&#125; 将_self属性指向自身这个实例。 可以确保在任何情况下都能正确引用当前实例。 八、执行一些初始化操作后面我们会执行一些用于初始化的操作。 内部具体做了什么我们咱不考虑，在后面的章节中我们会一一进行讨论。 123456789101112// 初始化生命周期initLifeCycle(vm);// 初始化事件中心initEvents(vm)// 初始化渲染initRender(vm)// 初始化 injectinitInjections(vm)// 初始化 props、data、computed 等initState(vm)// 初始化 providerinitProvide(vm) 这些函数基本上都是在实例上挂载了一些方法，比如渲染执行的_update就是在 initLifecycle中定义的、跟渲染相关的_render函数就是在 initRender中定义的。 九、执行一些生命钩子在执行 initRender 后，会调用 beforeCreate 钩子。这表示beforeCreate 钩子 调用的时机为Vue实例化 data数据前，所以此时获取 data是无法获取到的，因为这时候还没有初始化 data。 在执行完最后一个初始化函数initProvide后，会调用 created钩子。这表示created钩子 调用的时机为Vue实例初始化后。 123456// 省略initRender(vm)callHook(vm, &#x27;beforeCreate&#x27;, undefined, false /* setContext */)// 省略initProvide(vm) // resolve provide after data/propscallHook(vm, &#x27;created&#x27;) 十、执行挂载123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; 判断是否有vm上是否有$options选项，如果存在$options选项，则执行挂载方法。 十一、总结在 init函数内部，主要是执行一些初始化操作，比如设置基础的代理。初始化data、给实例上设置_update、_render方法等。"},{"title":"🔥Vue2丰富的选项合并策略","path":"//posts/vue2-merge-options.html","content":"专栏第五篇-丰富的选项合并策略 一、实例化时合并选项在上一篇文章中执行Vue初始化的时候，我们说到了选项合并。 那什么是选项呢？ 在 new Vue(选项)中，Vue构造函数中传入的数据就是选项，代表传入的选项，一般以对象形式传入。 在Vue源码中使用变量options表示选项，在源码中你经常能看到 options的身影。 在实例化时需要将实例对应的构造函数上的选项和传入的选项合并到实例的选项上。 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) 上面 mergeOptions 则是用于合并 2 个 options，resolveConstructorOptions用于获取构造函数上的options。 在前面的文章 Vue的原型设计中，我们知道 vm.constructor 就是指的 Vue构造函数 二、Vue构造函数的默认选项前面我们知道 vm.$options 中会合并Vue构造函数的 options。 那么 Vue.options 有值吗？ 实际上Vue构造函数本身会自带一些默认的选项。 在Vue被引入时，会执行多个方法给Vue.options注入属性。 2.1 initGlobalAPI方法创建 Vue.optionsinitGlobalAPI方法在Vue被引入时执行。 1234567891011121314151617// core/global-api/index.tsconst ASSET_TYPES = [&#x27;component&#x27;,&#x27;directive&#x27;,&#x27;filter&#x27;];const builtInComponents = &#123; KeepAlive&#125;export function initGlobalAPI(Vue)&#123; // Object.create用于创建一个对象 该对象没有原型 Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &#x27;s&#x27;] = Object.create(null) &#125;); Vue.options._base = Vue; extend(Vue.options.components, builtInComponents) &#125; 可以看到，installGlobalAPI方法中创建了 Vue.options为一个纯净的空对象，然后在options上面注入了一些属性。 _base就是 Vue构造函数。每个Vue组件都是通过_base属性获取到Vue构造函数，然后使用Vue.extend来生成对应的 VueComponent构造函数。 extend方法是vue中的一个通用方法。用于将第二个参数的值合并到第一个参数中，返回第一个参数。第二个参数的值直接覆盖进第一个参数 extend函数源码1234567891011export function extend( to, _from)&#123; // 用于合并第二个参数到第一个参数中 for (const key in _from) &#123; // 覆盖参数属性 to[key] = _from[key] &#125; return to&#125; 2.2 合并指令 &amp; 内置组件1234567891011121314// platforms/web/runtime/indexconst platformDirectives = &#123; model, show&#125;const platformComponents = &#123; Transition, TransitionGroup&#125;extend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents) 该段逻辑也是在 Vue被引入时执行，扩展了一些跟 web平台相关的指令和组件。 2.3 总结经过我们的研究发现，Vue构造函数的默认选项有： _base： 代表Vue构造函数，后续用来创建组件的构造函数VueComponent。 directive：代表需要注册的指令，默认的提供了 v-model、v-show的内置指令。 components：代表需要注册的组件选项，默认提供了 KeepAlive、Transition、TransitionGroup的内置组件。 filter ：代表需要注册的过滤器，默认没有提供默认值。 三、子类构造函数的 options学习完上节我们知道在Vue被引入时，在Vue构造函数上注入了一些默认选项。 在专栏第三篇中，我们介绍了 Vue.extend函数。 在render阶段生成虚拟节点时，会调用 Vue.extend 生成组件构造函数VueComponent，并存在 vnode上。 然后在update阶段开始挂载节点时，会调用组件构造函数 VueComponent来创建组件实例，再进行后续组件实例初始化、渲染等操作。 那么VueComponent构造函数作为Vue构造函数的子类，是不是也继承了它的默认选项呢？ 我们再次打开 Vue.extend 的源码一探究竟。 1234567891011Vue.extend = function(extendOptions)&#123; extendOptions = extendOptions || &#123;&#125; // 新增_Ctor属性 const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) const Super = this; const Sub = function VueComponent()&#123; this._init(); &#125; // mergeOptions用于合并2个选项返回一个合并选项 Sub.options = mergeOptions(Super.options, extendOptions)&#125; 虽然我们不知道 mergeOptions的具体逻辑，但是我们很容易看出来，VueComponent构造函数上的 options属性合并了“父类“构造函数上的options属性以及extend方法传入的选项。 在 VueComponent构造函数上新增了一个_Ctor属性，可以避免每次重新创建子类，提高性能，后面我们会专门说这里，这里不进行展开。 所以我们可以得出一个结论：子类构造函数的选项继承了其父类构造函数的选项。 举个例子： 123const VueComponent = Vue.extend(&#123; template:`&lt;div&gt;我是子类构造函数&lt;/div&gt;`&#125;); 此时 VueComponent.options 上既包含了自身传入的 template 选项，也包含了继承自Vue构造函数上的属性。 这里需要注意的是，在合并父类构造函数的 options时，不同 option的合并策略不同，对于components、filter、directives等内置选项会合并到原型链中。 我们知道，VueComponent构造函数本身是具有再次扩展的能力的。 1234567const VueComponentChild = VueComponent.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChildConstructor&quot; &#125; &#125;&#125;) 同理，VueComponentChildConstructor是VueComponent的子类，所以VueComponentChildConstructor就继承了VueComponent的 options。 四、获取构造函数上的 options在Vue初始化操作执行时，使用 resolveConstructorOptions 函数来获取构造函数上的 options。 1234567891011121314151617181920212223export function resolveConstructorOptions(Ctor)&#123; let options = Ctor.options; if (Ctor.super) &#123; const superOptions = resolveConstructorOptions(Ctor.super) const cachedSuperOptions = Ctor.superOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed, // need to resolve new options. Ctor.superOptions = superOptions // check if there are any late-modified/attached options (#4976) const modifiedOptions = resolveModifiedOptions(Ctor) // update base extend options if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options;&#125; 看到这么多代码，想必大家也是极其懵逼的。 因为我们之前说过： Vue构造函数的选项是在初始化时注入的。 VueComponent构造函数及其扩展子类的选项则是在extend方法中进行注入的。 那直接使用.options获取构造函数的选项不就行了，为什么还有这么一大段逻辑呢？ 12Vue.options // 获取Vue构造函数的选项VueComponent.options // 获取VueComponent构造函数的选项 其实这一段逻辑主要是应对父类构造函数上选项变化的情况。 4.1 Ctor.super可以看到只有 Ctor.super 存在时才会走这一大段逻辑。 那么 Ctor.super 指的是什么呢？ 在使用 extend生成子类构造函数时，会在子类构造函数上新增了一个 super属性，指向它的父类。 123456789Vue.extend = function()&#123; let Sub = function VueComponent()&#123; this._init &#125; let Super = this; // 省略部分代码 // super即代表它的父类 Sub[&#x27;super&#x27;] = Super;&#125; 所以如果存在 super 属性，则代表现在这里的 Ctor使用的是extend生成的VueComponent构造函数。所以这里分为 2 种情况： 没有super属性，代表这是 Vue构造函数，直接返回 Vue.options 即可。 如果存在super属性，代表这是extend生成的 VueComponent构造函数，需要进行进一步判断。 因为 VueComponent.options的值是在 extend时合并了父类选项和extend传入选项的全新选项。 所以如果后续Vue.options变化了无法获取最新的选项。 4.2 判断父类构造函数上的 options 是否变化那么有哪些操作可以修改父类构造函数上的 options呢？ 比如使用 Vue.mixin api，这个 api就修改了Vue.options选项。 这个时候就需要有一些逻辑可以更新 VueComponent上的 options。 我们来看下 Vue是怎么更新的。 12345const superOptions = resolveConstructorOptions(Ctor.super)const cachedSuperOptions = Ctor.superOptionsif (superOptions !== cachedSuperOptions) &#123; // 进入这个逻辑说明 Vue.options变化了&#125; 上面代码中如果 superOptions 不等于 cachedSuperOptions，即表示父类构造函数发生了变化。 所以我们需要搞明白这 2 个值分别表示什么？ superOptions是在resolveConstructorOptions中递归向上查找的，就是表示父类构造函数的最新选项。 cachedSuperOptions 是指的构造函数上的 superOptions属性，这个属性是在 extend中定义的： 12345678Vue.extend = function()&#123; let Super = this; let Sub = function VueComponent()&#123; this._init(); &#125; // 这里存储的就是父类构造函数的 options Sub.superOptions = Super.options&#125; 所以这 2 个值都是指的父类构造函数，指向的是同一块内存地址，那么为什么会有不一样的情况呢？ 在 Vue 旧版本中曾经有一个相关的 bug。我们先来了解一下这个 bug： 4.2.1 Vue旧版本的 buggithub issue #4976 这个bug的大概意思就是说：先生成VueComponent构造函数，然后再在构造函数上的 options 添加属性，在resolveComponentOptions函数执行后，后添加的属性消失了。 这是复现链接：options消失。 我们这里看一下代码： 123456789101112131415161718192021222324252627const Test = Vue.extend(&#123; foo: &#x27;Foo&#x27;&#125;)// Inject options later// vue-loader and vue-hot-reload-api are doing like thisTest.options.computed = &#123; $style: &#123; test: &#x27;abcde&#x27; &#125; &#125;Test.options.beforeCreate = [ () =&gt; &#123; console.log(&#x27;Should be printed&#x27;) &#125;]Test.options.render = function (h) &#123; return h(&#x27;div&#x27;, &#x27;$style: &#x27; + this.$style)&#125;// Update super constructor&#x27;s optionsVue.mixin(&#123;&#125;)new Vue(&#123;\trender: h =&gt; h(Test)&#125;).$mount(&#x27;#app&#x27;)// This is retainedconsole.log(Test.options.foo)// Should be appear but notconsole.log(Test.options.computed)console.log(Test.options.beforeCreate) 可以看到首先使用 Vue.extend 生成了一个 Test构造函数。 然后在 Test的 options上新增了 2 个属性。 执行完Vue.mixin后，先前定义的computed、beforeCreate2个属性不见了。 4.2.2 Vue.mixin那么这个 Vue.mixin究竟是干了啥呢？ 1234Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this&#125; 可以看到mixin函数仅仅是改变了构造函数上的options。 但是 mergeOptions 会返回一个新的对象，导致构造函数的 options 发生了变化。 也就导致了前面说的 superOptions !== cachedSuperOptions 情况的发生。 因为 superOptions 获取的是当前最新的选项，也就是 mixin 执行过的合并选项。 而 cachedSuperOptions 则是在执行 Vue.extend 时当时的父类构造函数的选项。 4.2.3 旧版本Vue中 resolveConstructorOptions 的逻辑是什么？但是 Vue.mixin 仅仅是更改了 Vue.options。 应该不会将VueComponent构造函数自身添加的属性清除。 所以应该是 Vue内部对其做了一些特殊处理。 我们打开 Vue 2.1.10 版本的相关源码。 1234567891011121314151617181920export function resolveConstructorOptions (Ctor) &#123; let options = Ctor.options if (Ctor.super) &#123; const superOptions = Ctor.super.options const cachedSuperOptions = Ctor.superOptions const extendOptions = Ctor.extendOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed Ctor.superOptions = superOptions extendOptions.render = options.render extendOptions.staticRenderFns = options.staticRenderFns extendOptions._scopeId = options._scopeId options = Ctor.options = mergeOptions(superOptions, extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125; 获取了父构造函数的当前的 options：const superOptions = Ctor.super.options。 获取了父构造函数执行extend时的options：const cachedSuperOptions = Ctor.superOptions。 获取了子构造函数 extend时传入的选项extendOptions。 因为执行了mixin，导致父构造函数中的 options发生了变化，即superOptions !== cachedSuperOptions，然后继续执行内部的逻辑。 1options = Ctor.options = mergeOptions(superOptions, extendOptions) 可以看到它是将获取到的父构造函数 options和当初 extend传入的 options合并，然后重新赋值给了 Ctor.options。 所以后添加的computed、beforeCreate就消失了，因为指向了不同的内存空间。 4.2.4 总结通过上面几节的学习，我们知道了为什么需要判断父类构造函数的变化。 我们系统提供了全局注入的 API：Vue.mixin。 使用这个函数可以向全局注入一些选项。 而实际上就是通过改变Vue构造函数上的option，再通过这里的变更逻辑重新赋值到 VueComponent.options上，这样生成的实例就可以访问到 Vue.mixin注入的属性了。 4.3 使用resolveModifiedOptions获取更改的属性应对上面说的这个 bug，Vue官方也对这resolveConstructorOptions方法进行了调整。 针对VueComponent构造函数上可能存在的options更改进行了处理。 首先在 Vue.extends中保存了VueComponent的当时的options。 12345Vue.extend = function()&#123; // 省略部分代码 // 存储了当时的 options Sub.sealedOptions = extend(&#123;&#125;, Sub.options)&#125; 使用resolveModifiedOptions查找修改的option部分 123456789101112function resolveModifiedOptions(Ctor)&#123; let modified const latest = Ctor.options const sealed = Ctor.sealedOptions for (const key in latest) &#123; if (latest[key] !== sealed[key]) &#123; if (!modified) modified = &#123;&#125; modified[key] = latest[key] &#125; &#125; return modified&#125; 将修改的 options合进 extendOptions 123if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions)&#125; 合并 extendOptions以及 superOptions extendOptions是最新的子类构造函数 options。 superOptions是最新的父类构造函数 options。 将两者合并就不会有问题了。 1options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) 5.4 总结这个函数可以获取到构造函数上最新的options。 同时可以更新子类构造函数和父类构造函数上的superOptions、extendOptions以及 options。 五、mergeOptions的合并场景mergeOptions在实例化时用于合并构造函数的 options和传入的 options。 mergeOptions 是实现继承和实例化的核心函数。 123456function mergeOptions(parent,child,vm)&#123; // parent代表合并父类 // child代表合并子类 // vm代表当前的 vm实例 // 如果vm实例存在，则表示这是在实例化时调用的&#125; mergeOptions函数不仅仅用于生成实例的$options属性。 也可以用于子类构造函数和父类构造函数的选项合并。 在多个场景都是用了这个函数。 5.1 Vue.extend1234Vue.extend = function(extendOptions)&#123; // 省略部分代码 Sub.options = mergeOptions(Super.options,extendOptions)&#125; 前面我们已经多次提及这个方法了。 这里的 mergeOptions 用于合并父类构造函数选项和传入的选项，生成子类构造函数的选项。 在这里：父类构造函数的选项相当于父类，而传入的选项相当于子类。不传入vm实例。 5.2 Vue.mixin1234Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this&#125; 前面我们也多次提到这个方法，这个方法主要是用于合并构造函数的options，和传入mixin选项，生成全新的构造函数的 options。 在这里：构造函数的选项相当于父类，而传入的 mixin选项相当于子类。不传入vm实例。 5.3 vm.$options12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm) 该方法用于在实例化的时候生成实例的$options属性。这个方法主要用于合并实例对应的构造函数的选项和传入的选项，生成一个完整地实例选项。 在这里：构造函数的选项相当于父类，而实例化时传入的 mixin选项相当于子类`。`此时传入vm实例。 六、合并策略在实例化的时候，会将构造函数上的选项和用户传入的选项进行合并，将最终的合并选项注入到实例中。 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm) mergeOptions函数用于合并2个选项，并返回一个新的选项。 123456789101112131415161718function mergeOptions(parent,child)&#123; // 省略部分代码 let key const options = &#123;&#125;; for(key in parent)&#123; mergeField(key) &#125; for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125; &#125; function mergeField(key)&#123; const strat = strats[key] || defaultStrat; options[key] = strat(parent[key], child[key], vm, key) &#125; return options;&#125; 大家可以先思考一下合并2个对象需要注意些什么呢？ 假设构造函数的options和传入的options中都存在data，这个时候合并的是： 直接覆盖？ 如果覆盖的话是使用构造函数的data还是传入的data? 还是将data中的内容再进行合并呢？ 实际上不同的选项中的都存在自己的合并逻辑。 比如data选项和生命周期钩子选项合并策略肯定是不同的。 6.1 自定义策略在Vue中，可以自己定义不同的合并策略。 1234// 可以配置合并策略Vue.config.optionMergeStrategies = &#123; customArray:[]&#125;; 配置完以后，就可以在optionMergeStrategies获取用户配置的策略。 12// 源码中定义策略变量首先获取optionMergeStrategies 如果没有配置 optionMergeStrategies 默认是一个空对象const strats = config.optionMergeStrategies 然后再在 strats这个对象上添加属性，定义不同的策略。 123456789101112// data的合并策略strats.data = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125;// props的合并策略strats.props = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125;// computed的合并策略strats.computed = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125; 由于strats是一个对象，所以你如果定义了和内部定义的策略相同的选项，会被覆盖掉。也就意味着你无法重新定义 data、computed、props等内部策略 但是你可以自定义自己的选项。 12345678910111213import Vue from &quot;vue/dist/vue.esm.browser&quot; import Test from &quot;./Test.vue&quot; Vue.mixin(&#123; customArray:[1,3,5,8,9]&#125;) const vm = new Vue(&#123; render: h=&gt;h(Test), customArray: [1,4,5,7]&#125;).$mount(&quot;#app&quot;) console.log(vm); 比如你想要实现你自定义的 customArray选项 数组内容合并并且去重，可以使用使用optionMergeStrategies: 123456// parentVal代表构造函数上的选项值， childVal代表传入的选项值Vue.config.optionMergeStrategies.customArray = (parentVal,childVal)=&gt;&#123; // 其他Vue组件没有定义不进行处理 if(!childVal) return []; return Array.from(new Set([...parentVal,...childVal]))&#125; 我们打印一下这个实例，可以发现已经成功了。 6.2 默认的合并策略由于可以选项高度可自定义，所以 Vue中内置了一套默认的合并策略。 主要应对没有设置对应策略的合并情况。 123const defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal&#125; 可以看出来默认的合并策略是传入的options直接对构造函数的options进行强制覆盖（如果存在的话）。 6.3 el、propsData的合并策略可以看出来 el、propsData的合并策略和默认策略一样，只是多了一个开发环境的报错提示。 12345678910111213141516if (__DEV__) &#123; strats.el = strats.propsData = function ( parent: any, child: any, vm: any, key: any ) &#123; if (!vm) &#123; warn( `option &quot;$&#123;key&#125;&quot; can only be used during instance ` + &#x27;creation with the `new` keyword.&#x27; ) &#125; return defaultStrat(parent, child) &#125;&#125; 那么这个报错是什么意思呢？ 策略函数的的第三个参数vm代表vue实例。 而这个vm同时也是mergeOptions的第三个参数。 而 mergeOptions作为一个通用函数，不仅只是在实例初始化的时候被调用，同时也在Vue.extend、Vue.mixin等多个方法中被使用，这个时候还没有生成 vm实例，所以 vm为空。而 el属性、propsData属性是属于跟实例相关的属性，所以如果在Vue.mixin等方法中注入 el属性，则会报错。 综上所述，这行报错的意思就是禁止在除了实例化之外的地方注入 el选项。 比如调用： 123Vue.mixin(&#123; el:&quot;#select&quot;&#125;) 控制台就会报错： 6.4 data的合并策略data选项在 Vue中无疑是使用最频繁的选项之一。 所以它的合并策略相当复杂。 12345678910111213141516171819202122strats.data = function ( parentVal: any, childVal: any, vm?: Component): Function | null &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123; __DEV__ &amp;&amp; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &#x27;that returns a per-instance value in component &#x27; + &#x27;definitions.&#x27;, vm ) return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125; 6.4.1 在定义时报错我们知道通常在组件中，建议将 data定义成函数，因为如果将 data定义成普通对象，在该组件被引入到多处时，由于 extend函数内部会缓存这个构造函数，所以 data中的数据可能会被多个组件共享，导致 bug的产生。 childVal在这里代表传入的选项，即在组件中定义的选项。 所以会提示你需要将 data定义成函数，并且依旧调用 mergeDataOrFn。 在执行构造函数时创建子类构造函数时，虽然已经有了 vm了，但是并没有传入 mergeOptions。 123Vue.extend = function()&#123; Sub.options = mergeOptions(Super.options, extendOptions);&#125; 所以这个报错是在创建子类构造函数时进行提示的。 6.4.2 mergeDataOrFn1234567891011121314151617181920export function mergeDataOrFn( parentVal, childVal, vm) &#123; return function mergedInstanceDataFn() &#123; // instance merge const instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal const defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125;&#125; 该函数生成了一个合并函数。 当这个合并函数执行的时候将获取构造函数的上的data和传入的data 当传入的选项中存在 data，则调用mergeData合并 2 个data并返回。 当传入的选项中不存在 data时，则直接返回构造函数上的 data。 6.4.3 mergeData当构造函数的选项和传入的选项都存在 data时，需要调用 mergeData对 2 个选项进行合并。 123456789101112131415161718192021222324252627282930function mergeData( to, from, recursive = true)&#123; if (!from) return to let key, toVal, fromVal const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from) for (let i = 0; i &lt; keys.length; i++) &#123; key = keys[i] // in case the object is already observed... if (key === &#x27;__ob__&#x27;) continue toVal = to[key] fromVal = from[key] if (!recursive || !hasOwn(to, key)) &#123; set(to, key, fromVal) &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal) &#125; &#125; return to&#125; 这个函数的主要作用是合并两个对象的属性，可以用于初始化组件的数据对象，或者在组件的 created 钩子中合并父组件和子组件的数据。通过 recursive 参数，它可以灵活地进行浅合并或深度合并。 由于其中涉及到响应式数据的内容，所以不在这里深入讨论。 后面会单独出响应式数据的内容。 6.5 生命周期的合并策略1234567891011121314151617181920212223242526272829303132333435363738394041424344export const LIFECYCLE_HOOKS = [ &#x27;beforeCreate&#x27;, &#x27;created&#x27;, &#x27;beforeMount&#x27;, &#x27;mounted&#x27;, &#x27;beforeUpdate&#x27;, &#x27;updated&#x27;, &#x27;beforeDestroy&#x27;, &#x27;destroyed&#x27;, &#x27;activated&#x27;, &#x27;deactivated&#x27;, &#x27;errorCaptured&#x27;, &#x27;serverPrefetch&#x27;, &#x27;renderTracked&#x27;, &#x27;renderTriggered&#x27;]LIFECYCLE_HOOKS.forEach(hook =&gt; &#123; strats[hook] = mergeLifecycleHook&#125;)// 生命周期的合并策略export function mergeLifecycleHook( parentVal, childVal)&#123; const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal return res ? dedupeHooks(res) : res&#125;function dedupeHooks(hooks) &#123; const res = [] for (let i = 0; i &lt; hooks.length; i++) &#123; if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]) &#125; &#125; return res&#125; 上面这个三元表达式还是比较复杂的。 如果子类和父类都拥有相同的钩子选项，则将子类选项和父类选项合并。 如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项。 当子类不存在钩子选项时，则以父类选项返回。 子父合并时，是将子类选项放在数组的末尾，这样在执行钩子时，永远是父类选项优先于子类选项执行。 简单总结一下：对于生命周期钩子选项，子类和父类相同的选项将合并成数组，这样在执行子类钩子函数时，父类钩子选项也会执行，并且父会优先于子执行。 6.6 组件、指令、过滤器的合并策略12345678910111213141516171819export const ASSET_TYPES = [&#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;]ASSET_TYPES.forEach(function (type) &#123; strats[type + &#x27;s&#x27;] = mergeAssets&#125;)function mergeAssets( parentVal, childVal, vm, key) &#123; const res = Object.create(parentVal || null) if (childVal) &#123; return extend(res, childVal) &#125; else &#123; return res &#125;&#125; 很明显 组件、指令、过滤器的合并策略就是直接对构造函数的选项进行覆盖。 Object.create()方法创建一个新对象，使用创建的对象来提供新创建的对象的__proto__。 这意味着这个合并策略让内置的一些资源选项变成了原型链的形式。 这样子类必须通过原型链才能查找并使用内置的组件和内置指令。 6.7 watch的合并策略在使用 Vue 进行开发时，我们经常需要对数据变化做出响应，尤其是当涉及到需要执行异步操作或计算成本较高的任务时，watch 选项就显得尤为高效。 关于 watch 选项的合并策略，它与生命周期钩子的合并有相似之处：如果父组件和子组件有相同的观察字段，它们的 watch 选项将被合并为一个数组。 当监测到字段变化时，父类和子类的监听代码将被同时触发。 与生命周期钩子的处理方式不同，watch 选项在合并后的数组中可以呈现多种形式：它们可以是包含选项的对象，也可以是回调函数，或者是方法名的字符串。 这种灵活性使得 watch 选项能够适应更多的使用场景，无论是简单的数据变化监听还是复杂的异步操作处理。 通过这种方式，Vue 允许开发者在组件和混入中灵活地定义和合并 watch 选项，从而实现精细化的数据监控和管理。 12345678910111213141516171819202122232425262728strats.watch = function (parentVal,childVal,vm,key) &#123; //火狐浏览器在Object的原型上拥有watch方法，这里对这一现象做了兼容 // var nativeWatch = (&#123;&#125;).watch; if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125; if (childVal === nativeWatch) &#123; childVal = undefined; &#125; // 没有子，则默认用父选项 if (!childVal) &#123; return Object.create(parentVal || null) &#125; &#123; // 保证watch选项是一个对象 assertObjectType(key, childVal, vm); &#125; // 没有父则直接用子选项 if (!parentVal) &#123; return childVal &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; // 父的选项先转换成数组 if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret&#125;; 下面结合具体的例子看合并结果： 1234567891011121314151617181920212223242526var Parent = Vue.extend(&#123; watch: &#123; &#x27;test&#x27;: function() &#123; console.log(&#x27;parent change&#x27;) &#125; &#125;&#125;)var Child = Parent.extend(&#123; watch: &#123; &#x27;test&#x27;: &#123; handler: function() &#123; console.log(&#x27;child change&#x27;) &#125; &#125; &#125;, data() &#123; return &#123; test: 1 &#125; &#125;&#125;)var vm = new Child().$mount(&#x27;#app&#x27;);vm.test = 2;// 输出结果parent changechild change 简而言之:Vue 在处理 watch 选项的合并时，会将子组件与父组件的 watch 选项合并成一个数组。这个数组中的成员可以是回调函数、包含配置的对象，或者是指向函数的方法名。这样的设计提供了灵活的选项，以适应不同的数据监控需求。 6.8 props methods inject computed合并在 Vue 的源码设计中，props、methods、inject 和 computed 这些选项被归为一类，并且它们遵循相同的合并策略。 12345678910111213141516171819strats.props = strats.methods = strats.inject = strats.computed = function ( parentVal, childVal, vm, key) &#123; if (childVal &amp;&amp; __DEV__) &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = Object.create(null) extend(ret, parentVal) if (childVal) extend(ret, childVal) return ret&#125; 简而言之。 父类没有相应的选项，则直接使用子类的选项 当父组件和子组件都提供了这些选项时，子组件的选项会覆盖父组件的选项。这种策略确保了组件能够继承和扩展行为，同时允许子组件通过提供自己的选项来覆盖继承自父组件或混入的选项。 举个例子： 12345678910111213141516171819202122232425262728var Parent = Vue.extend(&#123; methods:&#123; handleClick:function()&#123; console.log(&quot;父类点击事件&quot;) &#125;, getParentName:function()&#123; console.log(&quot;获取父类名称&quot;) &#125; &#125;&#125;)var Child = Parent.extend(&#123; methods:&#123; handleClick:function()&#123; console.log(&quot;子类点击事件&quot;) &#125;, getChildName:function()&#123; console.log(&quot;获取父类名称&quot;) &#125; &#125;&#125;)var vm = new Child().$mount(&#x27;#app&#x27;);console.log(vm.$options.methods);// 合并子类和父类，遇到相同的属性，使用子类覆盖父类&#123; getChildName:f(), getParentName:f(), handleClick:f(),&#125; 6.9 provide合并确保了子组件的 provide 选项可以覆盖父组件的同名选项，同时保留了父组件的其他选项。这种设计允许组件在继承和扩展 provide 数据时有更多的灵活性。通过这种方式，Vue 允许开发者在组件树中有效地传递数据，而无需通过每个层级的组件显式地传递 props。 123456789101112131415strats.provide = function (parentVal, childVal) &#123; if (!parentVal) return childVal return function () &#123; const ret = Object.create(null) mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal) if (childVal) &#123; mergeData( ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive ) &#125; return ret &#125;&#125;"},{"title":"🔥Vue2的基本使用和原型设计","path":"//posts/vue2-constructor.html","content":"专栏第三篇-基本使用和原型设计 &emsp;&emsp;在前面两篇文章中，我们熟悉了源码的目录结构以及构建方式。 &emsp;&emsp;今天我们继续来说下Vue的原型设计。 一、Vue的基础使用官方推荐 Vue 的使用方式主要有两种：通过 CDN 和 NPM。 使用 CDN，我们可以通过在 HTML 中添加 &lt;script&gt; 标签直接引入打包好的 vue.js 文件，这是一种快速且简便的方法。 12// CDN方式&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; 而 NPM 方式则涉及到与模块打包工具如 webpack 或 Browserify 的集成，通过执行 npm install vue 命令来安装 Vue，这通常是我们在开发大型应用时的首选方式。 12// NPM方式import Vue from &#x27;vue&#x27;; 当Vue被引入时，通常我们会在入口文件中去 new 一个Vue实例。 然后再利用实例上的$mount方法将对应的模版内容挂载到浏览器中#app节点的位置上。 12345678// NPM方式// Nodejs版本import Vue from &#x27;vue/dist/vue.common&#x27;;// 需要实例化 Vuenew Vue(&#123; template:`&lt;div&gt;Hello World&lt;/div&gt;`&#125;).$mount(&quot;#app&quot;); 二、为什么Vue不是一个类上一节我们说了使用 Vue 需要 new 一下。 所以你可能会习惯性的认为 Vue 是一个类。 但是我们打开Vue被定义的core/instance/index.js文件。 123456function Vue(options) &#123; if (__DEV__ &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; 会发现Vue是使用函数定义的。 那么Vue源码中为什么不使用类呢？ 在Vue中有大量的扩展实例属性的操作如：Vue.prototype.$mount=xxx。 其实本质上类只是function的语法糖。 虽然说使用类也可以进行扩展： 123456class Animate&#123;&#125;Animate.prototype.eat = function()&#123; console.log(&quot;动物吃东西&quot;)&#125;new Animate().eat();// 动物吃东西 但是用类和原型这么混合使用，难免会让人感到不适，也算是一种开发规范和习惯吧。 大部分开源库依旧使用的是构造函数function的方式。 三、必须使用new关键字来调用可以看到在Vue构造函数内部存在一个判断 this instanceof Vue，那么这行代码应该如何理解呢？ 我们知道通过 instanceof可以顺着原型链向上查找对应的构造函数。 所以这个判断的意思就是检查当前上下文（this）是否是一个 Vue实例。 如果不是一个实例，就会给你一个警告。 这要告知开发者Vue应该要作为一个构造函数来使用。 123456// instance/index.jsfunction Vue(options) &#123; if(__DEV__ &amp;&amp; !this instanceof Vue)&#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125;&#125; 假设你这么使用 Vue： 1const vm = Vue() 那么你将会在控制台看到一条报错信息。 四、Vue的原型设计Vue是一个基于原型设计的前端框架。 在Vue被引入 import Vue from vue时，会通过多个函数在Vue原型上添加上一系列的方法。 123456// 该函数在 Vue被引入时执行export function lifecycleMixin(Vue)&#123; Vue.prototype._update = ()=&gt;&#123; // xxxx &#125;&#125; 那么在Vue.prototype上定义方法有什么作用呢？ 前面2节，我们说到 Vue本质上是一个构造函数： 123function Vue()&#123; //xxx&#125; 所以我们可以通过 new关键字来创建一个 vue实例。 1const vm = new Vue(); 构造函数与原型对象：每个构造函数都有一个 prototype属性，指向一个对象。这个对象被叫做原型对象，包含了由该构造函数创建的实例共享属性和方法。 实例对象的 __proto__ 属性：每个实例对象都有一个 __proto__ 属性，指向构造函数的原型对象。 所以我们可以得出结论：Vue构造函数的显式原型（Vue.prototype）和基于它创建的实例的隐式原型（vm.__proto__）指向的是同一块内存空间。 当 Vue实例访问某个属性时，如果在自身属性中找不到，则会沿着__proto__属性指向的原型对象进行查找。 所以通过 vm 可以访问到定义在 Vue.prototype 的属性和方法。 通用这种方式，可以很方便的扩展方法，并不用显示的在 vm 上设置方法，做到了相对隔离。 五、Vue.extend利用原型链继承生成“子类“构造函数Vue.extend是定义在Vue这个构造函数上的方法。 该方法主要用于创建Vue构造函数的“子类“，该“子类“继承 Vue构造函数上的原型方法和原型属性。 虽然Vue在技术上不是传统意义上的类，但是Vue.extend提供了一种类似于面向对象编程中继承的方式来定义组件。 123456789101112131415// 对原函数进行了一些简化 只保留了核心Vue.extend = function()&#123; // this 为 Vue构造函数 const Super = this; // Sub 为 VueComponent构造函数，代表组件构造函数 const Sub = function VueComponent(this)&#123; // 和 Vue构造函数一样 会调用_init方法 this._init(options); &#125;; // 基于 Vue.prototype 创建一块新的内存，共享其属性和方法。 Sub.prototype = Object.create(Super.prototype); // 修正 constructor指向 Sub.prototype.constructor = Sub; return Sub;&#125; 我们简单的分析一下这几行代码。 声明了Super变量和 Sub变量分别指向Vue构造函数和 VueComponent构造函数。 5.1 使用场景在Vue源码内部和使用Vue编写业务代码时都可以使用 Vue.extend这个 api。 5.1.1 内部创建组件每一个Vue组件都对应着一个实例。 而这些实例都是通过 extend 方法创建的 VueComponent构造函数 生成的。 在render阶段，也就是在生成组件的vnode的时候会通过 extend 方法创建VueComponent构造函数。 并赋值到 vnode 中的 componentOptions属性中。 1234567891011// 创建组件的 vnode 的方法export function createComponent(Ctor,context)&#123; // _base在引入时被设置为 Vue // 这里的options后面我们会详细说明 const base = context.$options._base; // 创建Vue子类构造函数 Ctor = base.extend(); return new Vnode( &#123;componentOptions:&#123;Ctor&#125;&#125; )&#125; 这里的_base实际上就是 Vue。 这里的 context是vm实例，vm.$options是在实例化构造函数时通过 mergeOptions函数生成的。 然后在update阶段（渲染页面），会基于Ctor生成对应的实例，执行相应的初始化、渲染方法等。 12345// 每个组件都会调用这个方法来创建对应的实例// 这里的 componentOptions.Ctor 就是对应的VueComponent构造函数export function createComponentInstanceForVnode(vnode)&#123; return new vnode.componentOptions.Ctor()&#125; 5.1.2 在业务中的实际应用场景在实际业务场景中，有很多地方都可以利用 extend 来扩展组件。 包括创建可复用的组件、动态组件、全局和局部注册、临时组件、自定义指令和插件。 我们常用的 Element框架内部就利用了 Vue.extend 来扩展某些临时性的组件，例如模态对话框、提示信息等。 通过 Vue.extend 创建的组件构造函数可以按需创建和销毁，适合这类临时组件的管理。 123456789101112131415161718const Main = &#123; template:&#x27;&lt;div&gt;hello main&lt;/div&gt;&#x27;&#125;const NotificationConstructor = Vue.extend(Main);let instance;const Notification = function() &#123; // 通过VueComponent创建组件实例 instance = new NotificationConstructor(); // 使用$mount可以创建一个DOM节点 并挂载到instance.$el上 instance.$mount(); document.body.appendChild(instance.$el); return instance;&#125; Notification(); $mount方法如果没有传参不会挂载，但是依旧可以生成 DOM节点，并赋值在 vm.$el上。 在 element 中的 Notification组件 就使用了 extend 进行扩展。 5.1.3 使用VueComponent继续扩展它的“子类”构造函数需要关注的是在Vue.extend中，将Vue.extend方法同时赋值给了 VueComponent。 意味着赋予了 VueComponent继续扩展的能力： 12345678Vue.extend = function()&#123; const Super = this; const Sub = function VueComponent()&#123; this._init(); &#125; // 省略部分代码 Sub.extend = Super.extend;&#125; 这意味着我们可以无限的基于 VueComponent和它的“子类”扩展子类。 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from &quot;@/my-vue2/platforms/web/entry-runtime-with-compiler-esm&quot;// 基于Vue构造函数创建的基础构造函数const VueComponentConstructor = Vue.extend(&#123; template:`&lt;div&gt;&#123;&#123; name &#125;&#125;我是构造函数&lt;/div&gt;`, data()&#123; return &#123; name:&quot;VueComponentConstructor&quot; &#125; &#125;&#125;);// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild1Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild1Constructor&quot; &#125; &#125;&#125;)// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild2Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild2Constructor&quot; &#125; &#125;&#125;)function addNode()&#123; const vm1 = new VueComponentConstructor(); const vm2 = new VueComponentChild1Constructor(); const vm3 = new VueComponentChild2Constructor(); vm1.$mount() vm2.$mount() vm3.$mount() document.body.appendChild(vm1.$el) document.body.appendChild(vm2.$el) document.body.appendChild(vm3.$el)&#125;addNode(); 上述代码中，VueComponentConstructor 是通过 Vue.extend 创建的一个基础组件构造函数。 在这个基础构造函数中传入了模板选项，我们之后创建的构造函数就可以复用 template选项，避免编写重复的模板。 我们这里只是简单的举了一个例子，通过这个例子我们了解到了extend的重要意义。真实的复用结构肯定更为复杂。 不过在实际开发中，一般我们应用中基本只存在 Vue构造函数和它的直接构造函数 VueComponent。 在组件库等基础库中可能会存在这种子类继续扩展子类的情况。 六、为什么Vue实例被叫做 vm源码中你会看到大量的 vm。 使用 new Vue() 创建的Vue实例通常被叫做 vm。 Vue被称为VM，是因为它是一个基于MVVM（Model-View-ViewModel）架构的前端框架。 在MVVM架构中，VM代表ViewModel，负责管理视图（View）和数据模型（Model）之间的通信和交互。 七、引入时基于原型挂载方法Vue是基于原型设计的前端框架。 后续的操作都是在调用原型上定义的方法。 那么 Vue是在什么时候对这些方法进行挂载的呢？ 一部分是在 Vue引入的时候挂载的，一部分是在 Vue实例化的时候进行挂载的。 那么 Vue是如何在引入的时候进行挂载呢？ 我们打开入口文件可以看到 Vue 被有层次的导入多个文件中，然后在文件中添加上对应的原型方法。 比如在: 在platforms/web/runtime-with-compiler.js文件中： Vue上扩展了定义了Vue.compile 重写了 Vue.prototype.$mount 在platforms/web/runtime/index.js文件中： 定义了Vue.prototype.$mount 定义了Vue.prototype.patch 扩展了扩展 Vue.config一些属性 扩展 Vue.options.directive 扩展 Vue.options.components 在core/index.js文件中： 使用了initGlobalAPI定义了一些全局方法 如 mixin 定义了Vue.prototype.$isServer 定义了Vue.prototype.$ssrContext 定义了Vue.FunctionalRenderContext 定义了Vue.version 在core/instance/index文件中： 使用 initMixin 注入了 初始化有关的属性如：Vue.prototype.$init 使用 stateMixin 注入了 跟状态有关的属性如：Vue.prototype.$set、Vue.prototype.$watch、Vue.prototype.$delete 使用 eventsMixin 注入了 跟事件有关的属性如：Vue.prototype.$on、Vue.prototype.$off、Vue.prototype.$once 使用 lifecycleMixin 注入了 跟整个 vue生命周期更新有关的属性如：Vue.prototype.$update 使用 renderMixin 注入了 跟渲染相关的属性如：Vue.prototype._render 可以发现 Vue源码中是一层一层进行导入。 那么Vue为什么要这么设计目录结构呢？ 我们可以看到每个模块都对 Vue对象做了相应的处理，比如说扩展属性、扩展实例属性等。 Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有。 这种技巧便于后期Vue的维护和迭代。"},{"title":"🔥Vue2源码构建","path":"//posts/vue2-core-build.html","content":"专栏第二篇-源码构建 &emsp;&emsp;在上一篇文章中，我们大概了解了Vue的目录结构是怎么样的。 &emsp;&emsp;在这一篇文章中，我们会知晓 Vue 是如何构建的。 一、Vue的构建1.1 根据使用场景打包在上一篇专栏文章中，我们熟悉了 Vue源码中的代码结构。 其中我们介绍了几个入口文件： entry-runtime.ts entry-runtime-with-compiler.ts entry-runtime-esm.ts entry-runtime-with-compiler-esm.ts 在我们开发项目结束后，需要进行打包并部署到线上。 通常我们项目打包时需要一个入口文件， webpack通过这个入口文件递归文件进行依赖分析然后打包。 其实框架打包也一样，同样需要一个入口文件进行递归依赖分析打包生成 js文件方便我们进行使用。 和项目不一样的是，项目往往只有一个入口文件，而框架会根据不同的情况采用不同的入口文件进行打包，上面的这四个文件就是Vue框架的入口文件。 Vue是使用rollup进行打包的。 为了方便用户进行使用，Vue在使用rollup进行打包时根据开发环境&#96;和开发模式打包出了不同功能的文件，以适用于不同的使用场景。 构建的rollup打包脚本的代码在scripts/config.js文件中。 1234567891011121314151617const builds = &#123; &#x27;runtime-cjs-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.dev.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;development&#x27;, banner &#125;, &#x27;runtime-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, banner &#125;, // 省略&#125; 总共打包生成 12 个文件，这些文件可以适用于不同的场景。 根据是否带编译器的角度上分为Full和Runtime-Only 2个版本。Full版本包含编译器和运行时的全部功能。Runtime-Only 仅含运行时功能。 打包的文件根据使用场景分为 esm、cjs、umd三个版本。其中umd可以通过&lt;script&gt;标签引入直接在浏览器中使用，Vue会暴露一个全局变量 Windows.Vue。而 CommonJS适配const Vue &#x3D; require(‘vue’)这种 node式的模块系统。ES则适配import Vue from ‘vue’这种es6格式。 打包的文件根据环境分为 dev&#x2F;prod，在开发环境中可以使用 dev版本的 js文件，而部署到客户生产环境就可以使用 prod版本的 js文件。 dev版本的文件有一些提示，会在开发者开发时便于调试。 1.2 Full版本的Vue到底是什么意思？ 平时我们开发中只使用了 runtime-only 版本。 而 Full版本中不仅有 runtime-only部分，还包括编译器部分。 所谓编译器，就是在Vue内部的编译器可以将模板转化为对应的render函数。 在Vue内部渲染就是调用的 render方法生成 vnode。 因为编译器代码体积比较大，而且如果在运行的时候进行模板编译，极大可能会消耗性能。 所以我们一般在开发项目时，使用 runtime-only版本。 在 webpack预编译阶段，就将.vue文件编译成render函数，在运行时直接运行 render函数就可以获取到对应的 vnode。 通过 runtime-only 和 esm很容易推测出来我们项目在开发阶段中使用的是vue.runtime.esm.js 1.3 使用 Full 还是用 Runtime-Only版本这需要依据具体情况进行具体分析。 倘若你需要用到 Vue 所提供的 html 模板功能，那就选用 Full 版本。 反之，最好采用 Runtime-only 版本，原因在于它比 Full 版本的文件体积大约小 30%。 *.vue 单文件组件会被 vue-loader 直接构建成为 JavaScript，并未使用到 Vue 的编译器，所以可以使用 Runtime-only 版本。 二、神奇的“__DEV__”在前面我们说到，在打包成开发环境的包时，往往会存在很多提示信息。 而源码中判断开发环境通常都是使用__DEV__来进行判断。 2.1 __DEV__的本质在Vue源码中，到处都能看到__DEV__变量的身影。 但是你看不到__DEV__被 import 引入，甚至你都找不到在哪里定义了这个变量。 这个变量在 Vue 中代表开发环境。 当你在源码中看见 if(__DEV__) 代表这个if中的逻辑只有在开发环境才进入执行。 vue的构建工具是rollup，在rollup打包的时候会使用@rollup/plugin-replace 插件来替换源代码中的__DEV__变量，如下： 123456789101112......const replace = require(&#x27;@rollup/plugin-replace&#x27;)......// built-in varsconst vars = &#123; ...... __DEV__: `process.env.NODE_ENV !== &#x27;production&#x27;`, ......&#125;......config.plugins.push(replace(vars))...... 所以__DEV__的本质就是 proess.env.NODE_ENV!== &#39;production&#39; 。 2.2 约定俗成的“process.env.NODE_ENV!&#x3D;&#x3D;’production”将 DEV 变量转换为 process.env.NODE_ENV !== &#39;production&#39; 这样的条件表达式在现代前端构建工具中是一种常见的约定和实践。 原因有以下几点： 环境区分：通过 process.env.NODE_ENV 可以方便地在代码中区分开发环境（development）与生产环境（production）。例如，在开发环境中启用特定的警告、日志记录或者热加载功能；而在生产环境中则禁用这些功能以优化性能。 Tree-shaking 和 UglifyJS：当打包工具如 Rollup 或 webpack 遇到 process.env.NODE_DEV !== &#39;production&#39; 包裹的代码块时，在生产环境下会自动去除（tree-shake）其中仅在开发环境中需要的代码，因为该条件表达式最终会被编译器或压缩工具识别为始终为 false，因此包裹的代码不会被打包进最终产物。 标准化：许多框架和库都采用了这种模式来处理环境相关的逻辑，这样开发者可以统一遵循这个约定，减少配置和理解成本。 灵活配置：由于构建工具支持 .env 文件或其他方式来设置 NODE_ENV 的值，这使得项目配置更加灵活，团队成员可以根据实际需求快速切换不同环境下的行为。 跨平台兼容性：process.env.NODE_ENV 作为一个标准 Node.js 环境变量接口，已经被广泛接受，并且在各种打包工具中都有相应的机制将其映射到最终浏览器执行的代码中，确保了跨平台的一致性。 一般项目在开发环境中将process.env.NODE_ENV设置为development，在生产环境中设置为production。 所以通过process.env.NODE_ENV !== &#39;production就可以判断现在是处于什么环境下。 2.3 在本地环境配置__DEV__因为我们这门课程是写一个完整版的vue2。 所以我们也会使用__DEV__这个变量代表开发环境。 我们本地的项目是使用 vue-cli 搭建的。 可以在 webpack配置文件 vue.config.js 文件新增一个配置达到这个目的。 1234567891011121314// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, configureWebpack: &#123; plugins: [ new webpack.DefinePlugin(&#123; __DEV__: process.env.NODE_ENV === &#x27;development&#x27;, &#125;), ], &#125;,&#125;) DefinePlugin 插件的主要作用是在编译时将预定义的值替换到源代码中的特定变量。 我们执行yarn start启动这个项目打印一下__DEV__为 true即为成功。 1console.log(__DEV__); // true"},{"title":"🔥Vue2目录结构窥探","path":"//posts/vue2-catalog.html","content":"专栏第一篇-目录结构窥探 &emsp;&emsp;因为 Vue 框架是在十多年前产生的一个开源前端框架，经过一些迭代修复，目前已经趋于稳定。 &emsp;&emsp;Vue2框架在可维护性、性能、TypeScript支持等方面有一些痛点，所以尤雨溪推出了 Vue3版本。 &emsp;&emsp;不过目前大部分公司因为成本等方面的原因，还是使用在 Vue2 版本，所以我们这个专栏就来探讨一下 Vue2 的源码部分。 一、非核心Vue源码目录大致结构 我们看的Vue源码版本2.7.16是Vue2的最新版本 我们打开Vue2的github源码地址。 可以看到其中有很多个目录文件，但是其实 Vue2 源码核心的都是在 src文件夹中的。 我们这章大概介绍一下除了 src 下面的一些目录，了解一下大体的作用是什么。 1.1 .github该文件夹用于存放与 gitHub 相关的配置文件或者脚本。 1.2 benchmarks该文件夹用于存放性能基准测试的相关文件和脚本。 性能基准测试是一种用来评估软件性能的方法，它通过模拟真实世界中的使用场景来测量软件在不同条件下的表现。 可以确保新功能不会降低框架的整体性能，同时也可以用来优化现有代码，使其更加高效。 1.3. compiler-sfc该文件夹下的内容逻辑就可以协助 webpack进行解析处理单文件组件（SFC）。 通常我们开发时会借助webpack将vue文件转化为一个JS对象。 可以查看他的 index.js文件 发现实际上就是导出了@vue/compiler-sfc这个包。 1module.exports = require(&#x27;@vue/compiler-sfc&#x27;) 1.4. dist该文件夹为打包文件存放的地方。 1.5. examples该文件夹用于存放示例应用程序或代码片段，目的是展示 Vue.js 的基本用法和功能。 1.6 packages该文件夹主要用于组织 Vue.js 的各个子包或模块。 随着 Vue.js 项目的复杂度增加，将不同的功能模块拆分成独立的子包已经成为了一种常见的做法。 这样不仅有利于模块化开发，还能方便依赖管理和发布。 该目录下有三个目录。 1.6.1 compiler-sfc该文件夹下的内容主要用于处理单文件组件。 1.6.2 server-renderer该文件夹下的内容和服务端渲染相关的内容。 1.6.3 template-compiler该文件夹下的内容存放模板编译相关的逻辑。 1.7 scripts该文件夹主要用于存放各种自动化脚本。 这些脚本通常用于辅助项目的构建、测试、发布和其他开发任务。 1.8 src该文件夹是存放 vue框架核心源码的地方。 1.9 test该文件夹主要用于存放各种类型的测试文件，这些测试文件用于验证 Vue.js 框架的功能是否按预期工作。 1.10 types该文件夹主要用于存放 TypeScript 类型定义文件。 这些类型定义文件为 Vue.js 提供了类型支持，使得在使用 Vue.js 时可以享受静态类型检查的好处，从而提高代码质量和开发效率。 1.11 .editorconfig该文件用于指定编辑器应该遵循的一系列编码和格式化规则。 1.12 .git-blame-ignore-revs该文件用于告诉 Git 在执行 git blame 命令时忽略某些特定的提交记录。 1.13 .gitignore该文件用于指定 Git 应该忽略哪些文件或目录，即不将这些文件或目录纳入版本控制。 1.14 .prettierrc该文件用于配置 Prettier。 Prettier是一个流行的代码格式化工具，旨在帮助开发者保持代码风格的一致性。 Prettier 可以自动格式化代码，使其符合预设的编码规范，从而提高代码的可读性和一致性。 1.15 BACKERS.md该文件主要用于记录和支持 Vue.js 项目的赞助者或贡献者。 这份文件通常列出了那些通过资金或其他形式支持 Vue.js 发展的个人或组织。 1.16 CHANGELOG.md该文件主要用于记录项目的版本变更历史，包括每个版本的新增功能、改进、修复的错误以及其他重要的变更信息。 1.17 LICENSE该文件用来定义和声明项目使用的许可协议的文件 1.18 README.md该文件为项目的入口文档文件。 文件提供了关于项目的概述、安装步骤、使用方法、贡献指南等关键信息。 1.19 api-extractor.json该文件用于配置 API Extractor 工具（这是一种用于生成 TypeScript 类型定义文档和 API 报告的工具） API Extractor 通常用于大型 TypeScript 项目中，帮助开发者生成详细的 API 文档，并确保类型定义的一致性和准确性。 1.20 api-extractor.tsconfig.json该文件用于配置 TypeScript 编译选项，以配合 API Extractor 工具生成 API 文档和类型定义文件。 这个文件通常包含了一些特定的 TypeScript 配置，确保 API Extractor 能够正确地解析和处理源代码。 1.21 package.json该文件是项目的核心配置文件，用于描述项目的元数据以及项目依赖关系和构建脚本。 1.22 pnpm-lock.yaml该文件是由 pnpm 包管理器生成的锁定文件。 用于记录项目中所有依赖项的具体版本信息，以及它们是如何被安装的。 pnpm 是一种替代 npm 和 yarn 的高性能包管理器，它具有更快的速度和更少的磁盘空间占用。 1.23 pnpm-workspace.yaml该文件用于配置 pnpm 工作区（workspace）。 pnpm 支持多项目的工作区模式，这种模式允许多个相关项目共享依赖，并且可以方便地管理这些项目的依赖关系和构建流程。 1.24 tsconfig.json该文件是 TypeScript 编译配置文件，用于定义 TypeScript 编译器在编译源代码时应遵循的选项和规则。 1.25 vitest.config.ts该文件用于配置 Vitest 的测试框架配置文件。 Vitest 是一个现代化的 JavaScript 和 TypeScript 测试框架，它提供了快速的测试运行速度和丰富的功能集，适用于前端和后端开发。 二、src目录下有什么？上一章节我们简单介绍了一下非 src文件夹下面的一些文件内容。 这些都是在一个工程化的框架项目中必不可少的部分。 那么本节的内容就是看下 src 文件夹下包含哪些内容。 下面这个目录结构去除了 ts相关的声明文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147src├─shared| ├─constants.ts| └util.ts├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 三、shared文件夹 1234src├─shared| ├─constants.ts| └util.ts 这个文件夹包含了一些在不同环境下都需要共享的工具函数或者常量。 这个工具函数与平台无关。 既可以在客户端使用，也可以在服务端使用，因为它们不依赖于任何特定的环境特性（例如 DOM）。 constants.ts文件中定义了一些在整个框架内频繁使用的常量，比如特殊的字符串标识符、配置键名等。 util.ts文件中定义了一些基础的工具函数，比如 isString、isObject和其他一些常用的功能，如深拷贝、警告输出等。 这些文件的主要目的是为了提高代码的可维护性和复用性。 通过将这些功能抽象出来，Vue.js 能够保持核心逻辑的简洁，并且确保不同部分之间的兼容性。 这样做的好处是减少了重复代码，使得代码更容易理解和维护。 四、platforms文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152src├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts 4.1 为什么会有这么一个platforms目录呢？platforms 翻译成中文表示“平台“。 vue作为一个跨平台的框架，不仅支持传统的web浏览器环境，还支持其他平台，如服务器渲染（SSR），甚至是非浏览器环境。 因此，将 Web 平台相关的代码单独放在一个目录中，有助于保持代码的清晰度和可维护性。 Web平台有许多特定的功，比如 DOM操作、CSS动画、事件处理等。这些功能在 Vue的 Web版本中是必需的，但是在其他平台上则不一定适用。将这些代码组织在一起，可以确保它们只在 Web平台上生效，而不会影响到其他平台的构建。 当然目前仅仅只有一个web平台，所以平台下只有一个 web目录。 4.2 几个入口文件entry-*文件主要用于定义不同构建配置下的入口点。 web目录下有entry-compiler.ts、entry-runtime-esm.ts、entry-runtime-with-compiler-esm.ts、entry-runtime-with-compiler、entry-runtime.ts五个入口文件。 在vue源码scripts/config.js中有打包相关的配置，其中就利用了这几个入口文件。 4.2.1 entry-compiler.ts该文件是一个提供编译 html 模板相关接口的模块，通常用于为 Vue 编写的构建插件，比如 vue-loader。 1234567891011// scripts/config.jslet builds = &#123; compiler: &#123; entry: resolve(&#x27;web/entry-compiler.ts&#x27;), dest: resolve(&#x27;packages/template-compiler/build.js&#x27;), format: &#x27;cjs&#x27;, external: Object.keys( require(&#x27;../packages/template-compiler/package.json&#x27;).dependencies ) &#125;,&#125; 4.2.2 entry-runtime.ts &amp; entry-runtime-esm.ts这两个文件都用于构建仅包含运行时的文件，不具备编译 html 模板功能。区别是一个是 esm格式，一个不是。 12345678910111213141516// scripts/config.jslet builds = &#123; &#x27;runtime-esm&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.esm.js&#x27;), format: &#x27;es&#x27;, banner &#125;, &#x27;runtime-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.min.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;production&#x27;, banner &#125;,&#125; 4.2.3 entry-runtime-with-compiler.ts &amp; entry-runtime-with-compiler-esm.ts这两个文件都用于构建同时包含编译器和运行时的全功能文件。 区别是一个是 esm格式，一个不是。 下面的full-cjs-prod可以看出来这个全版本，有 vue的全部功能。 1234567891011121314151617181920// scripts/config.jslet builds = &#123; &#x27;full-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.ts&#x27;), dest: resolve(&#x27;dist/vue.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, &#x27;full-esm-browser-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.esm.browser.min.js&#x27;), format: &#x27;es&#x27;, transpile: false, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;,&#125; 4.3 runtime-with-compiler.ts之前我们了解到 Vue分为 runtime 和 compiler两个部分。 而 runtime-with-compiler.ts文件就是既有 runtime部分 也有 compiler部分。 上面的entry-runtime-with-compiler.ts和entry-runtime-with-compiler-esm.ts就是基于这个文件进行打包的。只是分别扩展了vue的一些功能。 4.4 util目录该目录包含了 Vue在 Web平台上常用的工具函数和使用工具。 这些工具主要用于处理与 Web平台相关的各种细节。 4.5 runtime目录4.5.1 components目录该目录下存放着 vue web平台中使用的组件如 transition、transition-group组件等，借助这些组件可以实现过渡动画。 4.5.2 directives目录该目录下的主要存放是 vue的内部指令文件，如v-model、v-show指令。 4.5.3 modules目录该目录下的主要存放的是vue在 web平台上常见的 DOM操作和特性处理。 4.5.3.1 attrs.ts这个文件实现了处理元素属性的模块，它负责更新和管理元素的属性。例如，当数据模型中的属性值发生变化时，需要更新 DOM 中相应的属性值。 4.5.3.2 class.ts这个文件实现了处理元素类的模块，它负责更新和管理元素的类名。例如，根据数据模型中的条件动态添加或移除类名。 4.5.3.3 dom-props.ts这个文件实现了处理 DOM 属性的模块，它负责同步和更新 DOM 属性，如 value, checked 等。这在处理表单控件时尤为重要。 4.5.3.4 events.ts这个文件实现了处理事件绑定的模块，它负责在 DOM 元素上添加、更新和移除事件监听器。这使得 Vue.js 可以响应用户的交互行为，并触发相应的事件处理函数。 4.5.3.5 style.ts这个文件实现了处理内联样式的模块，它负责更新和管理元素的内联样式。例如，根据数据模型中的条件动态设置或移除内联样式。 4.5.3.6 transition.ts这个文件实现了处理过渡动画的模块，它负责应用过渡类，管理过渡状态，并确保过渡效果正确地应用于元素。 4.5.4 transition-util.ts该文件包含了 Vue.js 在 Web 平台上与过渡动画相关的实用工具函数。 这些工具函数为 &lt;transition&gt; 和 &lt;transition-group&gt; 组件提供了底层的支持，使得 Vue.js 能够管理和控制元素的过渡效果。 4.5.5 patch.ts该文件是 Vue.js 在 Web 平台上负责 DOM 更新的核心模块。 这个文件定义了 patch 函数，它是 Vue.js 渲染引擎的关键部分之一，用于将虚拟 DOM（Virtual DOM）更新到实际的 DOM 上。 他实际上引用了core/vdom/patch目录下的 createPatchFunction函数。 4.5.6 node-ops.ts该文件包含了 Vue.js 在 Web 平台上进行 DOM 操作的具体实现。 这个文件定义了一组方法，这些方法是 Vue.js 渲染引擎在更新 DOM 时使用的具体操作。如添加节点、删除节点等。 4.5.7 class-util.ts该文件包含了 vue 在 web平台上与元素类相关的使用工具函数。 这些工具函数用于处理元素的类名，包括添加、删除和切换类名等操作。 4.6 compiler目录该目录包含了 Vue.js 在 Web 平台上进行模板编译的相关实现。 这个目录中的文件和模块负责将 Vue 模板字符串转换为可以被 Vue 渲染引擎执行的渲染函数。 其中 directives目录下的文件 定义了一些内置指令如v-html、v-text。 modules目录中存放了对应处理模板编译时需要的一些通用处理方法。 其余文件为通用工具等。 五、core文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071src├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts core文件夹是存储这 vue的核心逻辑。 5.1 components目录该目录下存放了一些内置组件如 keep-alive。 5.2 global-api目录该目录包含了 Vue.js在核心层面提供的全局 API的实现。 如Vue.mixin、Vue.use、Vue.extend等。 5.3 instance目录该目录包含了 vue实例相关的主要实现。 其中:render.js负责渲染相关的逻辑、lifecycle.js负责管理 vue实例的生命周期钩子、events.js负责处理 vue实例上的事件、state.js负责管理 vue实例的数据状态等。 5.4 observe目录该目录包含了 Vue.js 中用于实现响应式系统的核心模块。 这部分代码负责将数据对象转换为可观察的对象，使得数据的变化能够被追踪，并自动更新依赖于该数据的视图。 5.5 vdom目录该目录包含了Vue.js 处理虚拟 DOM (Virtual DOM) 的相关实现。 虚拟 DOM 是 Vue.js 渲染机制的核心部分，它通过内存中的 JavaScript 对象来表示真实的 DOM 节点。 六、compiler文件夹该目录存放了vue模板编译的相关内容。 1234567891011121314151617181920212223src├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 七、总结我们这章大概的介绍了 vue的大体目录结构。"},{"title":"二、Java语言发展历史","path":"//posts/Java语言发展历史.html","content":"1、Java语言发展历史 发行版本 发行时间 备注 Java 1995.05.23 SUN公司在 Sun world会议上正式发布 Java和 HotJava浏览器 Java1.0 1996.01.23 SUN公司发部了 Java的第一个开发工具包 Java1.1 1997.02.19 Java1.2 1998.12.08 拆分成：J2SE(标准版)、J2EE(企业级)、J2ME(小型版) Java1.3 2000.05.08 Java1.4 2004.02.06 Java5.0 2004.09.30 1.版本号从 1.4 直接更新至 5.0； 2.平台更名为JavaSE、JavaEE、JavaME Java6.0 2006.12.11 2009.04.20 Oracle宣布收购 SUN公司 Java7.0 2011.07.02 Java8.0 2014.03.18 LTS版本 Java9.0 2017.09.22 1.每半年更新一次 2.Java9.0开始不再支持 window32位系统 Java10.0 2018.03.21 Java11.0 2018.09.25 1.JDK安装包取消独立 JRE安装包；2.LTS版本 Java12.0 2019.03.19 Java13.0 2019.09.17 Java14.0 2020.03.17 Java15.0 2020.09.16 Java16.0 2021.03.16 Java17.0 2021.09.14 LTS版本 LTS（Long Term Support）:长期支持版本，下一个 LTS版本为 Java17.0","tags":["blog"],"categories":["Java","Java基础"]},{"title":"一、计算机语言介绍","path":"//posts/计算机语言介绍.html","content":"1、计算机语言是什么？所谓计算机编程语言，就是人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 比如打游戏等就是输入指令让计算机执行。 2、计算机语言发展 第一代：机器语言 例如：0101 不直观 第二代：汇编语言 例如：加入了单词 第三代：高级语言 面向过程语言 面向对象语言 3、计算机语言排行榜下面是 2024 年 2 月最受欢迎的 10 种编程语言。 4、计算机语言走势","tags":["blog"],"categories":["Java","Java基础"]},{"path":"/css/extra.css","content":"/** 设置侧边栏底部 **/ .social-wrap { display: block; } .social-wrap .social:hover { background-color: #d7beb6 } /** 设置右边栏 **/ /** 右边栏目录高度设置 **/ .l_right .widgets .widget-wrapper.toc .widget-body .toc{ /* max-height: calc(100vh - 500px); */ } .widget-wrapper.toc+.widget-wrapper{ padding-top: 0px; }"}]