[{"title":"🔥Vue2源码构建","path":"//posts/vue2-core-build.html","content":"&emsp;&emsp;在上一篇文章中，我们大概了解了Vue的目录结构是怎么样的。 &emsp;&emsp;在这一小节中，我们会了解一下 Vue 是如何构建的。 一、Vue的基础使用官方推荐 Vue 的使用方式主要有两种：通过 CDN 和 NPM。 使用 CDN，我们可以通过在 HTML 中添加 &lt;script&gt; 标签直接引入打包好的 vue.js 文件，这是一种快速且简便的方法。 12// CDN方式&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; 而 NPM 方式则涉及到与模块打包工具如 webpack 或 Browserify 的集成，通过执行 npm install vue 命令来安装 Vue，这通常是我们在开发大型应用时的首选方式。 12// NPM方式import Vue from &#x27;vue&#x27;; 当Vue被引入时，通常我们会在入口文件中去 new 一个Vue实例。 然后再利用实例上的$mount方法将对应的模版内容挂载到浏览器中#app节点的位置上。 12345678// NPM方式// Nodejs版本import Vue from &#x27;vue/dist/vue.common&#x27;;// 需要实例化 Vuenew Vue(&#123; template:`&lt;div&gt;Hello World&lt;/div&gt;`&#125;).$mount(&quot;#app&quot;); 二、Vue的构建2.1 根据使用场景打包在上一节课中，我们熟悉了 Vue源码中的代码结构。 其中我们介绍了几个入口文件： entry-runtime.ts entry-runtime-with-compiler.ts entry-runtime-esm.ts entry-runtime-with-compiler-esm.ts 在我们开发项目结束后，需要进行打包并部署到线上。 通常我们项目打包时需要一个入口文件， webpack通过这个入口文件递归文件进行依赖分析然后打包。 其实框架打包也一样，同样需要一个入口文件进行递归依赖分析打包生成 js文件方便我们进行使用。 和项目不一样的是，项目往往只有一个入口文件，而框架会根据不同的情况采用不同的入口文件进行打包，上面的这四个文件就是Vue框架的入口文件。 Vue是使用rollup进行打包的。 为了方便用户进行使用，Vue在使用rollup进行打包时根据开发环境和开发模式打包出了不同功能的文件，以适用于不同的使用场景。 构建的rollup打包脚本在scripts/config.js中。 1234567891011121314151617const builds = &#123; &#x27;runtime-cjs-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.dev.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;development&#x27;, banner &#125;, &#x27;runtime-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, banner &#125;, // 省略&#125; 总共打包生成 12 个文件，这些文件可以适用于不同的场景。 根据是否带编译器的角度上分为Full和Runtime-Only 2个版本。Full版本包含编译器和运行时的全部功能。Runtime-Only 仅含运行时功能。 打包的文件根据使用场景分为 esm、cjs、umd三个版本。其中umd可以通过&lt;script&gt;标签引入直接在浏览器中使用，Vue会暴露一个全局变量 Windows.Vue。而 CommonJS适配const Vue &#x3D; require(‘vue’)这种 node式的模块系统。ES则适配import Vue from ‘vue’这种es6格式。 打包的文件根据环境分为 dev&#x2F;prod，在开发环境中可以使用 dev版本的 js文件，而部署到客户生产环境就可以使用 prod版本的 js文件。 dev版本的文件有一些提示，会在开发者开发时便于调试。 2.2 Full版本的Vue到底是什么意思？ 平时我们开发中只使用了 runtime-only 版本。 而 Full版本中不仅有 runtime-only部分，还包括编译器部分。 所谓编译器，就是在Vue内部的编译器可以将模板转化为对应的render函数。 在Vue内部渲染就是调用的 render方法生成 vnode。 因为编译器代码体积比较大，而且如果在运行的时候进行模板编译，极大可能会消耗性能。 所以我们一般在开发项目时，使用 runtime-only版本。 在 webpack预编译阶段，就将.vue文件编译成render函数，在运行时直接运行 render函数就可以获取到对应的 vnode。 通过 runtime-only 和 esm很容易推测出来我们项目在开发阶段中使用的是vue.runtime.esm.js 2.3 使用 Full 还是用 Runtime-Only版本这需要依据具体情况进行具体分析。 倘若你需要用到 Vue 所提供的 html 模板功能，那就选用 Full 版本。 反之，最好采用 Runtime-only 版本，原因在于它比 Full 版本的文件体积大约小 30%。 *.vue 单文件组件会被 vue-loader 直接构建成为 JavaScript，并未使用到 Vue 的编译器，所以可以使用 Runtime-only 版本。 三、神奇的“__DEV__”在前面我们说到，在打包成开发环境的包时，往往会存在很多提示信息。 而源码中判断开发环境通常都是使用__DEV__来进行判断。 3.1 __DEV__的本质在Vue源码中，到处都能看到__DEV__变量的身影。 但是你看不到__DEV__被 import 引入，甚至你都找不到在哪里定义了这个变量。 这个变量在 Vue 中代表开发环境。 当你在源码中看见 if(__DEV__) 代表这个if中的逻辑只有在开发环境才进入执行。 vue的构建工具是rollup，在rollup打包的时候会使用@rollup/plugin-replace 插件来替换源代码中的__DEV__变量，如下： 123456789101112......const replace = require(&#x27;@rollup/plugin-replace&#x27;)......// built-in varsconst vars = &#123; ...... __DEV__: `process.env.NODE_ENV !== &#x27;production&#x27;`, ......&#125;......config.plugins.push(replace(vars))...... 所以__DEV__的本质就是 proess.env.NODE_ENV!== &#39;production&#39; 。 3.2 约定俗成的“process.env.NODE_ENV!&#x3D;&#x3D;’production”将 DEV 变量转换为 process.env.NODE_ENV !== &#39;production&#39; 这样的条件表达式在现代前端构建工具中是一种常见的约定和实践。 原因有以下几点： 环境区分：通过 process.env.NODE_ENV 可以方便地在代码中区分开发环境（development）与生产环境（production）。例如，在开发环境中启用特定的警告、日志记录或者热加载功能；而在生产环境中则禁用这些功能以优化性能。 Tree-shaking 和 UglifyJS：当打包工具如 Rollup 或 webpack 遇到 process.env.NODE_DEV !== &#39;production&#39; 包裹的代码块时，在生产环境下会自动去除（tree-shake）其中仅在开发环境中需要的代码，因为该条件表达式最终会被编译器或压缩工具识别为始终为 false，因此包裹的代码不会被打包进最终产物。 标准化：许多框架和库都采用了这种模式来处理环境相关的逻辑，这样开发者可以统一遵循这个约定，减少配置和理解成本。 灵活配置：由于构建工具支持 .env 文件或其他方式来设置 NODE_ENV 的值，这使得项目配置更加灵活，团队成员可以根据实际需求快速切换不同环境下的行为。 跨平台兼容性：process.env.NODE_ENV 作为一个标准 Node.js 环境变量接口，已经被广泛接受，并且在各种打包工具中都有相应的机制将其映射到最终浏览器执行的代码中，确保了跨平台的一致性。 一般项目在开发环境中将process.env.NODE_ENV设置为development，在生产环境中设置为production。 所以通过process.env.NODE_ENV !== &#39;production就可以判断现在是处于什么环境下。 3.3 在本地环境配置__DEV__因为我们这门课程是写一个完整版的vue2。 所以我们也会使用__DEV__这个变量代表开发环境。 我们本地的项目是使用 vue-cli 搭建的。 可以在 webpack配置文件 vue.config.js 文件新增一个配置达到这个目的。 1234567891011121314// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, configureWebpack: &#123; plugins: [ new webpack.DefinePlugin(&#123; __DEV__: process.env.NODE_ENV === &#x27;development&#x27;, &#125;), ], &#125;,&#125;) DefinePlugin 插件的主要作用是在编译时将预定义的值替换到源代码中的特定变量。 我们执行yarn start启动这个项目打印一下__DEV__为 true即为成功。 1console.log(__DEV__); // true"},{"title":"🔥Vue2目录结构窥探","path":"//posts/vue2-catalog.html","content":"&emsp;&emsp;本专栏旨在通过用丰富的图文详解来帮助你全面深入的了解 Vue2 源码。这是本专栏的第一篇文章。 &emsp;&emsp;因为 Vue 框架是在十多年前产生的一个开源前端框架，经过一些迭代修复，目前已经趋于稳定。 &emsp;&emsp;Vue2框架在可维护性、性能、TypeScript支持等方面有一些痛点，所以尤雨溪推出了 Vue3版本。 &emsp;&emsp;不过目前大部分公司因为成本等方面的原因，还是使用在 Vue2 版本，所以我们这个专栏就来探讨一下 Vue2 的源码部分。 一、非核心Vue源码目录大致结构 我们看的 vue源码 版本是 2.7.16 是 vue2 的最新版本 我们打开vue2的github源码地址。 可以看到其中有很多个目录文件，但是其实 Vue2 源码核心的都是在 src文件夹中的。 我们这章大概介绍一下除了 src 下面的一些目录，了解一下大体的作用是什么。 1.1 .github该文件夹用于存放与 gitHub 相关的配置文件或者脚本。 1.2 benchmarks该文件夹用于存放性能基准测试的相关文件和脚本。 性能基准测试是一种用来评估软件性能的方法，它通过模拟真实世界中的使用场景来测量软件在不同条件下的表现。 可以确保新功能不会降低框架的整体性能，同时也可以用来优化现有代码，使其更加高效。 1.3. compiler-sfc该文件夹下的内容逻辑就可以协助 webpack进行解析处理单文件组件（SFC）。 通常我们开发时会借助 webpack将 vue文件转化为一个 JS对象。 可以查看他的 index.js文件 发现实际上就是导出了@vue/compiler-sfc这个包。 1module.exports = require(&#x27;@vue/compiler-sfc&#x27;) 1.4. dist该文件夹为打包文件存放的地方。 1.5. examples该文件夹用于存放示例应用程序或代码片段，目的是展示 Vue.js 的基本用法和功能。 1.6 packages该文件夹主要用于组织 Vue.js 的各个子包或模块。 随着 Vue.js 项目的复杂度增加，将不同的功能模块拆分成独立的子包已经成为了一种常见的做法。 这样不仅有利于模块化开发，还能方便依赖管理和发布。 该目录下有三个目录。 1.6.1 compiler-sfc该文件夹下的内容主要用于处理单文件组件。 1.6.2 server-renderer该文件夹下的内容和服务端渲染相关的内容。 1.6.3 template-compiler该文件夹下的内容存放模板编译相关的逻辑。 1.7 scripts该文件夹主要用于存放各种自动化脚本。 这些脚本通常用于辅助项目的构建、测试、发布和其他开发任务。 1.8 src该文件夹是存放 vue框架核心源码的地方。 后面我们会详细说一下。 1.9 test该文件夹主要用于存放各种类型的测试文件，这些测试文件用于验证 Vue.js 框架的功能是否按预期工作。 1.10 types该文件夹主要用于存放 TypeScript 类型定义文件。 这些类型定义文件为 Vue.js 提供了类型支持，使得在使用 Vue.js 时可以享受静态类型检查的好处，从而提高代码质量和开发效率。 1.11 .editorconfig该文件用于指定编辑器应该遵循的一系列编码和格式化规则。 1.12 .git-blame-ignore-revs该文件用于告诉 Git 在执行 git blame 命令时忽略某些特定的提交记录。 1.13 .gitignore该文件用于指定 Git 应该忽略哪些文件或目录，即不将这些文件或目录纳入版本控制。 1.14 .prettierrc该文件用于配置 Prettier。 Prettier是一个流行的代码格式化工具，旨在帮助开发者保持代码风格的一致性。 Prettier 可以自动格式化代码，使其符合预设的编码规范，从而提高代码的可读性和一致性。 1.15 BACKERS.md该文件主要用于记录和支持 Vue.js 项目的赞助者或贡献者。 这份文件通常列出了那些通过资金或其他形式支持 Vue.js 发展的个人或组织。 1.16 CHANGELOG.md该文件主要用于记录项目的版本变更历史，包括每个版本的新增功能、改进、修复的错误以及其他重要的变更信息。 1.17 LICENSE该文件用来定义和声明项目使用的许可协议的文件 1.18 README.md该文件为项目的入口文档文件。 文件提供了关于项目的概述、安装步骤、使用方法、贡献指南等关键信息。 1.19 api-extractor.json该文件用于配置 API Extractor 工具（这是一种用于生成 TypeScript 类型定义文档和 API 报告的工具） API Extractor 通常用于大型 TypeScript 项目中，帮助开发者生成详细的 API 文档，并确保类型定义的一致性和准确性。 1.20 api-extractor.tsconfig.json该文件用于配置 TypeScript 编译选项，以配合 API Extractor 工具生成 API 文档和类型定义文件。 这个文件通常包含了一些特定的 TypeScript 配置，确保 API Extractor 能够正确地解析和处理源代码。 1.21 package.json该文件是项目的核心配置文件，用于描述项目的元数据以及项目依赖关系和构建脚本。 1.22 pnpm-lock.yaml该文件是由 pnpm 包管理器生成的锁定文件。 用于记录项目中所有依赖项的具体版本信息，以及它们是如何被安装的。 pnpm 是一种替代 npm 和 yarn 的高性能包管理器，它具有更快的速度和更少的磁盘空间占用。 1.23 pnpm-workspace.yaml该文件用于配置 pnpm 工作区（workspace）。 pnpm 支持多项目的工作区模式，这种模式允许多个相关项目共享依赖，并且可以方便地管理这些项目的依赖关系和构建流程。 1.24 tsconfig.json该文件是 TypeScript 编译配置文件，用于定义 TypeScript 编译器在编译源代码时应遵循的选项和规则。 1.25 vitest.config.ts该文件用于配置 Vitest 的测试框架配置文件。 Vitest 是一个现代化的 JavaScript 和 TypeScript 测试框架，它提供了快速的测试运行速度和丰富的功能集，适用于前端和后端开发。 二、src目录下有什么？上一章节我们简单介绍了一下非 src文件夹下面的一些文件内容。 这些都是在一个工程化的框架项目中必不可少的部分。 那么本节的内容就是看下 src 文件夹下包含哪些内容。 下面这个目录结构去除了 ts相关的声明文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147src├─shared| ├─constants.ts| └util.ts├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 三、shared文件夹 1234src├─shared| ├─constants.ts| └util.ts 这个文件夹包含了一些在不同环境下都需要共享的工具函数或者常量。 这个工具函数与平台无关。 既可以在客户端使用，也可以在服务端使用，因为它们不依赖于任何特定的环境特性（例如 DOM）。 constants.ts文件中定义了一些在整个框架内频繁使用的常量，比如特殊的字符串标识符、配置键名等。 util.ts文件中定义了一些基础的工具函数，比如 isString、isObject和其他一些常用的功能，如深拷贝、警告输出等。 这些文件的主要目的是为了提高代码的可维护性和复用性。 通过将这些功能抽象出来，Vue.js 能够保持核心逻辑的简洁，并且确保不同部分之间的兼容性。 这样做的好处是减少了重复代码，使得代码更容易理解和维护。 四、platforms文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152src├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts 4.1 为什么会有这么一个platforms目录呢？platforms 翻译成中文表示“平台“。 vue作为一个跨平台的框架，不仅支持传统的web浏览器环境，还支持其他平台，如服务器渲染（SSR），甚至是非浏览器环境。 因此，将 Web 平台相关的代码单独放在一个目录中，有助于保持代码的清晰度和可维护性。 Web平台有许多特定的功，比如 DOM操作、CSS动画、事件处理等。这些功能在 Vue的 Web版本中是必需的，但是在其他平台上则不一定适用。将这些代码组织在一起，可以确保它们只在 Web平台上生效，而不会影响到其他平台的构建。 当然目前仅仅只有一个web平台，所以平台下只有一个 web目录。 4.2 几个入口文件entry-*文件主要用于定义不同构建配置下的入口点。 web目录下有entry-compiler.ts、entry-runtime-esm.ts、entry-runtime-with-compiler-esm.ts、entry-runtime-with-compiler、entry-runtime.ts五个入口文件。 在vue源码scripts/config.js中有打包相关的配置，其中就利用了这几个入口文件。 4.2.1 entry-compiler.ts该文件是一个提供编译 html 模板相关接口的模块，通常用于为 Vue 编写的构建插件，比如 vue-loader。 1234567891011// scripts/config.jslet builds = &#123; compiler: &#123; entry: resolve(&#x27;web/entry-compiler.ts&#x27;), dest: resolve(&#x27;packages/template-compiler/build.js&#x27;), format: &#x27;cjs&#x27;, external: Object.keys( require(&#x27;../packages/template-compiler/package.json&#x27;).dependencies ) &#125;,&#125; 4.2.2 entry-runtime.ts &amp; entry-runtime-esm.ts这两个文件都用于构建仅包含运行时的文件，不具备编译 html 模板功能。区别是一个是 esm格式，一个不是。 12345678910111213141516// scripts/config.jslet builds = &#123; &#x27;runtime-esm&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.esm.js&#x27;), format: &#x27;es&#x27;, banner &#125;, &#x27;runtime-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.min.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;production&#x27;, banner &#125;,&#125; 4.2.3 entry-runtime-with-compiler.ts &amp; entry-runtime-with-compiler-esm.ts这两个文件都用于构建同时包含编译器和运行时的全功能文件。 区别是一个是 esm格式，一个不是。 下面的full-cjs-prod可以看出来这个全版本，有 vue的全部功能。 1234567891011121314151617181920// scripts/config.jslet builds = &#123; &#x27;full-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.ts&#x27;), dest: resolve(&#x27;dist/vue.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, &#x27;full-esm-browser-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.esm.browser.min.js&#x27;), format: &#x27;es&#x27;, transpile: false, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;,&#125; 4.3 runtime-with-compiler.ts之前我们了解到 Vue分为 runtime 和 compiler两个部分。 而 runtime-with-compiler.ts文件就是既有 runtime部分 也有 compiler部分。 上面的entry-runtime-with-compiler.ts和entry-runtime-with-compiler-esm.ts就是基于这个文件进行打包的。只是分别扩展了vue的一些功能。 4.4 util目录该目录包含了 Vue在 Web平台上常用的工具函数和使用工具。 这些工具主要用于处理与 Web平台相关的各种细节。 4.5 runtime目录4.5.1 components目录该目录下存放着 vue web平台中使用的组件如 transition、transition-group组件等，借助这些组件可以实现过渡动画。 4.5.2 directives目录该目录下的主要存放是 vue的内部指令文件，如v-model、v-show指令。 4.5.3 modules目录该目录下的主要存放的是vue在 web平台上常见的 DOM操作和特性处理。 4.5.3.1 attrs.ts这个文件实现了处理元素属性的模块，它负责更新和管理元素的属性。例如，当数据模型中的属性值发生变化时，需要更新 DOM 中相应的属性值。 4.5.3.2 class.ts这个文件实现了处理元素类的模块，它负责更新和管理元素的类名。例如，根据数据模型中的条件动态添加或移除类名。 4.5.3.3 dom-props.ts这个文件实现了处理 DOM 属性的模块，它负责同步和更新 DOM 属性，如 value, checked 等。这在处理表单控件时尤为重要。 4.5.3.4 events.ts这个文件实现了处理事件绑定的模块，它负责在 DOM 元素上添加、更新和移除事件监听器。这使得 Vue.js 可以响应用户的交互行为，并触发相应的事件处理函数。 4.5.3.5 style.ts这个文件实现了处理内联样式的模块，它负责更新和管理元素的内联样式。例如，根据数据模型中的条件动态设置或移除内联样式。 4.5.3.6 transition.ts这个文件实现了处理过渡动画的模块，它负责应用过渡类，管理过渡状态，并确保过渡效果正确地应用于元素。 4.5.4 transition-util.ts该文件包含了 Vue.js 在 Web 平台上与过渡动画相关的实用工具函数。 这些工具函数为 &lt;transition&gt; 和 &lt;transition-group&gt; 组件提供了底层的支持，使得 Vue.js 能够管理和控制元素的过渡效果。 4.5.5 patch.ts该文件是 Vue.js 在 Web 平台上负责 DOM 更新的核心模块。 这个文件定义了 patch 函数，它是 Vue.js 渲染引擎的关键部分之一，用于将虚拟 DOM（Virtual DOM）更新到实际的 DOM 上。 他实际上引用了core/vdom/patch目录下的 createPatchFunction函数。 4.5.6 node-ops.ts该文件包含了 Vue.js 在 Web 平台上进行 DOM 操作的具体实现。 这个文件定义了一组方法，这些方法是 Vue.js 渲染引擎在更新 DOM 时使用的具体操作。如添加节点、删除节点等。 4.5.7 class-util.ts该文件包含了 vue 在 web平台上与元素类相关的使用工具函数。 这些工具函数用于处理元素的类名，包括添加、删除和切换类名等操作。 4.6 compiler目录该目录包含了 Vue.js 在 Web 平台上进行模板编译的相关实现。 这个目录中的文件和模块负责将 Vue 模板字符串转换为可以被 Vue 渲染引擎执行的渲染函数。 其中 directives目录下的文件 定义了一些内置指令如v-html、v-text。 modules目录中存放了对应处理模板编译时需要的一些通用处理方法。 其余文件为通用工具等。 五、core文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071src├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts core文件夹是存储这 vue的核心逻辑。 5.1 components目录该目录下存放了一些内置组件如 keep-alive。 5.2 global-api目录该目录包含了 Vue.js在核心层面提供的全局 API的实现。 如Vue.mixin、Vue.use、Vue.extend等。 5.3 instance目录该目录包含了 vue实例相关的主要实现。 其中:render.js负责渲染相关的逻辑、lifecycle.js负责管理 vue实例的生命周期钩子、events.js负责处理 vue实例上的事件、state.js负责管理 vue实例的数据状态等。 5.4 observe目录该目录包含了 Vue.js 中用于实现响应式系统的核心模块。 这部分代码负责将数据对象转换为可观察的对象，使得数据的变化能够被追踪，并自动更新依赖于该数据的视图。 5.5 vdom目录该目录包含了Vue.js 处理虚拟 DOM (Virtual DOM) 的相关实现。 虚拟 DOM 是 Vue.js 渲染机制的核心部分，它通过内存中的 JavaScript 对象来表示真实的 DOM 节点。 六、compiler文件夹该目录存放了vue模板编译的相关内容。 1234567891011121314151617181920212223src├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 七、总结我们这章大概的介绍了 vue的大体目录结构。"},{"title":"博客真的需要魔改吗","path":"//posts/13.html","content":"博客真的需要魔改吗？很多人一开始都是贪新鲜感，为了让自己的博客更丰富、更吸引人，就会不断地去寻找各种插件、主题，甚至自己动手去修改博客的代码。但是，这样真的有必要吗？ 真正的简约远不止删繁就简，而是在纷繁中建立秩序博客的本质是记录，是分享，是交流，是沉淀。如果你的博客只是为了追求炫酷，那么你的博客就失去了本质。博客的本质是内容，而不是形式。人的注意力是有限的，要用有限的注意力去关注无限的内容，就需要有一个简洁的界面，让用户能够专注于内容本身，而不是被花里胡哨的界面所吸引。比如说一些卡通图像、五颜六色的组件、眼花缭乱的动画等等，这些东西都会让用户的注意力分散，让用户无法专注于内容本身。 降低视觉密度如果你的博客的界面太过于复杂，用户会觉得很累，不愿意继续阅读下去。所以，一个简洁的界面是非常重要的。比如说，你可以使用一些简洁的字体、简洁的颜色、简洁的布局等等，让用户能够更加专注于内容本身。 提高有效信息优先级标题永远是最重要的。用户在阅读博客的时候，首先会看标题，然后再决定是否继续阅读。所以，标题是非常重要的。不可交互的不重要的小标题（如侧边栏某个插件的标题），应该降低对比度。让用户专注更高优先级的标题、内容，而不是留意侧边栏不重要的信息。 删掉无效信息非常多的博客喜欢往自己的博客添加通讯电波、音乐播放器、彩蛋甚至是广告，这些东西都会让用户的注意力分散。所以应该把这些无效内容删除，让用户能够更加专注于内容本身，不被无关的东西所干扰。","tags":["blog"],"categories":["Java","Java基础"]},{"title":"一、计算机语言介绍","path":"//posts/13.html","content":"一、计算机语言介绍1.1 计算机语言是什么？所谓计算机编程语言，就是人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 比如打游戏等就是输入指令让计算机执行。 1.2 计算机语言发展 第一代：机器语言 例如：0101 不直观 第二代：汇编语言 例如：加入了单词 第三代：高级语言 面向过程语言 面向对象语言 1.3 计算机语言排行榜下面是 2024 年 2 月最受欢迎的 10 种编程语言。 1.4 计算机语言走势","tags":["blog"],"categories":["Java","Java基础"]},{"path":"/css/extra.css","content":"/** 设置侧边栏底部 **/ .social-wrap { display: block; } .social-wrap .social:hover { background-color: #d7beb6 } /** 设置右边栏 **/ /** 右边栏目录高度设置 **/ .l_right .widgets .widget-wrapper.toc .widget-body .toc{ max-height: calc(100vh - 500px); } .widget-wrapper.toc+.widget-wrapper{ padding-top: 0px; }"}]