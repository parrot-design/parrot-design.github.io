---
title: ğŸ”¥Vue2å¼‚æ­¥æ¸²æŸ“æœºåˆ¶
permalink: posts/vue2-async.html
date: 2024-11-25 14:27
topic: vue2
banner: /assets/topic/vue2/async/2.jpg
---  
 
&nbsp;

{% button è¿”å› javascript:window.history.back() icon:solar:back-white color:orange size:xs %}

{% quot ä¸“æ ç¬¬ä¹ç¯‡-å¼‚æ­¥æ¸²æŸ“æœºåˆ¶ %}

# ä¸€ã€å¼‚æ­¥æ¸²æŸ“æœºåˆ¶

åœ¨ä¸Šä¸€èŠ‚çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨æ•°æ®å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œä¼šé‡æ–°æ›´æ–°ä¾èµ–ï¼Œæœ€ç»ˆä¼šæ‰§è¡ŒWatcherå®ä¾‹çš„updateæ–¹æ³•ã€‚

ä½†æ˜¯å…¶å®Vueä¸­å¹¶ä¸æ˜¯åœ¨æ¯æ¬¡æ‰§è¡Œupdateæ–¹æ³•æ—¶éƒ½ä¼šæ‰§è¡Œæ¸²æŸ“ï¼Œä»–ä¼šå°†å¤šæ¬¡å˜åŒ–åšä¸€æ¬¡åˆå¹¶æ¸²æŸ“ã€‚

{% box child:codeblock color:purple %}
```js
import Vue from "vue";

new Vue({
    template:`<div>{{ msg }}</div>`,
    data(){
        return {
            msg:"inited"
        }
    },
    mounted(){
        this.msg = 'ç¬¬ä¸€æ¬¡æ¸²æŸ“';
        this.msg = 'ç¬¬äºŒæ¬¡æ¸²æŸ“';
    }
}).$mount("#app")
```
{% endbox %}

æŒ‰ç…§æˆ‘ä»¬ä¸ŠèŠ‚æ‰€å­¦çš„çŸ¥è¯†ï¼šæ¯ä¸€ä¸ªdataéƒ½è¢«ä»£ç†åŠ«æŒï¼Œæ¯æ¬¡dataä¿®æ”¹åéƒ½ä¼šé‡æ–°æ‰§è¡Œæ›´æ–°æ–¹æ³•ã€‚

é‚£ä¹ˆåœ¨ mountedæ–¹æ³•ä¸­ dataä¿®æ”¹äº† 2 æ¬¡ï¼Œæ˜¯ä¸æ˜¯åº”è¯¥æ¸²æŸ“ 2 æ¬¡å‘¢ï¼Ÿ

ä½†æ˜¯ä»å®é™…è§’åº¦æ˜æ˜¾æˆ‘ä»¬è¿™é‡Œåªéœ€è¦æ¸²æŸ“ç¬¬äºŒæ¬¡çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯åªæ¸²æŸ“ä¸€æ¬¡ï¼Œè€Œ Vueå†…éƒ¨ä¹Ÿæ˜¯è¿™ä¹ˆæ“ä½œçš„ã€‚

> ç”±äºVueå†…éƒ¨çš„å¼‚æ­¥æ¸²æŸ“æœºåˆ¶ï¼Œå®é™…ä¸Šé¡µé¢åªä¼šæ¸²æŸ“ä¸€æ¬¡ï¼ŒæŠŠç¬¬ä¸€æ¬¡çš„èµ‹å€¼æ‰€å¸¦æ¥çš„çš„å“åº”ä¸ç¬¬äºŒæ¬¡çš„èµ‹å€¼æ‰€å¸¦æ¥çš„çš„å“åº”è¿›è¡Œä¸€æ¬¡åˆå¹¶ï¼Œå°†æœ€ç»ˆçš„valåªåšä¸€æ¬¡é¡µé¢æ¸²æŸ“ï¼Œè€Œä¸”é¡µé¢æ˜¯åœ¨æ‰§è¡Œæ‰€æœ‰çš„åŒæ­¥ä»£ç ä¹‹åæ‰èƒ½å¾—åˆ°æ¸²æŸ“ã€‚

# äºŒã€ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥æ¸²æŸ“

{% box child:codeblock color:purple %}
```js
let data = {msg:'inited'}
let _msg = data.msg
Object.defineProperty(data,"msg",{
    set(val){
        console.log("æˆ‘è¢«è®¾ç½®äº†")
        _msg = val
    },
    get(){
        console.log("æˆ‘è¢«è®¿é—®äº†")
        return _msg
    }
}) 
data.msg = 'ç¬¬ä¸€æ¬¡æ¸²æŸ“'
console.log("è·å–æ­¤æ—¶data.msg",data.msg)
data.msg = 'ç¬¬äºŒæ¬¡æ¸²æŸ“' 
// æ‰§è¡Œç»“æœ
// æˆ‘è¢«è®¾ç½®äº†
// æˆ‘è¢«è®¿é—®äº†
// è·å–æ­¤æ—¶data.msg ç¬¬ä¸€æ¬¡æ¸²æŸ“
// æˆ‘è¢«è®¾ç½®äº†
```
{% endbox %}

é€šè¿‡æ‰§è¡Œä¸Šé¢è¿™æ®µä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ä»£ç†æ˜¯åŒæ­¥æ“ä½œã€‚

ä¹Ÿå°±æ˜¯è¯´å¦‚æœåœ¨ Vueä¸­ä¸è¿›è¡Œå¼‚æ­¥å¤„ç†çš„è¯ï¼Œå¯èƒ½æœ€ç»ˆæ‰§è¡Œé€»è¾‘å°±æ˜¯ä¸‹å›¾è¿™æ ·ã€‚

{% image /assets/topic/vue2/async/1.jpg %}

è¿™æ ·çš„è¯æ¯æ¬¡ dataå˜åŒ–å°±ä¼šé‡æ–°æ¸²æŸ“ä¸€æ¬¡ï¼Œå¯èƒ½ä¼šå¯¼è‡´æµè§ˆå™¨çš„é—ªçƒå¡é¡¿ã€‚

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»ç”¨æˆ·ä½“éªŒå’Œæ€§èƒ½ 2 ä¸ªè§’åº¦è¿›è¡Œåˆ†æï¼š

* ç”¨æˆ·ä½“éªŒï¼šä»ä¸Šè¿°ä¾‹å­å¯ä»¥çœ‹å‡ºï¼Œå®é™…ä¸Šé¡µé¢åªéœ€è¦å±•ç¤ºæœ€ç»ˆçš„å€¼å˜åŒ–ã€‚ç¬¬ä¸€æ¬¡çš„å€¼å˜åŒ–åªæ˜¯ä¸€ä¸ªè¿‡æ¸¡çŠ¶æ€ï¼Œå¦‚æœå°†å…¶æ¸²æŸ“å¹¶æ˜¾ç¤ºç»™ç”¨æˆ·ï¼Œå¯èƒ½ä¼šå¯¼è‡´é¡µé¢å‡ºç°é—ªçƒç°è±¡ï¼Œä»è€Œå½±å“ç”¨æˆ·ä½“éªŒã€‚é€šè¿‡ Vue çš„å¼‚æ­¥æ›´æ–°é˜Ÿåˆ—æœºåˆ¶ï¼Œå¯ä»¥æœ‰æ•ˆé¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œç¡®ä¿ç”¨æˆ·çœ‹åˆ°çš„æ˜¯ç¨³å®šä¸”æœ€æ–°çš„é¡µé¢çŠ¶æ€ã€‚
* æ€§èƒ½ï¼šåœ¨ä¸Šè¿°ä¾‹å­ä¸­ï¼Œæœ€ç»ˆéœ€è¦å±•ç¤ºçš„æ•°æ®å®é™…ä¸Šæ˜¯ç¬¬äºŒæ¬¡å¯¹ val èµ‹çš„å€¼ã€‚å¦‚æœç¬¬ä¸€æ¬¡èµ‹å€¼ä¹Ÿè§¦å‘é¡µé¢æ¸²æŸ“ï¼Œé‚£ä¹ˆåœ¨æœ€ç»ˆç»“æœæ¸²æŸ“ä¹‹å‰ï¼Œé¡µé¢ä¼šè¿›è¡Œä¸€æ¬¡ä¸å¿…è¦çš„æ¸²æŸ“ã€‚è¿™æ— ç–‘å¢åŠ äº†æ€§èƒ½çš„æ¶ˆè€—ã€‚

# ä¸‰ã€Vueå¼‚æ­¥æ¸²æŸ“åŸç† 

æ•°æ®æ¯æ¬¡å˜åŒ–æ—¶ï¼Œå°†å…¶å¼•èµ·é¡µé¢å˜åŒ–çš„æ“ä½œéƒ½ä¼šæ”¾åˆ°ä¸€ä¸ªå¼‚æ­¥APIçš„å›è°ƒå‡½æ•°ä¸­ã€‚å½“åŒæ­¥ä»£ç æ‰§è¡Œå®Œæ¯•åï¼Œå¼‚æ­¥å›è°ƒå¼€å§‹æ‰§è¡Œã€‚æ­¤æ—¶ Vue ä¼šå°†æ‰€æœ‰éœ€è¦æ¸²æŸ“çš„å˜åŒ–åˆå¹¶åœ¨ä¸€èµ·ï¼Œæœ€ç»ˆæ‰§è¡Œä¸€æ¬¡æ¸²æŸ“æ“ä½œã€‚

{% image /assets/topic/vue2/async/2.jpg %}

# å››ã€queueWatcher

æ¯ä¸€æ¬¡dataå˜åŒ–éƒ½ä¼šæ‰§è¡ŒWatcherå®ä¾‹ä¸Šçš„ updateæ–¹æ³•ã€‚

{% box child:codeblock color:purple %}
```js 
update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
}
```
{% endbox %}

é»˜è®¤ lazyã€syncéƒ½æ˜¯ falseã€‚

æ‰€ä»¥é»˜è®¤æ¯ä¸€æ¬¡éƒ½ä¼šè°ƒç”¨queueWatcheræ–¹æ³•ï¼Œé‚£ä¹ˆè¿™ä¸ª queueWatcherå‡½æ•°éƒ½åšäº†ä»€ä¹ˆæ“ä½œå‘¢ï¼Ÿ

## 4.1 haså¯¹è±¡ 

{% box child:codeblock color:purple %}
```js 
let has = {};
export function queueWatcher(watcher: Watcher) {
  const id = watcher.id
  if (has[id] != null) {
    return
  } 
  has[id] = true
  // çœç•¥éƒ¨åˆ†ä»£ç 
}
```
{% endbox %}

has å¯¹è±¡ç”¨äºå­˜å‚¨å·²ç»åŠ å…¥é˜Ÿåˆ—çš„ watcher çš„ IDï¼Œä»¥ç¡®ä¿æ¯ä¸ª watcher åªè¢«åŠ å…¥é˜Ÿåˆ—ä¸€æ¬¡ã€‚è¿™æ˜¯ä¸€ç§é¿å…é‡å¤å¤„ç†ç›¸åŒ watcher çš„æœºåˆ¶ã€‚

## 4.2 noRecurseé€‰é¡¹

{% box child:codeblock color:purple %}
```js 
if (watcher === Dep.target && watcher.noRecurse) {
    return
}
```
{% endbox %}

å¦‚æœå½“å‰çš„ watcher å°±æ˜¯å…¨å±€çš„ Dep.targetï¼ˆå³å½“å‰æ­£åœ¨æ‰§è¡Œçš„ watcherï¼‰ï¼Œå¹¶ä¸”è¿™ä¸ª watcher è®¾ç½®äº† noRecurse æ ‡å¿—ï¼ˆè¡¨ç¤ºä¸å¸Œæœ›é€’å½’è§¦å‘ï¼‰ï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚

## 4.3 queue

{% box child:codeblock color:purple %}
```js 
const queue: Array<Watcher> = []
export function queueWatcher(watcher: Watcher) {
    // çœç•¥éƒ¨åˆ†ä»£ç 
    if (!flushing) {
        queue.push(watcher)
    } else {
        queue.splice(i + 1, 0, watcher)
    }
}
```
{% endbox %}

queueæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”¨äºå­˜å‚¨éœ€è¦æ‰§è¡Œæ›´æ–°æ¸²æŸ“çš„ watcherå®ä¾‹ã€‚

å½“æ•°æ®å˜åŒ–æ—¶ï¼Œç›¸å…³çš„ watcherå®ä¾‹ä¼šè¢«æ·»åŠ åˆ°è¿™ä¸ªæ•°ç»„ä¸­ï¼Œç­‰å¾…æ‰§è¡Œã€‚

## 4.4 flushingçŠ¶æ€

{% box child:codeblock color:purple %}
```js  
let flushing = false;
let index = 0;
export function queueWatcher(watcher: Watcher) {
    // çœç•¥éƒ¨åˆ†ä»£ç 
    if (!flushing) {
        queue.push(watcher)
    } else {
        let i = queue.length - 1
        while (i > index && queue[i].id > watcher.id) {
            i--
        }
        queue.splice(i + 1, 0, watcher)
    }
    nextTick(flushSchedulerQueue);
}

function flushSchedulerQueue(){
    flushing = true;
    // çœç•¥ä»£ç 
    // æ‰§è¡Œå®Œæ›´æ–°æ“ä½œåé‡ç½®å†…éƒ¨çŠ¶æ€
    resetSchedulerState();
}
function resetSchedulerState(){
    flushing = false;
}
```
{% endbox %}
 
å¦‚ä¸Šè¿°ä»£ç æ‰€ç¤ºï¼šflushingæ˜¯ä¸€ä¸ªå†…éƒ¨çŠ¶æ€ï¼Œè¡¨ç¤ºå½“å‰æ˜¯å¦æ­£åœ¨æ‰§è¡Œ watcher çš„é˜Ÿåˆ—ã€‚é»˜è®¤ä¸º falseã€‚

å½“ç¬¬ä¸€æ¬¡æ‰§è¡Œ queueWatchæ—¶ï¼Œflushingä¸º falseï¼Œè¡¨ç¤ºå½“å‰æ²¡æœ‰æ‰§è¡Œ watcheré˜Ÿåˆ—ï¼Œè¿™ä¸ªæ—¶å€™å¤„ç†æ¯”è¾ƒç®€å•ï¼Œå°† watcher æ·»åŠ åˆ°é˜Ÿåˆ—çš„æœ«å°¾ï¼Œç­‰å¾…åç»­çš„æ‰§è¡Œã€‚

æ­¤æ—¶è°ƒç”¨nextTick(flushSchedulerQueue)æ–¹æ³•ã€‚

åœ¨åŒæ­¥ä»»åŠ¡æ‰§è¡Œä»¥åï¼Œæ‰§è¡Œå¼‚æ­¥æ—¶åœ¨flushSchedulerQueueæ–¹æ³•ä¸­å°† flushingç½®ä¸º trueï¼Œè¡¨ç¤ºå½“å‰æ­£åœ¨æ‰§è¡Œ watcheré˜Ÿåˆ—ã€‚

å¦‚æœåœ¨æ‰§è¡ŒflushSchedulerQueueæ–¹æ³•æ—¶å†æ¬¡è°ƒç”¨äº† queueWatcheræ–¹æ³•ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª idå°äºæˆ–ç­‰äº watch.idï¼Œç„¶åæ’å…¥ä»–çš„åé¢ï¼Œä¿è¯äº† watcheræŒ‰ç…§å®ƒä»¬è¢«åˆ›å»ºçš„é¡ºåºæ‰§è¡Œï¼Œå³ä½¿åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æœ‰ watcheråŠ å…¥ã€‚

## 4.5 waitingçŠ¶æ€

{% box child:codeblock color:purple %}
```js  
let waiting = false;
if (!waiting) {
    waiting = true;
    nextTick(flushSchedulerQueue)
} 

function resetSchedulerState(){
    // å°† waitingé‡ç½®ä¸º false
    waiting = false; 
}

function flushSchedulerQueue(){
    resetSchedulerState()
}
```
{% endbox %}

queueWatcheræ–¹æ³•æœ€ä¸»è¦çš„åŠŸèƒ½å°±æ˜¯æ‰§è¡Œ nextTick(flushSchedulerQueue)æ–¹æ³•ï¼Œä»è€Œè¾¾åˆ°å¼‚æ­¥æ‰¹é‡æ›´æ–°çš„ç›®çš„ã€‚
 
è€Œ waitingå†³å®šäº†æ˜¯å¦åº”è¯¥æ‰§è¡ŒflushSchedulerQueueæ–¹æ³•ã€‚

åœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œ queueWatcher(this)æ—¶ï¼Œä¼šè°ƒç”¨nextTick(flushSchedulerQueue)æ–¹æ³•ã€‚

å¹¶ä¸”å°† waitingè®¾ç½®ä¸º trueã€‚

ç„¶åç«‹å³æ‰§è¡Œå¼‚æ­¥æ›´æ–°æ“ä½œï¼Œæ‰€ä»¥ waitingè¡¨ç¤ºç›®å‰å­˜åœ¨å¼‚æ­¥æ›´æ–°æ“ä½œæ­£åœ¨ç­‰å¾…æ‰§è¡Œã€‚

ç„¶ååœ¨ä¸€æ¬¡äº‹ä»¶å¾ªç¯å†…å†æ¬¡è°ƒç”¨ queueWatcheræ–¹æ³•ï¼Œæ­¤æ—¶å·²ç»æœ‰å¼‚æ­¥æ›´æ–°æ“ä½œç­‰å¾…æ‰§è¡Œã€‚

æ‰€ä»¥ä¸å†è°ƒç”¨å¼‚æ­¥æ›´æ–°æ“ä½œï¼Œè¿™æ„å‘³ç€åœ¨ä¸€æ¬¡äº‹ä»¶å¾ªç¯å†…ï¼Œè¯¥æ–¹æ³•åªä¼šè¢«æ‰§è¡Œä¸€æ¬¡ã€‚

{% image /assets/topic/vue2/async/3.jpg %}

> è¯¥å˜é‡åœ¨å¼‚æ­¥æ›´æ–°åä¼šè¢«é‡ç½®ä¸º falseã€‚
 

## 4.6 flushSchedulerQueue

ä¸“é—¨ç”¨äºæ‰§è¡Œå¤„ç†queueé˜Ÿåˆ—ã€‚

{% box child:codeblock color:purple %}
```js  
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow()
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(sortCompareFn)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    if (__DEV__ && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
            (watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)
  cleanupDeps()

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}
```
{% endbox %}

### 4.6.1 ä½¿ç”¨sortCompareFnè¿›è¡Œæ’åº

{% box child:codeblock color:purple %}
```js  
const sortCompareFn = (a: Watcher, b: Watcher): number => {
  if (a.post) {
    if (!b.post) return 1
  } else if (b.post) {
    return -1
  }
  return a.id - b.id
}
let queue = []
function flushSchedulerQueue() { 
  // çœç•¥éƒ¨åˆ†ä»£ç 
  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(sortCompareFn)  
}
```
{% endbox %}

å› ä¸ºåœ¨ä¸€æ¬¡äº‹ä»¶å¾ªç¯å†…å¤šæ¬¡è§¦å‘ queueWatcher å‡½æ•°ä¼šç»™é˜Ÿåˆ—æ·»åŠ  watcherã€‚

æ­¤æ—¶ watcherçš„æ‰§è¡Œé¡ºåºéœ€è¦é‡æ–°æ•´ç†ï¼ŒsortCompareFnç”¨äºç»™ watcheræ’åºã€‚

> postè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªåœ¨ DOMæ›´æ–°åæ‰§è¡Œçš„ watcher

æ’åºç›®çš„ä¸»è¦æ˜¯ä¸ºäº†ç¡®ä¿ä¸‹é¢ä¸‰ç§æƒ…å†µçš„é¡ºåºï¼š

1. çˆ¶å­ç»„ä»¶æ›´æ–°é¡ºåºï¼šç»„ä»¶çš„çˆ¶ watcher åº”è¯¥åœ¨å­ watcher ä¹‹å‰æ‰§è¡Œã€‚è¿™æ˜¯å› ä¸ºçˆ¶ç»„ä»¶é€šå¸¸åœ¨å­ç»„ä»¶ä¹‹å‰åˆ›å»ºï¼Œå› æ­¤å…¶ watcher ä¹Ÿåº”è¯¥å…ˆæ‰§è¡Œã€‚
2. ç”¨æˆ· watcher ä¸æ¸²æŸ“ watcher çš„é¡ºåºï¼šç”¨æˆ·å®šä¹‰çš„ watcherï¼ˆé€šå¸¸åœ¨ç»„ä»¶çš„ watch é€‰é¡¹ä¸­å®šä¹‰ï¼‰åº”è¯¥åœ¨ç»„ä»¶çš„æ¸²æŸ“ watcher ä¹‹å‰æ‰§è¡Œã€‚è¿™æ˜¯å› ä¸ºç”¨æˆ· watcher é€šå¸¸åœ¨æ¸²æŸ“ watcher ä¹‹å‰åˆ›å»ºã€‚
3. å¤„ç†ç»„ä»¶é”€æ¯ï¼šå¦‚æœä¸€ä¸ªç»„ä»¶åœ¨çˆ¶ç»„ä»¶çš„ watcher æ‰§è¡Œè¿‡ç¨‹ä¸­è¢«é”€æ¯ï¼Œå…¶ watcher å¯ä»¥è¢«è·³è¿‡ï¼Œä»¥é¿å…å¯¹å·²é”€æ¯ç»„ä»¶çš„æ— æ•ˆæ“ä½œã€‚

### 4.6.2 æ‰§è¡Œwatcherå®ä¾‹çš„æ›´æ–°

{% box child:codeblock color:purple %}
```js   
for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    if (__DEV__ && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
            (watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`),
          watcher.vm
        )
        break
      }
    }
  }
```
{% endbox %}

åœ¨å°† watcheré¡ºåºæ’åˆ—å¥½åï¼Œç«‹å³æ‰§è¡Œéå†é˜Ÿåˆ—ä¸­çš„æ¯ä¸ª watcherå¹¶æ‰§è¡Œä»–ä»¬ã€‚

åŒæ—¶åœ¨å¼€å‘æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ— é™å¾ªç¯æ›´æ–°çš„æƒ…å†µã€‚

> å¦‚æœ has[id] ä»ç„¶ä¸ä¸º nullï¼ˆè¿™æ„å‘³ç€åœ¨å½“å‰ watcher æ‰§è¡Œåï¼Œåˆæœ‰æ–°çš„æ›´æ–°è¯·æ±‚ï¼‰ï¼Œåˆ™å¢åŠ  circular[id] çš„è®¡æ•°ï¼Œç”¨äºè·Ÿè¸ªåŒä¸€ä¸ª watcher è¢«é‡æ–°è§¦å‘çš„æ¬¡æ•°ã€‚
>
> å¦‚æœ circular[id] çš„æ¬¡æ•°è¶…è¿‡äº† MAX_UPDATE_COUNTï¼ˆä¸€ä¸ªè®¾å®šçš„æœ€å¤§æ›´æ–°æ¬¡æ•°ï¼‰ï¼Œåˆ™å‘å‡ºè­¦å‘Šï¼Œæç¤ºå¯èƒ½å­˜åœ¨æ— é™æ›´æ–°å¾ªç¯ï¼Œå¹¶ä¸­æ–­å½“å‰çš„æ‰§è¡Œå¾ªç¯ã€‚

### 4.6.3 è°ƒç”¨keep-aliveç»„ä»¶çš„activatedé’©å­

{% box child:codeblock color:purple %}
```js   
const activatedChildren: Array<Component> = []
 
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0
  has = {}
  if (__DEV__) {
    circular = {}
  }
  waiting = flushing = false
}
const activatedQueue = activatedChildren.slice()

callActivatedHooks(activatedQueue)

function callActivatedHooks(queue) {
  for (let i = 0; i < queue.length; i++) {
    queue[i]._inactive = true
    activateChildComponent(queue[i], true /* true */)
  }
}
```
{% endbox %}

å½“ä¸€ä¸ªç»„ä»¶è¢«æ’å…¥åˆ° DOM ä¸­æ—¶ï¼Œå®ƒçš„ activated é’©å­ä¼šè¢«è°ƒç”¨ã€‚

è¿™ä¸ªå‡½æ•°å¤„ç†çš„æ˜¯ activated é’©å­çš„è°ƒç”¨é€»è¾‘ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†åŠ¨æ€ç»„ä»¶ï¼ˆ<component> æ ‡ç­¾ï¼‰æˆ– keep-alive ç¼“å­˜çš„ç»„ä»¶æ—¶ã€‚

### 4.6.4 è°ƒç”¨æ™®é€šç»„ä»¶çš„ updatedé’©å­

{% box child:codeblock color:purple %}
```js   
const updatedQueue = queue.slice()

callUpdatedHooks(updatedQueue)

function callUpdatedHooks(queue: Watcher[]) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}
```
{% endbox %}

### 4.6.5 è°ƒç”¨resetSchedulerStateé‡ç½®çŠ¶æ€

{% box child:codeblock color:purple %}
```js   
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0
  has = {}
  if (__DEV__) {
    circular = {}
  }
  waiting = flushing = false
}
```
{% endbox %}

åœ¨æ‰§è¡Œå®Œ watcherå®ä¾‹çš„æ¸²æŸ“æ–¹æ³•åï¼Œéœ€è¦å°†çŠ¶æ€é‡ç½®ã€‚


### 4.6.6 æ¸…é™¤æ— æ•ˆçš„è®¢é˜…

{% box child:codeblock color:purple %}
```js   
cleanupDeps()

export const cleanupDeps = () => {
  for (let i = 0; i < pendingCleanupDeps.length; i++) {
    const dep = pendingCleanupDeps[i]
    dep.subs = dep.subs.filter(s => s)
    dep._pending = false
  }
  pendingCleanupDeps.length = 0
}
```
{% endbox %}

è¿™ä¸ªå‡½æ•°çš„ä¸»è¦ä½œç”¨æ˜¯ç§»é™¤é‚£äº›å·²ç»æ— æ•ˆçš„è®¢é˜…ï¼ˆsubsï¼‰ï¼Œè¿™äº›è®¢é˜…å¯èƒ½æ¥è‡ªäºå·²ç»è¢«é”€æ¯çš„ Watcher å®ä¾‹ã€‚ä»¥ä¸‹æ˜¯å¯¹ cleanupDeps å‡½æ•°çš„è¯¦ç»†è§£é‡Šï¼š

# äº”ã€å¼‚æ­¥å‡½æ•° nextTick

æˆ‘ä»¬çŸ¥é“Vueä½¿ç”¨å¼‚æ­¥æ¸²æŸ“çš„æ–¹å¼æ¥æé«˜æ•ˆç‡ã€‚

è€Œ Vueä¸­å°±æ˜¯ä½¿ç”¨ nextTickæ¥å®Œæˆå¼‚æ­¥è¿™ä¸ªæ“ä½œã€‚

{% box child:codeblock color:purple %}
```js   
const callbacks = []
let pending = false
export function nextTick(cb, ctx) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e: any) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}

```
{% endbox %} 

å¯ä»¥çœ‹å‡ºæ¥ nextTick å°±æ˜¯å°†ä¼ å…¥çš„å›è°ƒå‡½æ•°æ”¾å…¥ callbacksè¿™ä¸ªæ•°ç»„ä¸­ï¼Œç„¶åå†ä½¿ç”¨å¼‚æ­¥çš„ APIè¿›è¡Œè°ƒç”¨ã€‚

```js
let timerFunc

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (
  !isIE &&
  typeof MutationObserver !== 'undefined' &&
  (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')
) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
} 
```
timerFunc ç”¨äºå°†å›è°ƒå‡½æ•°æ’é˜Ÿåˆ°æµè§ˆå™¨çš„å¾®ä»»åŠ¡ï¼ˆmicrotaskï¼‰é˜Ÿåˆ—ä¸­ï¼Œä»¥ç¡®ä¿åœ¨å½“å‰è„šæœ¬æ‰§è¡Œå®Œæ¯•åï¼Œä¸‹ä¸€æ¬¡äº‹ä»¶å¾ªç¯å¼€å§‹å‰æ‰§è¡Œè¿™äº›å›è°ƒã€‚

1. ä¼˜å…ˆä½¿ç”¨ Promise.then 
2. å¦‚æœç¯å¢ƒä¸æ”¯æŒ Promise,åˆ™å°è¯•ä½¿ç”¨ MutationObserver 
3. å¦‚æœä¸Šé¢ 2 ç§éƒ½ä¸æ”¯æŒï¼Œåˆ™å°è¯•ä½¿ç”¨ setImmediate
4. å¦‚æœä¸Šé¢ 3 ç§éƒ½ä¸æ”¯æŒï¼Œåˆ™æœ€ç»ˆä½¿ç”¨ setTimeout

# å…­ã€æ€»ç»“

æœ¬æ–‡ä»‹ç»äº†Vueçš„å¼‚æ­¥æ¸²æŸ“æœºåˆ¶ä»¥åŠå¼‚æ­¥æ¸²æŸ“æœºåˆ¶å¸¦æ¥çš„å¥½å¤„ã€‚