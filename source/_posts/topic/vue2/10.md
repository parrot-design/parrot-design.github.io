---
title: 🔥Vue2双端对比
permalink: posts/vue2-diff.html
date: 2024-11-25 14:27
topic: vue2
banner: /assets/topic/vue2/async/2.jpg
---  
 
&nbsp;

{% button 返回 javascript:window.history.back() icon:solar:back-white color:orange size:xs %}

{% quot 专栏第十篇-双端对比算法 %}

上节我们说到Vue是异步批量更新的，本质上就是调用 watcher的run方法，然后调用实例上的_update方法进行重新渲染。

# 一、diff算法

## 1.1 前世今生

前世：diff 算法最初是由计算机科学家迈克尔·菲舍尔和丹尼尔·希尔伯特所发明的一种 {% u 文本比较算法 %}。

今生：伴随着前端开发的蓬勃兴起，diff 算法被引入到虚拟 DOM 当中，成为了一项用于高效更新用户界面的核心技术。其旨在高效地辨别出从一种状态转变为另一种状态所需要的最小变更集合。由于在浏览器中对 DOM 进行操作的性能消耗颇为昂贵，例如节点的添加、删除等等，所以 diff 算法能够 {% u 尽可能地降低 DOM 的操作数量，避免频繁的 DOM 操作所带来的性能耗费，进而减轻浏览器的性能负担 %}。
 
{% image /assets/topic/vue2/diff/1.jpg %}

如上图所示。如果需要将上图中左边的DOM树更新为右边的DOM树，在不采用虚拟DOM的情况下（即无法复用DOM节点），可能需要进行{% u 6次DOM操作 %}：

1. 卸载所有旧子节点，需要 3 次 DOM 删除操作。
2. 挂载所有新子节点，需要 3 次 DOM 添加操作。

但是如果采用diff算法复用DOM节点的策略进行的话，实际上只需要进行{% u 1次DOM操作 %}：

1. 移动新的一组子节点的B节点到C节点的后面。

可以看出来通过复用策略可以有效的避免频繁操作DOM带来的性能开销。

## 1.2 diff算法的复杂度

对两棵树进行 diff 操作，其复杂度为 O(n^3) 。

这是因为每个节点都需要和另一棵树的所有节点逐一进行对比，这便形成了 n 的复杂度。

倘若找到有变化的节点，执行插入、删除、修改操作同样具有 n 的复杂度。

所有的节点均是如此，再乘以 n ，因此得出的复杂度是 O(n * n * n) 。 

{% image /assets/topic/vue2/diff/2.jpg %}

如此的复杂度对于前端框架而言是无法接受的，这意味着若存在 1000 个节点，渲染一次就需要处理 1000 * 1000 * 1000，总计 10 亿次。

所以前端框架的 diff 约定了两种处理原则：{% u 1.只做同层的对比 2.type 变了就不再对比子节点 %}。

因为 DOM 节点进行跨层级移动的情形相对较少，通常情况下都是同一层级的 DOM 的增删改操作。

像这样的话，只需遍历一次，对比一下 type 就可以了，其复杂度是 O(n) 。而且一旦 type 发生变化，就不再对比子节点，能够节省下大量节点的遍历工作。另外，由于在虚拟 DOM 中记录了关联的 DOM 节点，执行 DOM 的增删改操作时也无需遍历，其复杂度是 O(1) 。整体的 diff 算法复杂度即为 O(n) 。

{% image /assets/topic/vue2/diff/3.jpg %}

## 1.3 diff算法的核心要素

### 1.3.1 同层比较

{% image /assets/topic/vue2/diff/4.jpg %}

如上图所示，算法会于两个虚拟 DOM 树的同一层级展开对比，而不会进行跨层级的对比。这代表着它首先会核查每个父节点是否一致，如果一致，接下来才会递归进入子树进行比较。倘若不同，则直接依据具体情况进行更新。

由之前的章节能够了解到：双端 diff 算法被设计为只有同层节点进行比较，其原因主要有以下两点：

1. 降低 diff 算法的复杂程度。
2. DOM 节点进行跨层级移动的情况相对较少，通常情况下都是同一层级的 DOM 的增删改操作。


### 1.3.2 相同节点判断策略

{% image /assets/topic/vue2/diff/5.jpg %}

如上图所示。在 Vue 中，判断新旧节点是否为相同节点的逻辑为：当 节点的标签（比如 p 节点） 以及 节点的（key=1） 相同时，即被视为同一个节点。之所以这样做，是因为一旦 type 或者 key 发生变化，就不再对比子节点，能够节省下大量节点的遍历工作，从而提升性能。
 
### 1.3.3 循环从两边向中间比较

{% image /assets/topic/vue2/diff/6.jpg %}

这是一种优化策略，算法不是线性遍历每一个节点，而是从两端开始，向中间逐步靠拢，这样可以在某些情况下更早地发现差异并终止不必要的比较。

1. 第一步：比较旧的一组子节点中的第一个子节点A与新的一组子节点中的第一个子节点C。
2. 第二步：比较旧的一组子节点的最后一个子节点C与旧的一组子节点的最后一个子节点B。
3. 第三步：比较旧的一组子节点的第一个子节点A与新的一组子节点中的最后一个子节点 B。
4. 第四步：比较旧的一组子节点的最后一个子节点 C与新的一组子节点的第一个节点C。

### 1.3.4 节点复用

在diff算法中，节点复用是一个非常重要的优化手段。通过复用旧节点，可以大大减少DOM操作，从而提升渲染效率。

Vue.js团队通过引入key的概念，实现了节点复用的功能。key是一个唯一的标识符，它可以帮助Vue.js区分不同的节点。当新旧节点的key相同时，Vue.js就会复用旧节点，而不是创建新节点。

* 在没有key的情况下，判断下面属于同一个节点，直接进行子节点的对比，子节点是文字，则直接更新文字。（这里因为没有key值无法进行复用，复用的话只需要移动A节点的位置即可）。

{% image /assets/topic/vue2/diff/7.jpg %}

* 在存在key的情况下，使用双端 diff的四步对比进行。

{% image /assets/topic/vue2/diff/8.jpg %}

1. 第一步，在有key的情况下，判断不属于同个节点，跳过
2. 第二步，在有key的情况下，判断不属于同个节点，跳过
3. 第三步，在有key的情况下，判断属于同个节点，进行节点复用操作（具体操作后续会说）

# 二、虚拟 DOM和 diff的关联

在[专栏第六篇](/posts/vue2-vnode.html)中，我们介绍了虚拟DOM。 

我们知道虚拟DOM是一种可以表示DOM的抽象层面的树形结构，它可以高效地更新到实际的DOM上。

在Vue中，每个组件都有一个对应的渲染函数，这个函数返回一个描述该组件视图的虚拟节点树。

在初次渲染时，会调用渲染函数生成一个虚拟节点树。

当组件的状态发生变化时，渲染函数会被再次调用，产生一个新的虚拟节点树。

Vue的diff算法就是用来比较新旧虚拟节点树的差异，找出最小的DOM操作来更新实际的DOM。

所以 Vue的 diff只会发生在更新阶段。初次挂载直接创建并挂载节点。

{% box child:codeblock color:purple %}
```js
// 假设有一个简单的组件
let component = {
  data: 'Hello, Vue!',
  template: `<div>{{ data }}</div>`
};
 
// 首次渲染，生成虚拟DOM
let oldVnode = Vue.render(component);
 
// 假设数据（data）更新，产生新的虚拟DOM
let newVnode = Vue.render(component);
 
// Vue的diff算法比较新旧虚拟DOM
let patches = Vue.diff(oldVnode, newVnode);
 
// 根据diff结果应用到实际DOM
Vue.patch(document.body, patches);
```
{% endbox %}

在这个例子中，Vue首次渲染组件时生成了一个虚拟DOM节点（oldVnode）。当组件的数据更新时，Vue再次渲染组件，生成了一个新的虚拟DOM节点（newVnode）。Vue的diff算法会比较这两个虚拟节点，找出需要执行的最小DOM操作（patches），最后这些DOM操作会被应用到实际的DOM上，以此来更新视图。
 
# 三、 snabbdom简介

Snabbdom是瑞典语单词，原意为”速度“。是一个轻量级的虚拟DOM和DOM diff算法库，它被设计用于以非常高效的方式更新真实DOM。Vue.js在2.x版本中采用了虚拟DOM的概念来提高其性能和效率，而Vue 2.x内部使用的虚拟DOM实现实际上是在Snabbdom的基础上进行了一些定制和改造的。
 
Vue团队选择Snabbdom作为其虚拟DOM实现的原因主要是因为Snabbdom的高性能特性和小巧的体积。它提供了一个简洁的API来创建和管理虚拟节点（vnodes），并通过高效的diff算法来计算出虚拟DOM树的最小变更集，进而只对实际DOM进行必要的更新，减少了不必要的DOM操作，提高了页面的渲染效率。

vue2源码中更新基本和snabbdom中一致，部分边角细节不一致，所以我们看一下snabbdom源码大致就可以了解Vue更新的细节。
 
github地址：[https://github.com/snabbdom/snabbdom](https://github.com/snabbdom/snabbdom)

{% box child:codeblock color:purple %}
```js
import {
  init,
  h
} from "snabbdom";

// 调用 init生成 patch渲染函数
const patch = init([]);

const container = document.getElementById("container");

const myVnode = h('div',[
    h('p','苹果'),
    h('p','香蕉'),
    h('p','火龙果'),
]);

const myVnode2 = h('div',[
    h('p','苹果'),
    h('p','香蕉'),
    h('p','桃子'),
])

// 第一个参数为 DOM节点
// 第二个参数为 VNODE节点
// 表示第一次执行挂载操作
patch(container, myVnode);

document.getElementById('btn').addEventListener('click',()=>{
    // 第一个参数为 DOM节点
    // 第二个参数为 VNODE节点
    // 表示执行更新操作
    patch(myVnode, myVnode2);
})
```
{% endbox %}

界面上渲染效果如下所示：

{% image /assets/topic/vue2/diff/9.png %}

点击按钮后：

{% image /assets/topic/vue2/diff/10.png %}

由之前的diff算法可知，当点击更新以后，界面上会复用前两个元素苹果和香蕉(即没有销毁以及重新创建)，那么如何证明它复用了呢，其实很简单，{% u 只需要在浏览器中手动更改前2个元素，如果点击更新以后，更改的前2个元素没有变化，即可证明它并对dom节点进行了复用 %}。

如上代码所示，patch即为vue中的第一次渲染，点击按钮更新新的vnode相当于vue中的更新渲染，只不过vue中将行为进行了一些封装。所以掌握snabbdom即可掌握vue2的核心双端diff算法。