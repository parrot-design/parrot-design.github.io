---
title: 🔥Vue2模版编译
permalink: posts/vue2-template-compiler.html
date: 2024-12-16 13:16
topic: vue2
banner: /assets/topic/vue2/banner/diff.jpg
---  

&nbsp;

{% button 返回 javascript:window.history.back() icon:solar:back-white color:orange size:xs %}

{% quot 专栏第十二篇-模版编译 %}

# 一、模版编译

通常我们使用SPA（SinglePage Web Application）的方式来编写Vue应用（即使用{% u .vue %}文件的方式来开发）。

显然浏览器不认识后缀为{% u .vue %}的文件。

所以为了让浏览器能够识别vue文件，一般在Vue项目中，vue-loader + webpack在预编译阶段会将.vue文件中的模版部分解析成一个render函数。

然后在渲染时就可以执行对应的render函数来生成对应的vnode。

拿到 vnode以后，就可以将 vnode转化成真实 DOM 元素然后渲染到页面上。

{% image /assets/topic/vue2/template-compiler/1.jpg %}

# 二、模版编译转化步骤

> 由于对.vue文件的编译涉及到webpack等相关的理论知识，所以我们后面的解析都是基于template模版进行分析的。
>
> 不过template解析和.vue解析用的核心库以及逻辑都是相同的，所以我们可以不去在意。

在Vue中，模板解析大致分为3步：

1. {% u 将模板转化为AST树 %}
2. {% u 对AST树进行优化 %}
3. {% u 将AST树转化为render函数 %} 

{% box child:codeblock color:purple %}
```js 
// 第一步：转化模板字符串为ast树
const ast = parse(template.trim(), options)
// 第二步：优化ast树
optimize(ast, options)
// 第三步：根据ast树生成对应的render函数字符串
const code = generate(ast, options)
```
{% endbox %} 
  
## 2.1 第一步：将template模板转化成AST树

因为模板就是一段字符串，是非结构化的数据，不利于进行分析。

所以第一步是将非结构化的模板字符串，换变成结构化的 JS对象抽象语法树，即 AST。

这个网站[https://astexplorer.net/](https://astexplorer.net/)可以将模板转成成对应的 AST。

> 注意解析内容选择 Vue，解析器选择 {% u vue-template-compiler %}。

{% image /assets/topic/vue2/template-compiler/2.png %}

## 2.2 第二步：对AST树进行优化

第一步仅仅负责将字符串模版转化成AST树。

而第二步的主要作用是对AST树进行优化，以提升运行时的渲染性能。

优化逻辑可以标记那些在组件生命周期内不会变化的节点为静态节点。

这些节点在后续的渲染过程中不需要进行虚拟DOM的diff对比，从而减少了不必要的计算和DOM操作

## 2.3 第三步：将AST树转化为 render 函数

在得到 模板 对应的 AST 对象以后。

先转换为一段可以创建元素的字符串，然后再用 new Function(`with(this){return 创建元素的字符串}`)生成对应的 render函数。

## 2.4 总结

{% box child:codeblock color:purple %}
```vue 
<template>
    <div>Hello World</div>
</template>
```
{% endbox %}

上面的模板最终会变成下面的render函数。

{% box child:codeblock color:purple %}
```js 
render:new Function(`with(this){return _c('div',[
    _v("Hello World") 
])}`) 
```
{% endbox %}

> _c就是我们上一篇文章提到的 createElement 函数 。执行createElement函数可以方便我们生成 vnode。

> _v就是我们上一篇文章提到的创建文本的函数：{% u createTextVNode %}。

{% u new Function() %} 可以根据参数内容生成一个函数。

而 {% u with(this) %}语句意味着函数体内的所有变量都将从 this对象中查找，比如上面的{% u _v、_c %}。
 
所以执行生成的 render 函数就可以获取模板对应的 vnode。