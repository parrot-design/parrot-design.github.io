---
title: ğŸ”¥Vue2åˆæ¬¡æ¸²æŸ“æµç¨‹
permalink: posts/vue2-init-render.html
date: 2024-11-15 14:48
topic: vue2
banner: /assets/topic/vue2/banner/init-render.jpg
--- 

{% quot ä¸“æ ç¬¬ä¸ƒç¯‡-åˆæ¬¡æ¸²æŸ“æµç¨‹ %}

ä¸Šç¯‡æˆ‘ä»¬ä»‹ç»äº†Vueæ¸²æŸ“çš„åŸºç¡€-è™šæ‹ŸDOMã€‚

åœ¨æ¸²æŸ“é˜¶æ®µï¼ŒVueé€šè¿‡è™šæ‹Ÿ DOMæ¥åˆ›å»ºå…ƒç´ ã€‚

# ä¸€ã€ç¼–è¯‘æ—¶çš„æŒ‚è½½æ“ä½œ

åœ¨ä¸“æ ç¬¬å››ç¯‡ä¸­ï¼Œæˆ‘ä»¬æåˆ°äº†åœ¨Vueå®ä¾‹åŒ–æ—¶ï¼Œä¼šæ‰§è¡Œinitå‡½æ•°æ¥åˆå§‹åŒ–ä¸€äº›åç»­éœ€è¦çš„é€‰é¡¹ã€‚

é€šå¸¸åœ¨å®ä¾‹åŒ–åæˆ‘ä»¬ä¼šæ‰§è¡ŒæŒ‚è½½æ“ä½œã€‚

è€Œæœç´¢æºç å¯ä»¥å‘ç°ï¼Œ$mountæ–¹æ³•è¢«å®šä¹‰äº† 2 æ¬¡ã€‚

æ ¹æ®æ˜¯å¦éœ€è¦æ¨¡ç‰ˆç¼–è¯‘ï¼Œå­˜åœ¨ 2 ä¸ª$mountæ–¹æ³•ã€‚

åœ¨æ¨¡æ¿ç¼–è¯‘ç‰ˆæœ¬çš„ Vueä¸­ï¼Œé‡å†™äº†è¿è¡Œæ—¶çš„$mountæ–¹æ³•ï¼Œå…¶ä¸­æ·»åŠ äº†ä¸€äº›æ¨¡æ¿ç¼–è¯‘çš„æ–¹æ³•ã€‚

> æ¨¡æ¿ç¼–è¯‘æ„ä¸ºå°† templateè½¬åŒ–æˆ renderå‡½æ•°ã€‚

{% box child:codeblock color:purple %}
```js
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    __DEV__ &&
      warn(
        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
      )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (__DEV__ && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (__DEV__) {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // @ts-expect-error
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: __DEV__,
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
} 
```
{% endbox %}

1. é¦–å…ˆè·å–ä¼ å…¥elå‚æ•°ï¼Œä¹Ÿå°±æ˜¯æŒ‚è½½çš„èŠ‚ç‚¹ã€‚
2. ç„¶ååˆ¤æ–­æŒ‚è½½èŠ‚ç‚¹æ˜¯å¦æ˜¯bodyèŠ‚ç‚¹æˆ–è€…htmlèŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯åˆ™æç¤ºæ— æ³•æŒ‚è½½å¹¶è¿”å›ã€‚
3. å¦‚æœæ²¡æœ‰renderæ–¹æ³•ï¼Œè·å–templateé€‰é¡¹ã€‚ 
    1. å¦‚æœå­˜åœ¨ templateé€‰é¡¹ï¼š
        - templateæ˜¯ä¸€ä¸ªé€‰æ‹©èŠ‚ç‚¹å­—ç¬¦ä¸²{% mark ("#app") color:orange %}ï¼Œå°†templateå˜é‡è®¾ç½®ä¸ºèŠ‚ç‚¹å­—ç¬¦ä¸²å¯¹åº”çš„HTMLä»£ç ã€‚
        - templateæ˜¯ä¸€ä¸ªçœŸå®DOMèŠ‚ç‚¹ï¼Œå°†templateå˜é‡è®¾ç½®ä¸ºèŠ‚ç‚¹å¯¹åº”çš„HTMLä»£ç ã€‚
        - å¦‚æœéƒ½ä¸æ˜¯ï¼Œåˆ™ä¼šæç¤ºæ— æ•ˆçš„templateé€‰é¡¹ã€‚
    2. å¦‚æœä¸å­˜åœ¨ templateé€‰é¡¹ï¼Œä½†æ˜¯æœ‰ elèŠ‚ç‚¹ï¼Œåˆ™å°†templateå˜é‡è®¾ç½®ä¸ºelèŠ‚ç‚¹å¯¹åº”çš„ HTMLä»£ç ã€‚
    3. è·å–åˆ°å¯¹åº”çš„æ¨¡æ¿ï¼Œç„¶åå°†è¿™ä¸ªå°†è¿™ä¸ªæ¨¡æ¿è½¬æ¢æˆ renderå‡½æ•°
4. å¦‚æœæœ‰renderæ–¹æ³•ï¼Œç›´æ¥æ‰§è¡Œ mountæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¿è¡Œæ—¶å®šä¹‰çš„$mountæ–¹æ³•ã€‚

# äºŒã€è¿è¡Œæ—¶çš„æŒ‚è½½æ“ä½œ

ä¸Šé¢æˆ‘ä»¬è¯´åˆ°ç¼–è¯‘æ—¶çš„$mountæ–¹æ³•å°†æ¨¡æ¿è½¬æ¢æˆäº†renderæ–¹æ³•ã€‚

ç„¶åè°ƒç”¨äº†è¿è¡Œæ—¶çš„$mountæ–¹æ³•ã€‚

è®©æˆ‘ä»¬æ¥çœ‹çœ‹$mountæ–¹æ³•éƒ½åšäº†ä»€ä¹ˆæ“ä½œã€‚

{% box child:codeblock color:purple %}
```js
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```
{% endbox %}

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å°±æ˜¯è·å–èŠ‚ç‚¹ï¼Œç„¶åè°ƒç”¨äº†mountComponentæ–¹æ³•ã€‚

# ä¸‰ã€mountComponent

å¯ä»¥çœ‹å‡ºæ¥æœ€ç»ˆæ‰§è¡Œäº†mountComponentæ–¹æ³•ã€‚

æˆ‘ä»¬æŠŠç›®å…‰ç§»åˆ°mountComponentæ–¹æ³•ä¸­ã€‚

{% box child:codeblock color:purple %}
```js
export function mountComponent(
  vm: Component,
  el: Element | null | undefined,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    // @ts-expect-error invalid type
    vm.$options.render = createEmptyVNode
    if (__DEV__) {
      /* istanbul ignore if */
      if (
        (vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el ||
        el
      ) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (__DEV__ && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  const watcherOptions: WatcherOptions = {
    before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }

  if (__DEV__) {
    watcherOptions.onTrack = e => callHook(vm, 'renderTracked', [e])
    watcherOptions.onTrigger = e => callHook(vm, 'renderTriggered', [e])
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(
    vm,
    updateComponent,
    noop,
    watcherOptions,
    true /* isRenderWatcher */
  )
  hydrating = false

  // flush buffer for flush: "pre" watchers queued in setup()
  const preWatchers = vm._preWatchers
  if (preWatchers) {
    for (let i = 0; i < preWatchers.length; i++) {
      preWatchers[i].run()
    }
  }

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```
{% endbox %}

1. å°†ä¼ å…¥çš„èŠ‚ç‚¹æŒ‚è½½ vm.$elä¸Šã€‚
2. åˆ¤æ–­æ˜¯å¦æœ‰ renderæ–¹æ³•ã€‚å¦‚æœæ²¡æœ‰renderæ–¹æ³•åˆ™ä¼šèµ‹äºˆrenderæ–¹æ³•ä¸€ä¸ªåˆ›å»ºç©º VNodeçš„æ–¹æ³•ä»¥åŠæç¤ºå¦åˆ™ã€‚æœ‰åˆ™ç»§ç»­å‘ä¸‹æ‰§è¡Œä»£ç ã€‚
3. è°ƒç”¨ beforeMounté’©å­
4. å®šä¹‰updateComponentæ–¹æ³•ï¼Œå…¶ä¸­æ ¹æ®æ˜¯å¦é…ç½®æ€§èƒ½é…ç½®åœ¨è¯¥æ–¹æ³•ä¸­æ‰“äº†ä¸€ä¸ªæ€§èƒ½ tagã€‚
5. ä¼ å…¥updateComponentæ–¹æ³•å¹¶å®ä¾‹åŒ– Watcherï¼Œåœ¨å®ä¾‹åŒ–æ—¶ä¼šæ‰§è¡Œä¼ å…¥çš„updateComponentæ–¹æ³•ã€‚
6. åˆ¤æ–­$vnodeæ˜¯å¦æœ‰å€¼ï¼Œæœ‰å€¼åˆ™è°ƒç”¨ mountedæ–¹æ³•ã€‚ 

è‡³æ­¤æˆ‘ä»¬å·²ç»å®Œæˆäº†æŒ‚è½½é˜¶æ®µçš„æºç é˜…è¯»ã€‚

å®é™…ä¸Š updateComponent å°±æ˜¯çœŸæ­£æ¸²æŸ“å’ŒæŒ‚è½½èŠ‚ç‚¹çš„åœ°æ–¹ã€‚

{% box child:codeblock color:purple %}
```js
updateComponent  = vm._update(vm._render())
```
{% endbox %}

æˆ‘ä»¬æ¥ç”»ä¸ªæµç¨‹å›¾æ¥åŠ æ·±å·©å›ºä¸€ä¸‹æ•´ä¸ªæ¸²æŸ“æµç¨‹ã€‚

{% image /assets/topic/vue2/init/1.jpg %}

æ‰€ä»¥ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¾ˆæ¸…æ¥šçš„çœ‹å‡ºæ¥ã€‚

Vueæ¸²æŸ“å¤§ä½“ä¸Šåˆ†ä¸º 2 æ­¥ï¼š

1. è°ƒç”¨vm._renderæ–¹æ³•è·å– vnodeã€‚
2. è°ƒç”¨vm._updateå°†è·å–åˆ°çš„ vnodeæ¸²æŸ“åˆ°é¡µé¢ä¸Šã€‚

# å››ã€è°ƒç”¨_renderæ–¹æ³•æ¥è·å– vnode

{% box child:codeblock color:purple %}
```js
 Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode && vm._isMounted) {
      vm.$scopedSlots = normalizeScopedSlots(
        vm.$parent!,
        _parentVnode.data!.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
      if (vm._slotsProxy) {
        syncSetupSlots(vm._slotsProxy, vm.$scopedSlots)
      }
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode!
    // render self
    const prevInst = currentInstance
    const prevRenderInst = currentRenderingInstance
    let vnode
    try {
      setCurrentInstance(vm)
      currentRenderingInstance = vm
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e: any) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (__DEV__ && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(
            vm._renderProxy,
            vm.$createElement,
            e
          )
        } catch (e: any) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = prevRenderInst
      setCurrentInstance(prevInst)
    }
    // if the returned array contains only a single node, allow it
    if (isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (__DEV__ && isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```
{% endbox %}

å¯ä»¥çœ‹å‡ºæ¥_renderæ–¹æ³•å°±æ˜¯è·å–é€‰é¡¹ä¸Šçš„renderå‡½æ•°å¹¶æ‰§è¡Œï¼Œå°±å¯ä»¥è·å–vnodeäº†ã€‚

renderå‡½æ•°çš„å…·ä½“é€»è¾‘åœ¨ä¸Šä¸€ç« ä¸­æˆ‘ä»¬ä¹Ÿäº†è§£çš„å·®ä¸å¤šäº†ã€‚

å°±æ˜¯é€šè¿‡å†…éƒ¨çš„ createElement å‡½æ•°æ¥åˆ›å»ºVNodeã€‚

{% image /assets/topic/vue2/init/2.jpg %}

# äº”ã€è°ƒç”¨_updateæ–¹æ³•æ¥è¿›è¡Œæ¸²æŸ“

_updateæ–¹æ³•è¢«å®šä¹‰åœ¨lifecycleMixinæ–¹æ³•ä¸­ã€‚

{% box child:codeblock color:purple %}
```js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    let wrapper: Component | undefined = vm
    while (
      wrapper &&
      wrapper.$vnode &&
      wrapper.$parent &&
      wrapper.$vnode === wrapper.$parent._vnode
    ) {
      wrapper.$parent.$el = wrapper.$el
      wrapper = wrapper.$parent
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }
```
{% endbox %}

## 5.1 é€šè¿‡vm._vnodeæ¥åˆ¤æ–­æ˜¯å¦æ˜¯åˆæ¬¡æ¸²æŸ“

_updateæ–¹æ³•çš„æ‰§è¡Œç›´æ¥æœ‰ 2 ä¸ªï¼š{% mark 1.åˆæ¬¡æ¸²æŸ“ã€2.æ›´æ–°æ¸²æŸ“ã€‚color:orange %}ã€‚

åœ¨æ¯æ¬¡æ¸²æŸ“æ—¶ï¼Œä¼šå°†å½“å‰ä¼ å…¥çš„ vnodeèµ‹å€¼ç»™ vm._vnodeã€‚

è€Œåœ¨åšæ­¤æ“ä½œå‰ï¼Œä¼šè·å–vm._vnodeæ„å‘³ä¸Šä¸€æ¬¡æ¸²æŸ“çš„ vnodeã€‚

é‚£ä¹ˆåœ¨åˆæ¬¡æ¸²æŸ“æ—¶ï¼ŒprevVnodeè¿™ä¸ªå€¼æ˜¯ç©ºçš„ã€‚

æ‰€ä»¥å°±å¯ä»¥æ ¹æ®è¿™ä¸ªå€¼æ¥åˆ¤æ–­æ˜¯å¦æ˜¯åˆæ¬¡æ¸²æŸ“ã€‚

å¦‚æœæ˜¯åˆæ¬¡æ¸²æŸ“ï¼Œè°ƒç”¨__patch__å‡½æ•°ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°å’Œç¬¬äºŒä¸ªå‚æ•°åˆ†åˆ«ä¸º vm.$elã€vnodeã€‚

å¦‚æœæ˜¯æ›´æ–°æ¸²æŸ“ï¼Œè°ƒç”¨__patch__å‡½æ•°ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°å’Œç¬¬äºŒä¸ªå‚æ•°åˆ†åˆ«ä¸º prevVnodeã€vnodeã€‚

## 5.2 vm.$elæ˜¯ä»€ä¹ˆ

vm.$elæ˜¯åœ¨ mountComponentå‡½æ•°ä¸­èµ‹å€¼çš„ã€‚

ä¹Ÿå°±æ˜¯æ‰§è¡Œ$mountæ–¹æ³•ä¸­ä¼ å…¥çš„æŒ‚è½½çš„èŠ‚ç‚¹ã€‚

{% box child:codeblock color:purple %}
```js
vm.$mount('#app')
```
{% endbox %}

æ‰€ä»¥åˆæ¬¡æ¸²æŸ“æ—¶ï¼Œvm.$elå°±æ˜¯çœŸå®çš„ DOMèŠ‚ç‚¹ã€‚

## 5.3 __patch__

è¯¥æ–¹æ³•æ˜¯é€šè¿‡createPatchFunctionå‡½æ•°æ¥åˆ›å»ºçš„ã€‚

æ‰€ä»¥ createPatchFunctionå‡½æ•°è¿”å›äº†ä¸€ä¸ªå‡½æ•°ã€‚

{% box child:codeblock color:purple %}
```js
export const patch: Function = createPatchFunction({ nodeOps, modules })
```
{% endbox %}

1. nodeOpsæ˜¯æµè§ˆå™¨æ“ä½œDOMçš„ç›¸å…³æ–¹æ³•ã€‚å¦‚åˆ é™¤ DOMã€æ·»åŠ  DOMç­‰ã€‚
2. modulesä¸­å­˜åœ¨äº†ä¸€äº›å¤„ç† DOM å±æ€§çš„æ–¹æ³•ã€‚å¦‚è®¾ç½®æ ·å¼ç­‰ã€‚

## 5.4 createPatchFunction  

### 5.4.1 ç¬¬ä¸€ä¸ªå‚æ•°oldVNodeå’Œç¬¬äºŒä¸ªå‚æ•°vnode

{% box child:codeblock color:purple %}
```js
function createPatchFunction(){
  return function patch(oldVnode,vnode){
    // xxx
  }
}
```
{% endbox %}

å¯ä»¥çœ‹åˆ°è¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯oldVnodeï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ vnodeã€‚

oldVnodeè¡¨ç¤ºæ—§çš„ vnodeã€‚

Vueåœ¨æ›´æ–°æ¸²æŸ“æ—¶ï¼Œä¼šè¿›è¡ŒåŒç«¯ diffå¯¹æ¯”ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦è·å–æ—§çš„ vnodeè¿›è¡Œå¯¹æ¯”ã€‚

å› ä¸ºè¿™ä¸ªå‡½æ•°æ—¶åˆæ¬¡æ¸²æŸ“å’Œæ›´æ–°æ¸²æŸ“çš„é€šç”¨å‡½æ•°ã€‚

è€Œå‰é¢æˆ‘ä»¬è¯´åˆ°åœ¨å¤„ç†æ¸²æŸ“æ—¶ä¼ é€’çš„æ˜¯ vm.$elï¼Œè¿™ä»£è¡¨æŒ‚è½½çš„èŠ‚ç‚¹ã€‚

æ‰€ä»¥å¯¹äºåˆæ¬¡æ¸²æŸ“ï¼ˆå°†è™šæ‹ŸèŠ‚ç‚¹æ¸²æŸ“åˆ°çœŸå®èŠ‚ç‚¹ï¼‰æ¥è¯´ï¼Œæ—§èŠ‚ç‚¹è¡¨ç¤ºçœŸå®çš„èŠ‚ç‚¹ã€‚

{% mark å®é™…ä¸ŠæŒ‚è½½èŠ‚ç‚¹ç›¸å½“äºä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹ï¼Œä¼šæ ¹æ®ä»–çš„ä½ç½®è¿›è¡ŒæŒ‚è½½èŠ‚ç‚¹ï¼ŒæŒ‚è½½èŠ‚ç‚¹åœ¨åˆæ¬¡æ¸²æŸ“åå°±ä¼šè¢«åˆ é™¤ã€‚ color:orange %}

### 5.4.2 å¤„ç†æ—§èŠ‚ç‚¹çš„é”€æ¯

å¦‚æœæ—§çš„è™šæ‹ŸèŠ‚ç‚¹å­˜åœ¨ï¼Œä½†æ˜¯æ–°çš„è™šæ‹ŸèŠ‚ç‚¹ä¸å­˜åœ¨ã€‚

åˆ™è¡¨ç¤ºè¯¥èŠ‚ç‚¹å¯èƒ½ç”±äºæ¡ä»¶æ¸²æŸ“ï¼ˆv-ifï¼‰è¢«ç§»é™¤ï¼Œè¿™æ—¶å€™è°ƒç”¨invokeDestroyHookå‡½æ•°ï¼Œç¡®ä¿æ—§èŠ‚ç‚¹è¢«æ­£ç¡®çš„é”€æ¯å’Œæ¸…ç†ã€‚

å¦‚æœæ–°èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™ç»ˆæ­¢å½“å‰çš„ patchæ“ä½œã€‚

è¿™æ˜¯å› ä¸ºæ²¡æœ‰æ–°çš„èŠ‚ç‚¹éœ€è¦æ¸²æŸ“ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦ç»§ç»­æ‰§è¡Œæ›´æ–° DOMçš„æ“ä½œã€‚

{% box child:codeblock color:purple %}
```js
if (isUndef(vnode)) {
  if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
  return
}
```
{% endbox %}

### 5.4.3 åˆ¤æ–­æ—§çš„vnodeæ˜¯å¦æ˜¯çœŸå®èŠ‚ç‚¹

å› ä¸ºåœ¨åˆæ¬¡æ¸²æŸ“æ—¶ï¼Œæ—§çš„ vnodeæ˜¯æŒ‚è½½å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªçœŸå® DOMã€‚

è€Œ patchå†…éƒ¨çš„å¤„ç†åŸºæœ¬ä¸Šéƒ½æ˜¯åŸºäºè™šæ‹Ÿ DOMæ¥å¤„ç†çš„ã€‚

æ‰€ä»¥éœ€è¦å°†çœŸå® DOMé€šè¿‡emptyNodeAtå‡½æ•°åŒ…è£…æˆè™šæ‹Ÿ DOMã€‚

{% box child:codeblock color:purple %}
```js
function emptyNodeAt(elm) {
  return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
}
```
{% endbox %}

{% mark å°†è™šæ‹ŸèŠ‚ç‚¹çš„elmå±æ€§æŒ‡å‘ä¼ å…¥çš„domèŠ‚ç‚¹ã€‚ color:orange %}

### 5.4.4 createElmåˆ›å»ºå­èŠ‚ç‚¹

åˆæ¬¡æ¸²æŸ“æ—¶ï¼Œæˆ‘ä»¬æ— éœ€å…³å¿ƒæ›´æ–°çš„é€»è¾‘ã€‚

åªéœ€è¦å°†æœ€æ–°çš„ vnodeæ¸²æŸ“åˆ°é¡µé¢ä¸Šå³å¯ã€‚

ç›´æ¥è°ƒç”¨ createElmæ–¹æ³•ã€‚

#### 5.4.4.1 åˆ›å»ºDOMå…ƒç´ 

{% box child:codeblock color:purple %}
```js
export function createElm(
  vnode,
  parentElm,
  refElm
){
  const tag = vnode.tag;
  const children = vnode.children;
  if(isDef(tag)){
    vnode.elm = nodeOps.createElement(tag);

    createChildren(vnode, children);
  }
}

export function createChildren(vnode, children){
  if(isArray(children)){
    createElm(
      children[i],
      vnode.elm,
      null
    )
  }
}
```
{% endbox %}

å¯ä»¥çœ‹åˆ°createElmæ–¹æ³•ä¸­è°ƒç”¨äº†document.createElementåˆ›å»ºäº† DOMå…ƒç´ å¹¶å°†åˆ›å»ºçš„å…ƒç´ èµ‹å€¼ç»™è™šæ‹ŸèŠ‚ç‚¹çš„ elmå±æ€§ä¸­ã€‚

#### 5.4.4.2 æ‰§è¡Œ insetæ–¹æ³•å°†åˆ›å»ºçš„ DOMæŒ‚è½½åˆ°çˆ¶èŠ‚ç‚¹ä¸Š

{% box child:codeblock color:purple %}
```js
insert(parentElm, vnode.elm, refElm)

function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (nodeOps.parentNode(ref) === parent) {
          nodeOps.insertBefore(parent, elm, ref)
        }
      } else {
        nodeOps.appendChild(parent, elm)
      }
    }
}
```
{% endbox %}

å¦‚æœæœ‰ refèŠ‚ç‚¹ï¼Œåˆ™è°ƒç”¨ insetBeforeæ’å…¥ refèŠ‚ç‚¹ä¹‹å‰ã€‚

å¦åˆ™è°ƒç”¨ appendChild ç›´æ¥æ’å…¥æ•°ç»„æœ€åé¢ã€‚

#### 5.4.4.3 åˆæ¬¡æ¸²æŸ“æ—¶éœ€è¦åˆ é™¤æ—§èŠ‚ç‚¹

èŠ‚ç‚¹åˆæ¬¡æŒ‚è½½åï¼Œéœ€è¦å°†æ—§çš„èŠ‚ç‚¹ç»™åˆ é™¤æ‰ã€‚

{% box child:codeblock color:purple %}
```js
// destroy old node
if (isDef(parentElm)) {
  removeVnodes([oldVnode], 0, 0)
} else if (isDef(oldVnode.tag)) {
  invokeDestroyHook(oldVnode)
}
```
{% endbox %} 

{% image /assets/topic/vue2/init/3.jpg %}

# å…­ã€æ€»ç»“

æˆ‘ä»¬è¿™ç¯‡ä¸­ç®€å•ä»‹ç»äº†åˆæ¬¡æŒ‚è½½æ—¶çš„å¤§æ¦‚æµç¨‹ã€‚

å®é™…ä¸Šå°±æ˜¯é€šè¿‡æµè§ˆå™¨çš„ä¸€äº› APIå¦‚createElementã€appendChildæ¥åˆ›å»ºçœŸå® DOMã€‚

å…¶ä¸­æ¶‰åŠåˆ°çš„ä¸€äº›ç»†èŠ‚å¹¶æ²¡æœ‰åšè¯¦ç»†é˜è¿°ï¼Œæ¯”å¦‚è¯´ç»„ä»¶çš„å¤„ç†ï¼Œæ ·å¼äº‹ä»¶å±æ€§çš„æ³¨å†Œç­‰ã€‚

åœ¨åé¢çš„æ–‡ç« ä¸­æˆ‘ä»¬ä¼šä¸€ä¸€ç»™å¤§å®¶è§£ç­”ã€‚

{% image /assets/topic/vue2/banner/init-render.jpg %}
