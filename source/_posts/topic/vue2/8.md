---
title: 🔥Vue2数据响应式原理
permalink: posts/vue2-observe.html
date: 2024-11-18 14:39
topic: vue2
banner: /assets/topic/vue2/banner/init-render.jpg
--- 

{% quot 专栏第八篇-数据响应式原理 %}

上一篇中我们将初次渲染页面的流程大致的过了一遍。

当然，还有很多细节没有描述。

Vue中最核心的部分的就是数据驱动视图，所谓响应式就是当数据发生改变时，界面会同步更新。

# 一、数据代理的基础

数据代理，有时也被称作数据劫持，是一种技术手段，它能够截获对对象属性的访问和修改操作，并在这些操作发生时执行额外的逻辑或修改返回的结果。

在 Vue.js 中，响应式系统的核心机制正是基于数据代理。

通过代理，Vue 能够{% mark 在数据被访问时收集依赖，在数据被修改时更新这些依赖 color:red %}，这是响应式系统运作的基本理念。

而这一切都依赖于 Vue 对数据进行的拦截和代理操作。

尽管响应式特性本身并非本节的讨论重点，我们将探索数据代理在其他场景下的应用。

在深入分析之前，重要的是要理解实现数据代理的两种主要方法：{% mark Object.defineProperty color:orange %}和 {% mark Proxy color:orange %}。

这两种方法为我们提供了强大的支持，以实现对数据访问和修改行为的精细控制。 

## 1.1 Object.defineProperty

Vue是通过这个API对数据进行监听的。

> Object.defineProperty() 方法用于在一个对象上直接定义一个新属性，或者修改一个对象的现有属性，并返回该对象。

基本使用如下：

{% box child:codeblock color:purple %}
```js
Object.defineProperty(obj, prop, descriptor)
```
{% endbox %}

参数说明：

> obj：必需。目标对象
> props：必需。需定义或修改的属性的名字
> descriptor：必需。目标属性所拥有的特性

Object.defineProperty() 允许我们精确地添加或修改对象的属性。 

给对象的属性添加特性描述有两种形式：{% mark 1.数据描述和2.存取描述 color:orange %}。

数据描述和存取描述所对应的属性是不同的。

### 1.1.1 数据描述

当修改或定义对象的某个属性的时候，给这个属性添加一些特性。

{% box child:codeblock color:purple %}
```js
let obj = {
    test:'hello world'
}
//对已有的属性添加特性描述
Object.defineProperty(obj,"test",{
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
});
//对新添加的属性的特性描述
Object.defineProperty(obj,"newKey",{
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
});
```
{% endbox %}

数据描述中的属性都是可选的，来看一下设置每一个属性的作用。

#### 1.1.1.1 value 

属性对应的值，可以使用任意类型的值，默认为 undefined。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：不设置value属性
Object.defineProperty(obj,"newKey",{

});
console.log( obj.newKey );  //undefined
----------------------------------------
//第二种情况：设置value属性
Object.defineProperty(obj,"newKey",{
    value:"hello"
});
console.log( obj.newKey );  //hello
```
{% endbox %}


#### 1.1.1.2 writable 

属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：writable设置为false，不能重写。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false
});
//更改newKey的值
obj.newKey = "change value";
console.log( obj.newKey );  //hello
------------------------------
//第二种情况：设置value属性
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true
});
//更改newKey的值
obj.newKey = "change value";
console.log( obj.newKey );  //change value
```
{% endbox %}
 
#### 1.1.1.3 configurable 

是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。

这个属性起到两个作用：

1. 目标属性是否可以使用delete删除
2. 目标属性是否可以再次设置特性


{% box child:codeblock color:purple %}
```js
//-----------------测试目标属性是否能被删除------------------------
let obj = {}
//第一种情况：configurable设置为false，不能被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:false
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //hello
//第二种情况：configurable设置为true，可以被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:true
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //undefined

//-----------------测试是否可以再次修改特性------------------------
let obj = {}
//第一种情况：configurable设置为false，不能再次修改特性。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:false
});
//重新修改特性
//报错：Uncaught TypeError: Cannot redefine property: newKey
// 因为 writable和 configurable都为 false 即无法重新配置
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true,
    enumerable:true,
    configurable:true
});


//第二种情况：configurable设置为true，可以再次修改特性。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:true
});
//重新修改特性
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true,
    enumerable:true,
    configurable:true
});
console.log( obj.newKey ); //hello
```
{% endbox %}

#### 1.1.1.4 enumerable
 
此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：enumerable设置为false，不能被枚举。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false
});

//枚举对象的属性
for( var attr in obj ){
    console.log( attr );  // 打印为空
}
//第二种情况：enumerable设置为true，可以被枚举。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:true
});

//枚举对象的属性
for( var attr in obj ){
    console.log( attr );  //newKey
}
```
{% endbox %}

> {% mark 一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false color:orange %}

### 1.1.2 存取器描述

当使用存取器描述属性的特性的时候，允许设置以下特性属性：

{% box child:codeblock color:purple %}
```js
let obj = {};
Object.defineProperty(obj,"newKey",{
    get:function (){} | undefined,
    set:function (value){} | undefined
    configurable: true | false
    enumerable: true | false
});
```
{% endbox %}

> 当使用了getter或setter方法，不允许使用writable和value这两个属性


#### 1.1.2.1 getter/setter

当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。

* getter 是一种获得属性值的方法
* setter是一种设置属性值的方法。

在特性中使用get/set属性来定义对应的方法。

{% box child:codeblock color:purple %}
```js
let obj = {};
let initValue = 'hello';
Object.defineProperty(obj,"newKey",{
    get:function (){
        //当获取值的时候触发的函数
        return initValue;    
    },
    set:function (value){
        //当设置值的时候触发的函数,设置的新值通过参数value拿到
        initValue = value;
    }
});
//获取值
console.log( obj.newKey );  //hello

//设置值
obj.newKey = 'change value';

console.log( obj.newKey ); //change value
```
{% endbox %}

> 注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined

> configurable和enumerable同上面的用法。

> 属性描述符和数据描述符都是相互独立的，如果你在第三个参数中既写了 value/writable，又写了 get/set 则会报错。

{% image /assets/topic/vue2/observe/2.png %}

### 1.1.3 兼容性

{% image /assets/topic/vue2/observe/1.png %}

兼容性如上图所示，需要注意的是：在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。

### 1.1.4 困惑的问题

{% image /assets/topic/vue2/observe/3.png %}

如上，在使用 get 方法后，无法直接看到对象上的属性，需要点击才可以。

## 1.2 Proxy 

### 1.2.1 defineProperty的缺点

我们知道Vue2中的数据响应式处理使用的是 Object.defineProperty，而 Vue3中实现数据响应使用的是 Proxy。

Object.defineProperty虽然可以实现功能，但是无法对数组或者深层次对象进行监听处理。

#### 1.2.1.1 数组

{% box child:codeblock color:purple %}
```js
let arr = [1,2,3,4,5];
arr.forEach((item,index)=>{
    Object.defineProperty(arr,index,{
        get() {
            console.log('数组被getter拦截')
            return item
        },
        set(value) {
            console.log('数组被setter拦截')
            return item = value
        }
    })
})
arr[1] = 11;
console.log(arr[1]);
// 结果
数组被setter拦截
数组被getter拦截
11
```
{% endbox %}

很显然，{% mark 已知长度的数组可以通过索引进行属性的设置与访问 color:orange %}。

然而，数组的添加操作却无法被直接拦截。

这很容易理解：无论是通过 arr.push() 方法还是直接赋值如 arr[10] = 10 来添加元素，新添加的索引并未被包含在预设的数据拦截机制中，因此无法实现拦截处理。

这是使用 Object.defineProperty 进行数据代理的一个局限性。

Vue 在其响应式系统中对数组方法进行了重写，从而间接地解决了此问题。

#### 1.2.1.2 深层次对象 

{% box child:codeblock color:purple %}
```js
let obj={
    level1:{
        level2:"第二层"
    }
}
// 保存 level1 的原始值 避免循环引用的错误
let originalLevel1 = obj.level1;
Object.defineProperty(obj,'level1',{
    get(){
        console.log("对象被getter拦截")
        return originalLevel1
    },
    set(value){
        console.log("对象被setter拦截")
        originalLevel1 = value;
    }
})
// 结果
对象被setter拦截
对象被getter拦截
obj.level1 = {level3:"第三层"}
console.log(obj.level1)// {level3:"第三层"}
```
{% endbox %}

可以看到更新设置的那一层是没问题的。

但是如果我们更新更深层次的对象，就无法监听到。

{% box child:codeblock color:purple %}
```js
let obj={
    level1:{
        level2:"第二层"
    }
}
// 保存 level1 的原始值 避免循环引用的错误
let originalLevel1 = obj.level1;
Object.defineProperty(obj,'level1',{
    get(){
        console.log("对象被getter拦截")
        return originalLevel1
    },
    set(value){
        console.log("对象被setter拦截")
        originalLevel1 = value;
    }
}) 
//结果
对象被getter拦截
obj.level1.level2 = '第二层-复制'
```
{% endbox %}

可以看出来并没有执行 set 方法，如果想要深层次的属性也被监听到的话，需要递归地给对象中的每一个属性添加属性描述。


{% box child:codeblock color:purple %}
```js
function walk(obj){
    // 如果不是对象 无需处理
    if(!(obj instanceof Object))  return obj
    for(let k in obj){
        let val = obj[k];
        walk(val);
        Object.defineProperty(obj,k,{
            enumerable:true,
            configurable:true,
            get(){
                console.log(`访问obj.${k}属性触发`)
                return val
            },
            set(newValue) {
                console.log(`修改obj.${k}属性触发` , newValue)
                if (val === newValue) return;
                val = newValue
                walk(newValue)
            } 
        })
    }
    return obj;
}
// 递归监听所有层级对象
let obj = {a:{b:{c:'d'}}}
walk(obj)
obj.a
obj.a.b
obj.a.b.c
```
{% endbox %}

### 1.2.2 

