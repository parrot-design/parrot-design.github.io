---
title: 🔥Vue2数据响应式原理
permalink: posts/vue2-observe.html
date: 2024-11-18 14:39
topic: vue2
banner: /assets/topic/vue2/banner/init-render.jpg
---  
 
&nbsp;

{% button 返回 javascript:window.history.back() icon:solar:back-white color:orange size:xs %}

{% quot 专栏第八篇-数据响应式原理 %}

上一篇中我们将初次渲染页面的流程大致的过了一遍。

当然，还有很多细节没有描述。

Vue中最核心的部分的就是数据驱动视图，所谓响应式就是当数据发生改变时，界面会同步更新。

# 一、数据代理的基础

数据代理，有时也被称作数据劫持，是一种技术手段，它能够截获对对象属性的访问和修改操作，并在这些操作发生时执行额外的逻辑或修改返回的结果。

在 Vue.js 中，响应式系统的核心机制正是基于数据代理。

通过代理，Vue 能够{% u 在数据被访问时收集依赖，在数据被修改时更新这些依赖 %}，这是响应式系统运作的基本理念。

而这一切都依赖于 Vue 对数据进行的拦截和代理操作。

尽管响应式特性本身并非本节的讨论重点，我们将探索数据代理在其他场景下的应用。

在深入分析之前，重要的是要理解实现数据代理的两种主要方法：{% u Object.defineProperty %}和 {% u Proxy %}。

这两种方法为我们提供了强大的支持，以实现对数据访问和修改行为的精细控制。 

## 1.1 Object.defineProperty

Vue是通过这个API对数据进行监听的。

> Object.defineProperty() 方法用于在一个对象上直接定义一个新属性，或者修改一个对象的现有属性，并返回该对象。

基本使用如下：

{% box child:codeblock color:purple %}
```js
Object.defineProperty(obj, prop, descriptor)
```
{% endbox %}

参数说明：

> obj：必需。目标对象
> props：必需。需定义或修改的属性的名字
> descriptor：必需。目标属性所拥有的特性

Object.defineProperty() 允许我们精确地添加或修改对象的属性。 

给对象的属性添加特性描述有两种形式：{% u 1.数据描述和2.存取描述 color:orange %}。

数据描述和存取描述所对应的属性是不同的。

### 1.1.1 数据描述

当修改或定义对象的某个属性的时候，给这个属性添加一些特性。

{% box child:codeblock color:purple %}
```js
let obj = {
    test:'hello world'
}
//对已有的属性添加特性描述
Object.defineProperty(obj,"test",{
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
});
//对新添加的属性的特性描述
Object.defineProperty(obj,"newKey",{
    configurable:true | false,
    enumerable:true | false,
    value:任意类型的值,
    writable:true | false
});
```
{% endbox %}

数据描述中有四个属性，都是可选的，来看一下每一个属性的作用。

#### 1.1.1.1 value 

属性对应的值，可以使用任意类型的值，默认为 undefined。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：不设置value属性
Object.defineProperty(obj,"newKey",{

});
console.log( obj.newKey );  //undefined
----------------------------------------
//第二种情况：设置value属性
Object.defineProperty(obj,"newKey",{
    value:"hello"
});
console.log( obj.newKey );  //hello
```
{% endbox %}


#### 1.1.1.2 writable 

属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：writable设置为false，不能重写。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false
});
//更改newKey的值
obj.newKey = "change value";
console.log( obj.newKey );  //hello
------------------------------
//第二种情况：设置value属性
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true
});
//更改newKey的值
obj.newKey = "change value";
console.log( obj.newKey );  //change value
```
{% endbox %}
 
#### 1.1.1.3 configurable 

是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。

这个属性起到两个作用：

1. 目标属性是否可以使用delete删除
2. 目标属性是否可以再次设置特性


{% box child:codeblock color:purple %}
```js
//-----------------测试目标属性是否能被删除------------------------
let obj = {}
//第一种情况：configurable设置为false，不能被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:false
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //hello
//第二种情况：configurable设置为true，可以被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:true
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //undefined

//-----------------测试是否可以再次修改特性------------------------
let obj = {}
//第一种情况：configurable设置为false，不能再次修改特性。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:false
});
//重新修改特性
//报错：Uncaught TypeError: Cannot redefine property: newKey
// 因为 writable和 configurable都为 false 即无法重新配置
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true,
    enumerable:true,
    configurable:true
});


//第二种情况：configurable设置为true，可以再次修改特性。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:true
});
//重新修改特性
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:true,
    enumerable:true,
    configurable:true
});
console.log( obj.newKey ); //hello
```
{% endbox %}

#### 1.1.1.4 enumerable
 
此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。

{% box child:codeblock color:purple %}
```js
let obj = {}
//第一种情况：enumerable设置为false，不能被枚举。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false
});

//枚举对象的属性
for( var attr in obj ){
    console.log( attr );  // 打印为空
}
//第二种情况：enumerable设置为true，可以被枚举。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:true
});

//枚举对象的属性
for( var attr in obj ){
    console.log( attr );  //newKey
}
```
{% endbox %}

> {% u 一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false color:orange %}

### 1.1.2 存取器描述

存取器描述符也有四个属性：get、set、enumerable、configure。

{% box child:codeblock color:purple %}
```js
let obj = {};
Object.defineProperty(obj,"newKey",{
    get:function (){} | undefined,
    set:function (value){} | undefined
    configurable: true | false
    enumerable: true | false
});
```
{% endbox %}

> 当使用了getter或setter方法，不允许使用writable和value这两个属性


#### 1.1.2.1 getter/setter

当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。

* getter 是一种获得属性值的方法
* setter是一种设置属性值的方法。

在特性中使用get/set属性来定义对应的方法。

{% box child:codeblock color:purple %}
```js
let obj = {};
let initValue = 'hello';
Object.defineProperty(obj,"newKey",{
    get:function (){
        //当获取值的时候触发的函数
        return initValue;    
    },
    set:function (value){
        //当设置值的时候触发的函数,设置的新值通过参数value拿到
        initValue = value;
    }
});
//获取值
console.log( obj.newKey );  //hello

//设置值
obj.newKey = 'change value';

console.log( obj.newKey ); //change value
```
{% endbox %}

> 注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined

> configurable和enumerable同上面的用法。

> 属性描述符和数据描述符都是相互独立的，如果你在第三个参数中既写了 value/writable，又写了 get/set 则会报错。

{% image /assets/topic/vue2/observe/2.png %}

### 1.1.3 兼容性

{% image /assets/topic/vue2/observe/1.png %}

兼容性如上图所示，需要注意的是：在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。

### 1.1.4 困惑的问题

{% image /assets/topic/vue2/observe/3.png %}

如上，在使用 get 方法后，无法直接看到对象上的属性，需要点击才可以。

## 1.2 Proxy 

### 1.2.1 defineProperty的缺点

我们知道Vue2中的数据响应式处理使用的是 Object.defineProperty，而 Vue3中实现数据响应使用的是 Proxy。

Object.defineProperty虽然可以实现功能，但是无法对数组或者深层次对象进行监听处理。

#### 1.2.1.1 数组

{% box child:codeblock color:purple %}
```js
let arr = [1,2,3,4,5];
arr.forEach((item,index)=>{
    Object.defineProperty(arr,index,{
        get() {
            console.log('数组被getter拦截')
            return item
        },
        set(value) {
            console.log('数组被setter拦截')
            return item = value
        }
    })
})
arr[1] = 11;
console.log(arr[1]);
arr.push(6)
arr[10] = 10
// 结果
数组被setter拦截
数组被getter拦截
11
```
{% endbox %}

很显然，{% u 已知长度的数组可以通过索引进行属性的设置与访问 color:orange %}。

然而，数组的添加操作却无法被直接拦截。

这很容易理解：无论是通过 arr.push() 方法还是直接赋值如 arr[10] = 10 来添加元素，新添加的索引并未被包含在预设的数据拦截机制中，因此无法实现拦截处理。

这是使用 Object.defineProperty 进行数据代理的一个局限性。

Vue 在其响应式系统中对数组方法进行了重写，从而间接地解决了此问题。

#### 1.2.1.2 深层次对象 

{% box child:codeblock color:purple %}
```js
let obj={
    level1:{
        level2:"第二层"
    }
}
// 保存 level1 的原始值 避免循环引用的错误
let originalLevel1 = obj.level1;
Object.defineProperty(obj,'level1',{
    get(){
        console.log("对象被getter拦截")
        return originalLevel1
    },
    set(value){
        console.log("对象被setter拦截")
        originalLevel1 = value;
    }
})
// 结果
对象被setter拦截
对象被getter拦截
obj.level1 = {level3:"第三层"}
console.log(obj.level1)// {level3:"第三层"}
```
{% endbox %}

可以看到更新设置的那一层是没问题的。

但是如果我们更新更深层次的对象，就无法监听到。

{% box child:codeblock color:purple %}
```js
let obj={
    level1:{
        level2:"第二层"
    }
}
// 保存 level1 的原始值 避免循环引用的错误
let originalLevel1 = obj.level1;
Object.defineProperty(obj,'level1',{
    get(){
        console.log("对象被getter拦截")
        return originalLevel1
    },
    set(value){
        console.log("对象被setter拦截")
        originalLevel1 = value;
    }
}) 
obj.level1.level2 = '第二层-复制'
//结果
对象被getter拦截
```
{% endbox %}

可以看出来并没有执行 set 方法，如果想要深层次的属性也被监听到的话，需要递归地给对象中的每一个属性添加属性描述。


{% box child:codeblock color:purple %}
```js
function walk(obj){
    // 如果不是对象 无需处理
    if(!(obj instanceof Object))  return obj
    for(let k in obj){
        let val = obj[k];
        walk(val);
        Object.defineProperty(obj,k,{
            enumerable:true,
            configurable:true,
            get(){
                console.log(`访问obj.${k}属性触发`)
                return val
            },
            set(newValue) {
                console.log(`修改obj.${k}属性触发` , newValue)
                if (val === newValue) return;
                val = newValue
                walk(newValue)
            } 
        })
    }
    return obj;
}
// 递归监听所有层级对象
let obj = {a:{b:{c:'d'}}}
walk(obj)
obj.a
obj.a.b
obj.a.b.c
```
{% endbox %}

### 1.2.2 Proxy的介绍

Proxy就可以解决Object.defineProperty的这些问题。

代理是目标对象的抽象。

他可以用作目标对象的替身，但又完全独立于目标对象。

目标对象既可以直接被操作，也可以通过代理来操作。但是直接操作会绕过代理赋予的行为。

#### 1.2.2.1 空代理

最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。

代理对象上执行的所有操作都会无障碍的传播到目标对象。

{% box child:codeblock color:purple %}
```js
const target = {
    id: 'target'
}

const handler = {}

const proxy = new Proxy(target, handler)
// id属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target

// 给目标属性赋值会反映在两个对象上
// 因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo 

// 给代理属性赋值会反映在两个对象上
// 因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar

// Proxy.prototype 是 undefined
// 因此不能使用 instanceof 操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype

// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```
{% endbox %}

#### 1.2.2.2 定义捕获器

当然，正常使用不会给一个空代理，肯定是要通过代理对访问和修改进行捕获。

本节暂且介绍几个常用的捕获器。覆盖Vue2中使用的所有捕获器。

#### 1.2.2.2.1 get 捕获器

get捕获器会在获取属性值的操作中被调用。

{% box child:codeblock color:purple %}
```js 
const target = {
    foo: 'bar'
}; 

const handler = {
    // 捕获器在处理程序对象中以方法名为键
    get(){
        return 'handler override';
    }
}

const proxy = new Proxy(target, handler)

// 只有在代理对象上执行这些操作才会触发捕获器 在目标对象上执行这些操作仍然会产生正常的行为
console.log(target.foo) // bar
console.log(proxy.foo) // handler override
```
{% endbox %}

1. 返回值

返回值无限制。

2. 拦截的操作

* proxy.property
* proxy[property]
* Object.create(proxy)[property]
* Reflect.get(proxy, property, receiver)

3. 捕获器处理程序参数

* target: 目标对象
* property: 引用目标对象上的字符串键属性
* receiver: 代理对象或继承代理对象的对象  

#### 1.2.2.2.2 set捕获器

set()捕获器会在设置属性值的操作中被调用。

{% box child:codeblock color:purple %}
```js 
const myTarget = {};
const proxy = new Proxy(myTarget, {
 set(target, property, value, receiver) {
    console.log('触发了set');
    return Reflect.set(...arguments)
 }
});
proxy.foo = 'bar';
// 触发了set
```
{% endbox %}

1. 返回值

返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。

2. 拦截的操作

* proxy.property = value
* proxy.[property]  = value
* Object.create(proxy)[property] = value
* Reflect.set(proxy, property, value, receiver)

3. 捕获器处理程序参数

* target: 目标对象
* property: 引用目标对象上的字符串键属性
* value：要赋给属性的值。
* receiver: 接收最初赋值的对象  

#### 1.2.2.2.3 has捕获器

has()捕获器会在 in 操作符中被调用。

{% box child:codeblock color:purple %}
```js 
const myTarget = {};
const proxy = new Proxy(myTarget, {
    has(target, property) {
        console.log('触发了has函数');
        return Reflect.has(...arguments)
    }
});
'foo' in proxy;
// 触发了has函数
```
{% endbox %}

1. 返回值

has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。

2. 拦截的操作

* property in proxy
* property in Object.create(proxy)
* with(proxy) {(property);}
* Reflect.has(proxy, property)

3. 捕获器处理程序参数

* target: 目标对象
* property: 引用目标对象上的字符串键属性 

### 1.2.3 试试深层次对象和数组

上面我们说到Object.defineProperty对于数组格式和深层次对象处理不了。

那我们来试试 Proxy是否可以处理。

#### 1.2.3.1 处理数组

{% box child:codeblock color:purple %}
```js
let target = [1,2,3,4] 

let proxy = new Proxy(target,{
    get(){
        console.log("触发了获取数组")
        return Reflect.get(...arguments)
    },
    set(){ 
        console.log("触发了设置数组")
        return Reflect.set(...arguments) 
    }
}) 

proxy1.push(5);
console.log(proxy1[4]);
```
{% endbox %}

{% image /assets/topic/vue2/observe/4.png %}

可以看到打印了多次。

但是这里有点令我困惑的是{% wavy 为什么会打印这么多次? %}。

#### 1.2.3.2 处理深层次对象

{% box child:codeblock color:purple %}
```js 
let target = {a:{b:{c:'d'}}}

let proxy = new Proxy(target,{
    get(){
        console.log("触发了获取对象")
        return Reflect.get(...arguments)
    },
    set(){ 
        console.log("触发了设置对象")
        return Reflect.set(...arguments) 
    }
}) 

proxy.a.b.c
proxy.a.b.c = 'e'
```
{% endbox %}

# 二、initProxy

虽然Vue2中的数据劫持并没有使用 Proxy，但是却在检测 data 时使用了Proxy。

还记得我们在前面章节[专栏第四篇-初始化干了什么事](/posts/vue2-init.html)中介绍了Vue实例化的时候会调用 initProxy，但是当时我们并没有对这个方法进行深度剖析，因为这个方法主要是使用 Proxy 来进行数据代理。

但是我们现在已经学习了 Proxy，所以我们这几来详细看下这块的逻辑。

{% box child:codeblock color:purple %}
```js 
 Vue.prototype._init = function (options) {
    if (__DEV__) {
        initProxy(vm)
    } else {
        vm._renderProxy = vm
    }
 }
```
{% endbox %}

在开发环境下，调用了 initProxy。

而在生产环境下并没有调用，而是将实例本身赋值到_renderProxy属性中。

一般仅存在于开发环境中的逻辑都是一些报错提示信息，所以我们盲猜initProxy也是添加了开发时报错的提示信息。

{% box child:codeblock color:purple %}
```js  
const hasHandler = {
    has(target, key) {
      const has = key in target
      const isAllowed =
        allowedGlobals(key) ||
        (typeof key === 'string' &&
          key.charAt(0) === '_' &&
          !(key in target.$data))
      if (!has && !isAllowed) {
        if (key in target.$data) warnReservedPrefix(target, key)
        else warnNonPresent(target, key)
      }
      return has || !isAllowed
    }
}

const getHandler = {
    get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) warnReservedPrefix(target, key)
        else warnNonPresent(target, key)
      }
      return target[key]
    }
}

initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      const options = vm.$options
      const handlers =
        options.render && options.render._withStripped ? getHandler : hasHandler
      vm._renderProxy = new Proxy(vm, handlers)
    } else {
      vm._renderProxy = vm
    }
  }
}
```
{% endbox %}

## 2.1 hasProxy

首先判断当前宿主环境中是否存在Proxy，通过Proxy是否定义和是原生属性来判断。

{% box child:codeblock color:purple %}
```js  
export function isNative(Ctor: any): boolean {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy)
```
{% endbox %}

## 2.2 _renderProxy

在开发环境下给 vm 设置代理后，将_renderProxy设置为代理对象。代理目标为 vue实例 vm。这意味着当访问 vm时，会触发代理捕获器。

在生产环境下直接将_renderProxy设置为实例 vm。

所以可以看出来不论是在开发环境或者生产环境如何都是给 vm._renderProxy设置值。

那么这里的_renderProxy是在何时使用的呢？

答案是在执行_render方法生成 vnode的时候，将 vm._renderProxy 当做第一个参数传入render方法中。

{% box child:codeblock color:purple %}
```js  
vnode = render.call(vm._renderProxy, vm.$createElement)
```
{% endbox %}

比如我们在.vue文件的模版中编写一段代码：

{% box child:codeblock color:purple %}
```html  
<div>{{ msg }}</div>
```
{% endbox %}

上面这段代码会被转化成一个render函数。

{% box child:codeblock color:purple %}
```js
render = function(){
    // 获取 this
    const _vm = this;
    // _vm._self 是 vue 实例
    // _c是创建 vnode的方法
    const _c = _vm._self._c
    // _s是转成字符串的方法
    const _s = _vm._self._s
    return _c('div',_s(_vm.msg))
}
```
{% endbox %}

可以看出来 render函数的 this指向的就是vm._renderProxy，也就是 vue实例。

然后通过 {% u vm.xxx %} 访问实例上的属性时就可以触发代理上的定义的捕获器逻辑。

## 2.3 模板渲染的几种情况

在我们了解捕获器中的详细逻辑前，我们需要了解编写Vue渲染中的三种情况。

知道对应的代码处理的是哪些场景有助于我们更好的了解源码。

### 2.3.1 用户自定义 template 模板

{% box child:codeblock color:purple %}
```js
new Vue({
    template:`<div>{{ msg }}</div>`,
    data(){
        return {
            msg:'Hello World'
        }
    }
}).$mount("#app");
```
{% endbox %}

对template选项进行模版编译是发生在实例的挂载阶段。

所以在初始化时，选项中只有 template标签。

经过选项合并后，vm.$options上只有 template选项并没有 render方法。

{% wavy 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是hasHandler方法。%}

hasHandler方法中使用的是has捕获器，has捕获器用于处理属性的存在性检查。

vue在对template选项进行模板编译时，会将其转化为 render函数，且会被 with包裹。

{% image /assets/topic/vue2/observe/6.png %}

而前面我们说过has捕获器可以拦截 with语句下的作用。在执行 with语句的过程中，该作用域下的变量都会触发 has钩子。这也是模版渲染时之所以会触发代理拦截的原因。

### 2.3.2 使用.vue文件来编写页面

这也是我们编写 vue项目中最常用的写法。

{% box child:codeblock color:purple %}
```js
// Test.vue
<template>
  <div>
    {{ msg }}
  </div> 
</template>

<script> 

export default {
  data(){
    return {
      msg: "Hello World"
    }
  }
};
</script>
```
{% endbox %}

.vue文件在webpack预编译阶段会被 vue-loader 解析成一个对象，其中模板部分会被解析成render函数。

并且在会在render方法中挂载_withStripped为true。

所以这个变量标识着当前的 render函数是使用.vue文件编写编译而来的。

{% wavy 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是getHandler方法。%}

getHandler方法中使用的是get捕获器，get捕获器用于处理对 Vue 实例属性的读取操作。

webpack + vue-loader对.vue文件进行编译时，会转化成下面这种形式。

{% image /assets/topic/vue2/observe/7.png %}

可以看到直接使用 vm.xxx 访问的属性。所以可以使用 get捕获器进行捕获。

### 2.3.3 用户自定义 render方法来编写页面

{% box child:codeblock color:purple %}
```js
// main.js
import Fun from "./Fun.js"; 
 
new Vue(Fun).$mount("#app");

// fun.js
let Component = {
  render:function(h){
    return h('div',this.msg)
  },
  data(){
    return {
      msg:'Hello World'
    }
  }
}

export default Component;
```
{% endbox %}

虽然这种情况在也存在 render方法，但是并没有 _withStripped 属性

{% wavy 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是hasHandler方法。%}

但是自定义 render的情况并没有使用 in或者 with的情况。

所以用户自定义的方法不会有报错提示。

## 2.4 捕获器里面的具体逻辑

前面我们说到了三种情况都有对应的捕获方法。

那么这个捕获方法内部究竟做了些什么操作呢？

主要是在开发者开发时对属性和方法的定义做提示。

1. 当开发者在渲染内容中使用了_作为变量名的前缀时，提示不可以使用这种命名方式。因为这种方式可能会与内部的变量存在冲突。
2. 当开发者在渲染内容中使用了未定义的变量时，提示该变量并没有在 vue实例上找到。

而前面我们说到了用户自定义的方法不会有报错提示。

我们可以实验一下：

{% box child:codeblock color:purple %}
```js
// main.js
import Fun from "./Fun.js"; 
 
new Vue(Fun).$mount("#app");

// fun.js
let Component = {
  render:function(h){
    // 使用了未定义的变量
    return h('div',this.msg1)
  },
  data(){
    return {
      msg:'Hello World'
    }
  }
}

export default Component;
```
{% endbox %}

我们在render方法中使用了一个未使用的变量 msg1。

然后打开控制台并没有报错提示。

因为此时代理使用的是has捕获器，而我们既没有使用 with，也没使用 in。

那么有没有解决办法呢？

有，那就是在 render上挂载一个_withStripped变量，让他在 initProxy时注册 get捕获器。

{% box child:codeblock color:purple %}
```js
let Component = {
  render:function(h){
    return h('div',this.msg1)
  },
  data(){
    return {
      msg:'Hello World'
    }
  }
}
// 在 render方法中挂载_withStripped属性
Component.render._withStripped = true;
export default Component;
```
{% endbox %}

可以看到控制台出现了报错信息。

{% image /assets/topic/vue2/observe/8.png %}

# 三、实现简易版vue依赖收集

因为Vue中对数据响应式这块的代码比较多，涉及多个文件。

但是我们知道数据响应式的原理就是{% u 页面渲染时进行数据访问时收集依赖，在数据更新时更新对应依赖的渲染内容 %}

{% image /assets/topic/vue2/observe/10.jpg %}

{% box child:codeblock color:purple %}
```js
// =================== 新增点击事件更改===================
const btnElement = document.createElement('button');
document.body.appendChild(btnElement);
btnElement.innerHTML = '点击';
btnElement.onclick = function(){
    // 点击事件
    debugger;
}

// A页面
let PageA = {
    msg:'Hello World',
    render(){
        const appElement = document.getElementById('#app');
        appElement.innerHTML = this.msg;
    }
}

// 存储依赖的页面
let Dep = [];

Object.defineProperty(PageA,'msg',{
    get(){
        //访问msg变量时执行
        console.log("访问了 msg变量")
    },
    set(){
        //设置msg变量时执行
        console.log("设置了 msg变量")
    }
})

// 执行渲染函数
PageA.render();
```
{% endbox %}