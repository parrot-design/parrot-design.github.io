[{"title":"第一节：安装JavaSDK","path":"//posts/java-class1.html","content":"一、JDK8、JDK11、JDK17应该怎么选择要使用Java语言，那么JDK就必不可少。 安装JDK后，会在电脑中同时安装：java的运行环境jre 和 开发环境jdk。 截止到目前为止，我们的JDK存在了三个版本的长期支持版：JDK8、JDK11和JDK17。 基本上Java大部分的项目都是基于JDK8环境。 首先，回顾所有版本，JDK8刚出生时，他就冠名了一个相对完美的开发环境之称。因为相比以往的JDK7、JDK5这些，JDK8的生态很好，开发者使用起来也比之前的版本舒适，同时JDK8支持了几乎所有的开发功能需求，设计比较完善。 所以我们下载 JDK8 二、Mac下载jdk82.1 官网下载打开oracle 官网下载页面。 页面一直下拉，可以找到历史版本的下载路径。可以通过切换tab，选择适合自己电脑系统的安装包。 macbook下载jdk8时，推荐下载.dmg文件。 2.2 国内平台国内有很多提供镜像下载的平台。可以找到历史版本的jdk，下载速度快，免登录。 我实际使用过的是：http://www.codebaoku.com/jdk/jdk-oracle-jdk1-8.html 三、安装 jdk下载完 dmg文件以后，双击文件，然后会跳出来一个文件夹，里面有个 pkg包安装文件，双击进入安装引导界面。一直点“继续”按钮就可以傻瓜式安装 java了。 打开终端输入 java -version就可以查看 java是否安装成功。","tags":["blog"],"categories":["Java实战"]},{"title":"🔥Vue2异步渲染机制","path":"//posts/vue2-async.html","content":"&nbsp; 返回 专栏第九篇-异步渲染机制 一、异步渲染机制在上一节的内容中，我们知道在数据发生变化的时候，会重新更新依赖，最终会执行Watcher实例的update方法。 但是其实Vue中并不是在每次执行update方法时都会执行渲染，他会将多次变化做一次合并渲染。 1234567891011121314import Vue from &quot;vue&quot;;new Vue(&#123; template:`&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; msg:&quot;inited&quot; &#125; &#125;, mounted()&#123; this.msg = &#x27;第一次渲染&#x27;; this.msg = &#x27;第二次渲染&#x27;; &#125;&#125;).$mount(&quot;#app&quot;) 按照我们上节所学的知识：每一个data都被代理劫持，每次data修改后都会重新执行更新方法。 那么在 mounted方法中 data修改了 2 次，是不是应该渲染 2 次呢？ 但是从实际角度明显我们这里只需要渲染第二次的内容，也就是只渲染一次，而 Vue内部也是这么操作的。 由于Vue内部的异步渲染机制，实际上页面只会渲染一次，把第一次的赋值所带来的的响应与第二次的赋值所带来的的响应进行一次合并，将最终的val只做一次页面渲染，而且页面是在执行所有的同步代码之后才能得到渲染。 二、为什么需要异步渲染1234567891011121314151617181920let data = &#123;msg:&#x27;inited&#x27;&#125;let _msg = data.msgObject.defineProperty(data,&quot;msg&quot;,&#123; set(val)&#123; console.log(&quot;我被设置了&quot;) _msg = val &#125;, get()&#123; console.log(&quot;我被访问了&quot;) return _msg &#125;&#125;) data.msg = &#x27;第一次渲染&#x27;console.log(&quot;获取此时data.msg&quot;,data.msg)data.msg = &#x27;第二次渲染&#x27; // 执行结果// 我被设置了// 我被访问了// 获取此时data.msg 第一次渲染// 我被设置了 通过执行上面这段代码，我们可以知道代理是同步操作。 也就是说如果在 Vue中不进行异步处理的话，可能最终执行逻辑就是下图这样。 这样的话每次 data变化就会重新渲染一次，可能会导致浏览器的闪烁卡顿。 所以我们可以从用户体验和性能 2 个角度进行分析： 用户体验：从上述例子可以看出，实际上页面只需要展示最终的值变化。第一次的值变化只是一个过渡状态，如果将其渲染并显示给用户，可能会导致页面出现闪烁现象，从而影响用户体验。通过 Vue 的异步更新队列机制，可以有效避免这种情况的发生，确保用户看到的是稳定且最新的页面状态。 性能：在上述例子中，最终需要展示的数据实际上是第二次对 val 赋的值。如果第一次赋值也触发页面渲染，那么在最终结果渲染之前，页面会进行一次不必要的渲染。这无疑增加了性能的消耗。 三、Vue异步渲染原理数据每次变化时，将其引起页面变化的操作都会放到一个异步API的回调函数中。当同步代码执行完毕后，异步回调开始执行。此时 Vue 会将所有需要渲染的变化合并在一起，最终执行一次渲染操作。 四、queueWatcher每一次data变化都会执行Watcher实例上的 update方法。 12345678910update() &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 默认 lazy、sync都是 false。 所以默认每一次都会调用queueWatcher方法，那么这个 queueWatcher函数都做了什么操作呢？ 4.1 has对象123456789let has = &#123;&#125;;export function queueWatcher(watcher: Watcher) &#123; const id = watcher.id if (has[id] != null) &#123; return &#125; has[id] = true // 省略部分代码&#125; has 对象用于存储已经加入队列的 watcher 的 ID，以确保每个 watcher 只被加入队列一次。这是一种避免重复处理相同 watcher 的机制。 4.2 noRecurse选项123if (watcher === Dep.target &amp;&amp; watcher.noRecurse) &#123; return&#125; 如果当前的 watcher 就是全局的 Dep.target（即当前正在执行的 watcher），并且这个 watcher 设置了 noRecurse 标志（表示不希望递归触发），那么就直接返回，不执行任何操作。 4.3 queue123456789const queue: Array&lt;Watcher&gt; = []export function queueWatcher(watcher: Watcher) &#123; // 省略部分代码 if (!flushing) &#123; queue.push(watcher) &#125; else &#123; queue.splice(i + 1, 0, watcher) &#125;&#125; queue是一个数组，用于存储需要执行更新渲染的 watcher实例。 当数据变化时，相关的 watcher实例会被添加到这个数组中，等待执行。 4.4 flushing状态12345678910111213141516171819202122232425let flushing = false;let index = 0;export function queueWatcher(watcher: Watcher) &#123; // 省略部分代码 if (!flushing) &#123; queue.push(watcher) &#125; else &#123; let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; nextTick(flushSchedulerQueue);&#125;function flushSchedulerQueue()&#123; flushing = true; // 省略代码 // 执行完更新操作后重置内部状态 resetSchedulerState();&#125;function resetSchedulerState()&#123; flushing = false;&#125; 如上述代码所示：flushing是一个内部状态，表示当前是否正在执行 watcher 的队列。默认为 false。 当第一次执行 queueWatch时，flushing为 false，表示当前没有执行 watcher队列，这个时候处理比较简单，将 watcher 添加到队列的末尾，等待后续的执行。 此时调用nextTick(flushSchedulerQueue)方法。 在同步任务执行以后，执行异步时在flushSchedulerQueue方法中将 flushing置为 true，表示当前正在执行 watcher队列。 如果在执行flushSchedulerQueue方法时再次调用了 queueWatcher方法，找到第一个 id小于或等于 watch.id，然后插入他的后面，保证了 watcher按照它们被创建的顺序执行，即使在执行过程中有 watcher加入。 4.5 waiting状态1234567891011121314let waiting = false;if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue)&#125; function resetSchedulerState()&#123; // 将 waiting重置为 false waiting = false; &#125;function flushSchedulerQueue()&#123; resetSchedulerState()&#125; queueWatcher方法最主要的功能就是执行 nextTick(flushSchedulerQueue)方法，从而达到异步批量更新的目的。 而 waiting决定了是否应该执行flushSchedulerQueue方法。 在第一次执行 queueWatcher(this)时，会调用nextTick(flushSchedulerQueue)方法。 并且将 waiting设置为 true。 然后立即执行异步更新操作，所以 waiting表示目前存在异步更新操作正在等待执行。 然后在一次事件循环内再次调用 queueWatcher方法，此时已经有异步更新操作等待执行。 所以不再调用异步更新操作，这意味着在一次事件循环内，该方法只会被执行一次。 该变量在异步更新后会被重置为 false。 4.6 flushSchedulerQueue专门用于执行处理queue队列。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function flushSchedulerQueue() &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&#x27;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&#x27;s watcher run, // its watchers can be skipped. queue.sort(sortCompareFn) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (__DEV__ &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( &#x27;You may have an infinite update loop &#x27; + (watcher.user ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;` : `in a component render function.`), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) cleanupDeps() // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit(&#x27;flush&#x27;) &#125;&#125; 4.6.1 使用sortCompareFn进行排序123456789101112131415161718192021const sortCompareFn = (a: Watcher, b: Watcher): number =&gt; &#123; if (a.post) &#123; if (!b.post) return 1 &#125; else if (b.post) &#123; return -1 &#125; return a.id - b.id&#125;let queue = []function flushSchedulerQueue() &#123; // 省略部分代码 // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&#x27;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&#x27;s watcher run, // its watchers can be skipped. queue.sort(sortCompareFn) &#125; 因为在一次事件循环内多次触发 queueWatcher 函数会给队列添加 watcher。 此时 watcher的执行顺序需要重新整理，sortCompareFn用于给 watcher排序。 post表示这是一个在 DOM更新后执行的 watcher 排序目的主要是为了确保下面三种情况的顺序： 父子组件更新顺序：组件的父 watcher 应该在子 watcher 之前执行。这是因为父组件通常在子组件之前创建，因此其 watcher 也应该先执行。 用户 watcher 与渲染 watcher 的顺序：用户定义的 watcher（通常在组件的 watch 选项中定义）应该在组件的渲染 watcher 之前执行。这是因为用户 watcher 通常在渲染 watcher 之前创建。 处理组件销毁：如果一个组件在父组件的 watcher 执行过程中被销毁，其 watcher 可以被跳过，以避免对已销毁组件的无效操作。 4.6.2 执行watcher实例的更新1234567891011121314151617181920212223for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (__DEV__ &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( &#x27;You may have an infinite update loop &#x27; + (watcher.user ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;` : `in a component render function.`), watcher.vm ) break &#125; &#125; &#125; 在将 watcher顺序排列好后，立即执行遍历队列中的每个 watcher并执行他们。 同时在开发模式下，检查是否有无限循环更新的情况。 如果 has[id] 仍然不为 null（这意味着在当前 watcher 执行后，又有新的更新请求），则增加 circular[id] 的计数，用于跟踪同一个 watcher 被重新触发的次数。 如果 circular[id] 的次数超过了 MAX_UPDATE_COUNT（一个设定的最大更新次数），则发出警告，提示可能存在无限更新循环，并中断当前的执行循环。 4.6.3 调用keep-alive组件的activated钩子1234567891011121314151617181920const activatedChildren: Array&lt;Component&gt; = [] function resetSchedulerState() &#123; index = queue.length = activatedChildren.length = 0 has = &#123;&#125; if (__DEV__) &#123; circular = &#123;&#125; &#125; waiting = flushing = false&#125;const activatedQueue = activatedChildren.slice()callActivatedHooks(activatedQueue)function callActivatedHooks(queue) &#123; for (let i = 0; i &lt; queue.length; i++) &#123; queue[i]._inactive = true activateChildComponent(queue[i], true /* true */) &#125;&#125; 当一个组件被插入到 DOM 中时，它的 activated 钩子会被调用。 这个函数处理的是 activated 钩子的调用逻辑，特别是在处理动态组件（ 标签）或 keep-alive 缓存的组件时。 4.6.4 调用普通组件的 updated钩子1234567891011121314const updatedQueue = queue.slice()callUpdatedHooks(updatedQueue)function callUpdatedHooks(queue: Watcher[]) &#123; let i = queue.length while (i--) &#123; const watcher = queue[i] const vm = watcher.vm if (vm &amp;&amp; vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;updated&#x27;) &#125; &#125;&#125; 4.6.5 调用resetSchedulerState重置状态12345678function resetSchedulerState() &#123; index = queue.length = activatedChildren.length = 0 has = &#123;&#125; if (__DEV__) &#123; circular = &#123;&#125; &#125; waiting = flushing = false&#125; 在执行完 watcher实例的渲染方法后，需要将状态重置。 4.6.6 清除无效的订阅12345678910cleanupDeps()export const cleanupDeps = () =&gt; &#123; for (let i = 0; i &lt; pendingCleanupDeps.length; i++) &#123; const dep = pendingCleanupDeps[i] dep.subs = dep.subs.filter(s =&gt; s) dep._pending = false &#125; pendingCleanupDeps.length = 0&#125; 这个函数的主要作用是移除那些已经无效的订阅（subs），这些订阅可能来自于已经被销毁的 Watcher 实例。以下是对 cleanupDeps 函数的详细解释： 五、异步函数 nextTick我们知道Vue使用异步渲染的方式来提高效率。 而 Vue中就是使用 nextTick来完成异步这个操作。 123456789101112131415161718192021222324252627const callbacks = []let pending = falseexport function nextTick(cb, ctx) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e: any) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 可以看出来 nextTick 就是将传入的回调函数放入 callbacks这个数组中，然后再使用异步的 API进行调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455let timerFunc// The nextTick behavior leverages the microtask queue, which can be accessed// via either native Promise.then or MutationObserver.// MutationObserver has wider support, however it is seriously bugged in// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It// completely stops working after triggering a few times... so, if native// Promise is available, we will use it:/* istanbul ignore next, $flow-disable-line */if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if ( !isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Technically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; timerFunc 用于将回调函数排队到浏览器的微任务（microtask）队列中，以确保在当前脚本执行完毕后，下一次事件循环开始前执行这些回调。 优先使用 Promise.then 如果环境不支持 Promise,则尝试使用 MutationObserver 如果上面 2 种都不支持，则尝试使用 setImmediate 如果上面 3 种都不支持，则最终使用 setTimeout 六、总结本文介绍了Vue的异步渲染机制以及异步渲染机制带来的好处。"},{"title":"🔥Vue2双端对比","path":"//posts/vue2-diff.html","content":"&nbsp; 返回 专栏第十篇-双端对比算法 上节我们说到Vue是异步批量更新的，本质上就是调用 watcher的run方法，然后调用实例上的_update方法进行重新渲染。 一、diff算法1.1 前世今生前世：diff 算法最初是由计算机科学家迈克尔·菲舍尔和丹尼尔·希尔伯特所发明的一种 文本比较算法。 今生：伴随着前端开发的蓬勃兴起，diff 算法被引入到虚拟 DOM 当中，成为了一项用于高效更新用户界面的核心技术。其旨在高效地辨别出从一种状态转变为另一种状态所需要的最小变更集合。由于在浏览器中对 DOM 进行操作的性能消耗颇为昂贵，例如节点的添加、删除等等，所以 diff 算法能够 尽可能地降低 DOM 的操作数量，避免频繁的 DOM 操作所带来的性能耗费，进而减轻浏览器的性能负担。 如上图所示。如果需要将上图中左边的DOM树更新为右边的DOM树，在不采用虚拟DOM的情况下（即无法复用DOM节点），可能需要进行6次DOM操作： 卸载所有旧子节点，需要 3 次 DOM 删除操作。 挂载所有新子节点，需要 3 次 DOM 添加操作。 但是如果采用diff算法复用DOM节点的策略进行的话，实际上只需要进行1次DOM操作： 移动旧的一组子节点的B节点到C节点的后面。 可以看出来通过复用策略可以有效的避免频繁操作DOM带来的性能开销。 1.2 diff算法的复杂度对两棵树进行 diff 操作，其复杂度为 O(n^3) 。 这是因为每个节点都需要和另一棵树的所有节点逐一进行对比，这便形成了 n 的复杂度。 倘若找到有变化的节点，执行插入、删除、修改操作同样具有 n 的复杂度。 所有的节点均是如此，再乘以 n ，因此得出的复杂度是 O(n * n * n) 。 如此的复杂度对于前端框架而言是无法接受的，这意味着若存在 1000 个节点，渲染一次就需要处理 1000 * 1000 * 1000，总计 10 亿次。 所以前端框架的 diff 约定了两种处理原则：1.只做同层的对比 2.type 变了就不再对比子节点。 因为 DOM 节点进行跨层级移动的情形相对较少，通常情况下都是同一层级的 DOM 的增删改操作。 像这样的话，只需遍历一次，对比一下 type 就可以了，其复杂度是 O(n) 。而且一旦 type 发生变化，就不再对比子节点，能够节省下大量节点的遍历工作。另外，由于在虚拟 DOM 中记录了关联的 DOM 节点，执行 DOM 的增删改操作时也无需遍历，其复杂度是 O(1) 。整体的 diff 算法复杂度即为 O(n) 。 1.3 diff算法的核心要素1.3.1 同层比较 如上图所示，算法会于两个虚拟 DOM 树的同一层级展开对比，而不会进行跨层级的对比。这代表着它首先会核查每个父节点是否一致，如果一致，接下来才会递归进入子树进行比较。倘若不同，则直接依据具体情况进行更新。 由之前的章节能够了解到：双端 diff 算法被设计为只有同层节点进行比较，其原因主要有以下两点： 降低 diff 算法的复杂程度。 DOM 节点进行跨层级移动的情况相对较少，通常情况下都是同一层级的 DOM 的增删改操作。 1.3.2 相同节点判断策略 如上图所示。在 Vue 中，判断新旧节点是否为相同节点的逻辑为：当节点的标签（比如 p 节点） 以及节点的key相同时，即被视为同一个节点。之所以这样做，是因为一旦 type 或者 key 发生变化，就不再对比子节点，能够节省下大量节点的遍历工作，从而提升性能。 1.3.3 循环从两边向中间比较 这是一种优化策略，算法不是线性遍历每一个节点，而是从两端开始，向中间逐步靠拢，这样可以在某些情况下更早地发现差异并终止不必要的比较。 第一步：比较旧的一组子节点中的第一个子节点A与新的一组子节点中的第一个子节点C。 第二步：比较旧的一组子节点的最后一个子节点C与旧的一组子节点的最后一个子节点B。 第三步：比较旧的一组子节点的第一个子节点A与新的一组子节点中的最后一个子节点 B。 第四步：比较旧的一组子节点的最后一个子节点 C与新的一组子节点的第一个节点C。 1.3.4 节点复用在diff算法中，节点复用是一个非常重要的优化手段。通过复用旧节点，可以大大减少DOM操作，从而提升渲染效率。 Vue.js团队通过引入key的概念，实现了节点复用的功能。key是一个唯一的标识符，它可以帮助Vue.js区分不同的节点。当新旧节点的key相同时，Vue.js就会复用旧节点，而不是创建新节点。 在没有key的情况下，判断下面的p节点属于同一个节点，直接进行子节点的对比，子节点是文字，则直接更新文字。（这里因为没有key值无法进行复用，复用的话只需要移动A节点的位置即可）。 在存在key的情况下，使用双端 diff的四步对比进行。 第一步，在有key的情况下，判断不属于同个节点，跳过 第二步，在有key的情况下，判断不属于同个节点，跳过 第三步，在有key的情况下，判断属于同个节点，进行节点复用操作（具体操作后续会说） 二、虚拟 DOM和 diff算法的关联在专栏第六篇中，我们介绍了虚拟DOM。 我们知道虚拟DOM在 JS中就是一个普通的 JS对象，这个对象的结构是一种可以表示DOM的抽象层面的树形结构，它可以高效地更新到实际的DOM上。 在Vue中，每个组件都有一个对应的渲染函数，这个函数返回一个描述该组件视图的虚拟节点树。 在初次渲染时，会调用渲染函数生成一个虚拟节点树oldVNode。 当组件的状态发生变化时，渲染函数会被再次调用，产生一个新的虚拟节点树newVNode。 Vue的diff算法就是用来比较新旧虚拟节点树的差异，找出最小的DOM操作来更新实际的DOM。 所以 Vue的 diff只会发生在更新阶段。初次挂载直接创建并挂载节点。 1234567891011121314151617// 假设有一个简单的组件let component = &#123; data: &#x27;Hello, Vue!&#x27;, template: `&lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;`&#125;; // 首次渲染，生成虚拟DOMlet oldVnode = Vue.render(component); // 假设数据（data）更新，产生新的虚拟DOMlet newVnode = Vue.render(component); // Vue的diff算法比较新旧虚拟DOMlet patches = Vue.diff(oldVnode, newVnode); // 根据diff结果应用到实际DOMVue.patch(document.body, patches); 在这个例子中，Vue首次渲染组件时生成了一个虚拟DOM节点（oldVnode）。当组件的数据更新时，Vue再次渲染组件，生成了一个新的虚拟DOM节点（newVnode）。Vue的diff算法会比较这两个虚拟节点，找出需要执行的最小DOM操作（patches），最后这些DOM操作会被应用到实际的DOM上，以此来更新视图。 三、 snabbdom简介Snabbdom是瑞典语单词，原意为”速度“。是一个轻量级的虚拟DOM和DOM diff算法库，它被设计用于以非常高效的方式更新真实DOM。Vue.js在2.x版本中采用了虚拟DOM的概念来提高其性能和效率，而Vue 2.x内部使用的虚拟DOM实现实际上是在Snabbdom的基础上进行了一些定制和改造的。 Vue团队选择Snabbdom作为其虚拟DOM实现的原因主要是因为Snabbdom的高性能特性和小巧的体积。它提供了一个简洁的API来创建和管理虚拟节点（vnodes），并通过高效的diff算法来计算出虚拟DOM树的最小变更集，进而只对实际DOM进行必要的更新，减少了不必要的DOM操作，提高了页面的渲染效率。 vue2源码中更新基本和snabbdom中一致，部分边角细节不一致，所以我们看一下snabbdom源码大致就可以了解Vue更新的细节。 github地址：https://github.com/snabbdom/snabbdom 123456789101112131415161718192021222324252627282930313233import &#123; init, h&#125; from &quot;snabbdom&quot;;// 调用 init生成 patch渲染函数const patch = init([]);const container = document.getElementById(&quot;container&quot;);const myVnode = h(&#x27;div&#x27;,[ h(&#x27;p&#x27;,&#x27;苹果&#x27;), h(&#x27;p&#x27;,&#x27;香蕉&#x27;), h(&#x27;p&#x27;,&#x27;火龙果&#x27;),]);const myVnode2 = h(&#x27;div&#x27;,[ h(&#x27;p&#x27;,&#x27;苹果&#x27;), h(&#x27;p&#x27;,&#x27;香蕉&#x27;), h(&#x27;p&#x27;,&#x27;桃子&#x27;),])// 第一个参数为 DOM节点// 第二个参数为 VNODE节点// 表示第一次执行挂载操作patch(container, myVnode);document.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;,()=&gt;&#123; // 第一个参数为 DOM节点 // 第二个参数为 VNODE节点 // 表示执行更新操作 patch(myVnode, myVnode2);&#125;) 界面上渲染效果如下所示： 点击按钮后： 由之前的diff算法可知，当点击更新以后，界面上会复用前两个元素苹果和香蕉(即没有销毁以及重新创建)，那么如何证明它复用了呢，其实很简单，只需要在浏览器中手动更改前2个元素，如果点击更新以后，更改的前2个元素没有变化，即可证明它并对dom节点进行了复用。 如上代码所示，patch即为vue中的第一次渲染，点击按钮更新新的vnode相当于vue中的更新渲染，只不过vue中将行为进行了一些封装。所以掌握snabbdom即可掌握vue2的核心双端diff算法。 四、更新渲染在专栏第六篇中我们已经学习了首次渲染，首次渲染没有旧节点，所以不需要进行节点对比，直接创建元素并挂载就可以了。 这节会补充相同节点进行更新渲染的相关逻辑。下图是更新渲染重要函数patchVNode的关键流程图。 存在 text即为文本节点，文本节点没有 tag，只有 text。 4.1 为什么更新函数patchVNode叫做打补丁？123456789function patch(oldVNode,newVNode)&#123; // 省略代码 if(sameVnode(oldVNode,newVNode))&#123; // 进行精细化比较 patchVnode(oldVNode, newVNode); &#125;else&#123; // 粗暴更新 &#125;&#125; 在新旧虚拟节点相同的情况下下，渲染器会使用新的虚拟节点与旧的虚拟节点进行比较，试图找到并更新变更点。这个过程叫做“打补丁”，英文通常用patch来表达。 “打补丁”这个词形象地描述了patchVnode函数在vue框架中的工作方式。在计算机领域，“打补丁”通常指的是对现有程序或数据进行局部修改或修复，而不必完全重写或替换整个内容。patchVnode也是基于类似的理念工作的 最小化变更：当Vue的数据变化时，它需要决定如何将这些变化反映到界面上。patchVNode通过对比新旧虚拟DOM树（VNode），仅对发生改变的部分进行操作，这就像是在原有的DOM结构上打上“补丁”，而不是重建整个DOM树。这种做法极大地减少了实际的DOM操作，提高了性能。 精确更新:就像衣服破了洞，只需要在破洞处缝上一小块布料（补丁）即可修复，而不是制作一件新衣服。同样，Vue在更新界面时，只针对有差异的部分进行精确更新，这就是“打补丁”的过程。 4.2 进行dom的复用4.2.1 浏览器中的DOMDOM并不是存储在硬盘上作为文件的一部分，而是作为浏览器解析HTML后在JS引擎的内存空间里创建的一个对象模型。开发者可以通过JS来访问和修改这个内存的DOM，从而实现对网页内容的动态操作，比如添加、删除、修改DOM元素或应用样式等。用户看到的页面变化，实际上是浏览器根据内存中的DOM的状态重新渲染页面的结果。 浏览器的DOM结构存储在JS的堆内存中。堆内存是用来存储复杂数据结构如对象和数组的地方，DOM树作为对象的集合，自然也被存储在这里。每当一个网页被加载，浏览器就会在堆内存中创建一个与之对应的DOM树结构。 4.2.2 旧的vnode指向内存中的真实DOM在挂载阶段创建节点时，会将vnode中的elm属性指向内存的创建的真实DOM。如下代码所示。 12345678function createElm(vnode)&#123; const tag = vnode.tag; const data = vnode.data; // 省略部分代码 const elm = nodeOps.createElement(tag, data); vnode.elm = elm;&#125; 所以在更新渲染时，很容易通过旧的vnode中的elm属性来获取真实DOM。 4.2.3 新的vnode elm复用老的vnode elm由上可知，老的vnode指向了真实DOM，那么如果想复用可以将新的vnode也指向内存中的真实DOM即可，具体代码如下： 1234function patchVnode(oldVNode,vnode)&#123; // 复用旧节点的 DOM const elm = vnode.elm = oldVNode.elm;&#125; 上面的代码将新的虚拟节点的elm属性也指向了内存中的真实DOM，同时也创建了一个elm变量指向真实DOM。方便后续代码中使用这个真实的DOM元素。 此时新旧虚拟节点和真实DOM的状态如下图所示。 4.3 获取新老节点的子节点因为后续需要依据新节点和老节点的子节点信息来进行一些逻辑处理，所以要先获取他们的子节点信息方便后续处理。 12345function patchVnode(oldVNode,vnode)&#123; // 省略部分代码 const oldCh = oldVNode.children; const ch = vnode.children;&#125; 4.4 判断新虚拟节点是文本节点 通过if判断和vnode.text === undefined可以判断出新的虚拟节点是文本节点。 如果新的虚拟节点是文本节点，则旧的虚拟节点同样也是文本节点。 所以当新旧文本节点文本不同时，直接更新即可。 1234567891011function patchVnode(oldVNode,vnode)&#123; // 非文本节点 if(vnode.text === undefined)&#123; // 省略部分代码 &#125; // 文本节点 else if(oldVNode.text !== vnode.text)&#123; // 文本变化，直接更新 nodeOps.setTextContent(elm, vnode.text) &#125;&#125; 通过 vnode.text === undefined 来判断不是一个文本节点。所以else就代表它是一个文本节点。 判断 oldVNode.text和vnode.text是否相等;如果想等，不需要更新。如果不相等，意味着文字发生了变化， 直接调用setTextContent更新节点上的文本信息。 4.5 判断新虚拟节点是非文本节点上小节我们说到判断新虚拟节点是非文本节点的方法是vnode.text === undefined。 4.5.1 当新旧虚拟节点都存在子节点时 当新旧节点都有子节点时，这种情况最复杂，需要使用到双端diff算法，后续我们会详细说明。 123456789function patchVnode(oldVNode,vnode)&#123; // 非文本节点 if(vnode.text === undefined)&#123; if(oldCh !== undefined &amp;&amp; ch !== undefined)&#123; //双端diff算法 待实现 updateChildren(elm, oldCh, ch) &#125; &#125;&#125; 4.5.2 当新虚拟节点存在子节点 &amp; 旧虚拟节点不存在子节点 当新虚拟节点有子节点，旧虚拟节点没有子节点时，可以将新节点的子节点创建出来的DOM直接挂载到DOM上。 12345678910111213function patchVnode(oldVNode,vnode)&#123; // 非文本节点 if(vnode.text === undefined)&#123; if(oldCh !== undefined &amp;&amp; ch !== undefined)&#123; // 省略部分代码 &#125;else if (ch !== undefined) &#123; // 目前还想不到这行代码的实际应用场景 if (oldVNode.text !== undefined) api.setTextContent(elm, &quot;&quot;); // 增加子节点 addVnodes(elm, null, ch, 0, ch.length - 1); &#125; &#125;&#125; 第一个if中判断了新旧虚拟节点中都存在子节点。 第二个if中判断了新虚拟节点存在子节点，那么可以知道这个分支判断的是新节点存在子节点，但是旧节点不存在子节点。 如果新节点中存在子节点，但是旧节点中不存在子节点，说明需要将新节点的子节点创建出来的DOM直接挂载到DOM上。这里添加了一个判断就是如果旧节点是文本节点，需要先清除DOM中的文本元素，再添加新的dom，但是目前没有发现具体的使用场景。 addVnodes 函数和removeVnodes类似，目的是将一系列虚拟节点（VNodes）添加到DOM树中的指定位置，核心依赖insertBefore api。 4.5.3 当新虚拟节点没有子节点 &amp; 旧虚拟节点节点有子节点 当新虚拟节点没有子节点，旧虚拟节点有子节点时，需要在DOM中将旧节点的子节点清除。 1234567891011function patchVnode(oldVNode,vnode)&#123; if(vnode === undefined)&#123; if (oldCh !== undefined &amp;&amp; ch !== undefined) &#123; // 省略部分代码 &#125; else if(ch !== undefined)&#123; // 省略部分代码 &#125; else if(oldCh !== undefined)&#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1); &#125; &#125;&#125; 第一个if中判断了新旧节点中都存在子节点。 第二个if中判断了新节点存在子节点，但是旧节点不存在子节点。 所以可以得出第三个if中判断了新节点不存在子节点，但是旧节点存在子节点，所以需要清除DOM元素中的旧节点中的子节点。 4.5.4 新虚拟节点没有子节点且没有文字节点 &amp; 旧虚拟节点有文字节点新虚拟节点没有子节点且没有文字节点，旧节点有文字节点需要清除节点。 12345678910111213function patchVnode(oldVNode,vnode)&#123; if(vnode === undefined)&#123; if (oldCh !== undefined &amp;&amp; ch !== undefined) &#123; // 省略部分代码 &#125; else if(ch !== undefined)&#123; // 省略部分代码 &#125; else if(oldCh !== undefined)&#123; // 省略部分代码 &#125; else if(oldVNode.text !== undefined)&#123; api.setTextContent(elm, &quot;&quot;); &#125; &#125;&#125; 第一个if中判断了新旧节点中都存在子节点。 第二个if中判断了新节点存在子节点，旧节点不存在子节点。 第三个if中判断了新节点没有子节点，旧节点有子节点。 所以很容易知道oldVNode.text !&#x3D;&#x3D; undefined表示的是旧节点是文本节点，且新节点没有子节点。故直接清除节点中的文字即可。 五、双端diff核心函数-updateChildren在新旧虚拟节点打补丁时，当遇到新虚拟节点和旧虚拟节点都有子节点时，需要进行diff对比。 双端diff算法利用虚拟节点的key属性，尽可能的复用DOM元素，并通过移动DOM的方式来完成更新，从而减少不断地创建和销毁DOM元素带来的性能开销。 5.1 双端比较的四个关键索引值双端diff算法是一种同时对新旧两组子节点的两个端点进行比较的算法。因此，我们需要四个索引值，分别指向新旧两组子节点的端点。如下图所示： 后面的图片事例中，菱形代表新节点；方形代表老节点；圆形代表真实DOM；虚线代表当前元素已经被处理过。p代表节点的标签，1、2、3、4代表节点的key，“-“ 起连接作用。 5.1.1 头部节点和尾部节点 位置newStartIdx指向的节点代表新的一组子节点的头部节点。 同理位置oldStartIdx指向的节点代表旧的一组子节点的头部节点。 位置newEndIdx指向的节点代表新的一组子节点的尾部节点。 同理位置oldEndIdx指向的节点代表旧的一组子节点的尾部节点。 5.1.2 代码实现定义了一些索引值以及对应的虚拟节点。 12345678910111213141516171819、function updateChildren(parentElm,oldCh,newCh)&#123; // 旧的一组子节点的头部节点索引值 let oldStartIdx = 0; // 旧的一组子节点的尾部节点索引值 let oldEndIdx = oldCh.length - 1; // 新的一组子节点的头部节点索引值 let newStartIdx = 0; // 新的一组子节点的尾部节点索引值 let newEndIdx = newCh.length - 1; // 旧的一组子节点的头部节点 let oldStartVnode = oldCh[0]; // 旧的一组子节点的尾部节点 let oldEndVnode = oldCh[oldEndIdx]; // 新的一组子节点的头部节点 let newStartVnode = newCh[0]; // 新的一组子节点的尾部节点 let newEndVnode = newCh[newEndIdx]; &#125; 5.2 老vnode引用真实DOM在初次渲染完成后，所有虚拟节点中都保存了真实 DOM的引用，可以通过 elm属性获取对应的真实 DOM。 所以在更新渲染前，所有旧的一组子节点中都存储真实DOM的引用。如下图所示。 5.3 双端比较的方式 在双端比较中，每一轮都分为四个步骤，如上图中的连线所示。 第一步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的头部节点P-4，看看它们是否相同。由于两者的key值不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第二步：比较旧的一组子节点中的尾部节点P-4与新的一组子节点中的尾部节点P-3，看看他们是否相同。由于两者的key值不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第三步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的尾部节点P-3，看看它们是否相同。由于两者的key值不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第四步：比较旧的一组子节点中的尾部节点P-4与新的一组子节点中的头部节点P-4，看看它们是否相同。由于它们的key值相同，因此可以进行DOM复用。 直至找到了相同的一组子节点，他就会对节点做相应的处理，然后将对应的指针向没有处理过的节点方向移动，再次进行上述方式的比较。比如这里就是newStartId指针向下移动，而oldEndIdx指针向上移动。如下图所示。 下图中边框虚线表示已经处理过的元素。 newStartIdx指针向下移动，所以新子节点的头部节点变成了P-2。 oldEndIdx指针向上移动，所以旧子节点的尾部节点变成了P-3。 依旧重复双端diff的四个步骤： 第一步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的头部节点P-2是否相同。由于两者的key不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第二步：比较旧的一组子节点中的尾部节点P-3与新的一组子节点中的尾部节点P-3是否相同。由于它们的key相同，因此可以进行DOM复用。 因为已经在第二步中找到了，所以将newEndIdx指针向上移动，oldEndIdx向上移动。如下图所示。 newEndIdx指针向上移动，所以新子节点的尾部节点变成了P-1。 oldEndIdx指针向上移动，所以旧子节点的尾部节点变成了P-2。 由于还没有结束对比，依旧重复下面四个步骤： 第一步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的头部节点P-2是否相同。由于两者的key不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第二步：比较旧的一组子节点中的尾部节点P-2与新的一组子节点中的尾部节点P-1是否相同。由于两者的key不同，因此不相同。不可复用，于是什么都不做，直接跳过。 第三步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的尾部节点P-1是否相同。由于两者的key相同，因此可以进行DOM复用。 新旧两组节点中各还有一个节点没有比完。有的人会产生疑问，为啥要对比P-1和P-1不是一样的吗？对于程序来说，还没有移动指针，所以它是不清楚是否是相同节点的，所以还需要继续对比，将newEndIdx向上移动，oldStartIdx向下移动。 newEndIdx指针向上移动和newStartIdx重合，所以新子节点的头部节点和尾部相同，都是P-1。 oldStartIdx指针向下移动和oldEndIdx重合，所以旧子节点的头部节点和尾部节点相同，都是P-1。 此时对比还没有结束，依次重复双端diff的四个步骤： 第一步：比较旧的一组子节点中的头部节点P-1与新的一组子节点中的头部节点P-1是否相同。由于两者的key相同，因此可以进行DOM复用。 至此，所有的节点已经对比完毕。（节点复用的具体操作我们后面会说）。大致来说，diff算法是基于这四步进行比较的。 5.3.1 第三步和第四步顺序容易搞混？第三步比较 和 第四步比较对应的是双端中的“X”位置，很多人容易把它们的顺序给弄混淆。 你只需要记得是双端diff的逻辑是拿旧节点和新节点进行对比，所以需要先从旧节点的头部节点开始对比。 5.4 双端比较的循环条件双端diff每一轮比较是通过不断的移动索引值来完成的。比较会持续进行，直到以下任一条件满足为止： newStartIdx大于newEndIdx，意味着新节点列表全部遍历完成。 oldStartIdx大于oldEndIdx，意味着旧节点列表全部遍历完成。 5.4.1 代码如下代码所示，oldStartIdx大于oldEndIdx或者newStartIdx大于newEndIdx时，需要跳出循环： 123while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 省略部分代码&#125; 头尾指针是从外向里进行移动，当头指针大于尾指针，说明当前列表已经处理完成。 5.5 双端比较四步匹配如何移动我们知道双端diff存在的意义就是找到尽可能的复用节点，避免重新销毁、创建元素带来的性能损耗，这一节我们讨论下应该如何移动节点？ 我们还以之前使用的四个P节点举例。如下图，此时DOM元素的顺序还是跟旧的一组节点保持一致。 5.5.1 双端对比第四步：旧节点的尾部节点和新节点的头部节点相同 - 进行移动 如上图。在双端对比第一轮比较中的第四步比较中，旧的一组子节点的尾部节点P-4和新的一组子节点的头部节点P-4一样，说明它们对应的真实DOM可以进行复用。对于可复用的DOM节点，我们只需要通过DOM移动操作完成更新即可。 那么这种情况下，我们应该如何移动节点呢？为了搞清楚这个问题，我们需要分析第四步比较过程中的细节。 我们注意到：第四步是比较旧的一组子节点的尾部节点与新的一组子节点的头部节点，发现两者相同。这说明：节点P-4原本是最后一个子节点，但在新的顺序中，它变成了第一个子节点。换句话说，节点P-4在更新之后应该是第一个节点。对应到程序中的逻辑，可以将其翻译为：将索引oldEndIdx指向的虚拟节点所对应的真实DOM（最后一个节点）移动到索引oldStartIdx指向的虚拟节点所对应的真实DOM（第一个节点）前面。 代码如下所示。 12345678while(newStartIdx &lt;= newEndIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx)&#123; if(sameVNode(oldEndVnode, newStartVnode))&#123; patchVNode(oldEndVnode, newStartVnode); nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125;&#125; 由上面这些代码可知，在第四步这种情况下可以总结出下面几点内容。 当旧的一组节点的尾部节点对比新的一组节点的头部节点相同时，需要调用patchVNode函数对新旧对应节点进行打补丁。因为相同节点只能代表当前层级是相同的，并不能代表他的子节点信息等是相同的，所以需要对子节点继续进行比较。 oldEndVnode.elm 代表旧的一组节点的尾部节点所对应的真实节点。oldStartVnode.elm代表旧的一组节点的头部节点所对应的真实节点，insertBefore API可以将元素插入到某个元素之前。 DOM元素移动成功后，移动oldEndIdx指针以及newStartIdx指向至未处理的节点处。此时DOM和指针移动完成。 处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序是P-4、P-1、P-2、P-3。 5.5.2 双端对比第一步&amp;第二步 - 无需移动DOM 如上图所示，接着进行双端四步对比。此时在第二步中找到了相同的节点。如果在双端对比的第一步和第二步相同时，因为2者都同时处于尾部或者头部，因此不需要进行移动操作，只需要打补丁进行深度比较即可。 12345678910111213while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if(sameVNode(oldStartVnode, newStartVnode))&#123; patchVNode(oldStartVnode, newStartVnode); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125;else if(sameVNode(oldEndVnode, newEndVnode))&#123; patchVNode(oldEndVnode, newEndVnode); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125;else if(sameVNode(oldEndVnode, newStartVnode))&#123; // 省略部分逻辑 &#125;&#125; 第二轮比较中新旧两组节点中的尾部节点相同，无需移动DOM节点，只需要移动相对应的指针。处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序依旧是P-4、P-1、P-2、P-3。 5.5.3 双端对比第三步 - 旧节点的头部节点和新节点的尾部节点相同 - 进行移动在上一轮循环中，我们并没有移动节点，只是对节点进行打补丁操作并移动索引。 我们再次进行新一轮的四步比较。 如上图，在第三步的比较中我们发现两者节点相同。这说明：节点P-1原本是头部节点，但在新的顺序中，它变成了尾部节点。换句话说，节点P-1在更新之后应该是最后一个节点。因此，我们需要将节点P-1对应的真实DOM移动到旧的一组子节点的尾部节点P-2所对应的真实DOM后面。 代码如下所示。 123456789101112131415161718while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if(sameVNode(oldStartVnode, newStartVnode))&#123; // 省略 &#125;else if(sameVNode(oldEndVnode, newEndVnode))&#123; // 省略 &#125;else if(sameVNode(oldStartVnode, newEndVnode))&#123; patchVNode(oldStartVnode, newEndVnode); api.insertBefore( parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm) ); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125;else if(sameVNode(oldEndVnode, newStartVnode))&#123; // 省略 &#125;&#125; 由上面这些代码可知，在第三步这种情况下可以总结出下面几点内容。 在旧的一组节点的头部节点对比新的一组节点的尾部节点相同时，需要调用patchVNode函数对新旧对应节点进行打补丁。因为相同节点只能代表当前层级是相同的，并不能代表他的子节点信息等是相同的，所以需要对子节点继续进行比较。 oldStartVnode.elm 代表旧的一组节点的头部节点所对应的真实节点。oldEndVnode.elm代表旧的一组节点的尾部节点所对应的真实节点，insertBefore API可以将元素插入到某个元素之前。因为需要将节点移至最后一位，所以这里获取到旧的一组子节点的尾部节点下一位，即空白字符。 DOM元素移动成功后，移动oldStartIdx指针以及newEndIdx指向至未处理的节点处。此时DOM和指针移动完成。 第三轮比较中旧节点的尾部节点和新节点的头部节点相同，则移动旧节点头部节点对应的DOM元素到尾部节点对应的DOM元素之后。处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序是P-4、P-2、P-1、P-3。 如上图所示，其实这个时候DOM元素的顺序已经完全调整好了，但是由于还有一组数据没有对比完，所以要接着进行对比，我们可以发现，新旧节点均只存在一组子节点，我们进行对比，发现节点一样，由于这属于第一步，不需要进行DOM移动，只需要打补丁即可。这里不再赘述。 5.5.4 总结经过上面的实践，我们可以对该现象进行总结： 在执行双端diff的第一步（新旧两组子节点的头部节点进行比较）和第二步（新旧两组子节点的尾部节点进行比较）时，如果找到相同节点，不需要移动DOM，只需要打补丁。 在执行双端diff的第三步（旧的一组子节点的头部节点与新的一组子节点的尾部节点）时，如果找到相同节点，需要将旧的一组子节点的头部节点引用的真实节点插入到旧的一组子节点的尾部节点引用的真实节点之后。同时需要打补丁。 在执行双端diff的第四步（旧的一组子节点的尾部节点与新的一组子节点的头部节点）时，如果找到相同节点，需要将旧的一组子节点的尾部节点引用的真实节点插入到旧的一组子节点的头部节点引用的真实节点之前。同时需要打补丁。 5.5.5 思考：为什么在第三步&#x2F;第四步中 节点移动的位置跟当前处理中的元素位置有关不知道大家有没有质疑过，在第三步时，节点移动的位置不是插在整个DOM树的最后一个位置，而是跟当前处理中的元素位置有关。即头部节点和尾部节点有关。 因为在第三步双端diff比较的过程中，尾部节点的索引是一直向上的，所以后面处理的元素一定不会比之前处理过的元素位置要更靠后。也就是说一定会在当前处理元素的最后一位。 5.6 非理想情况下应该如何操作之前我们举的例子一直是比较理想的情况，即每一轮diff对比都能够命中，但是实际中可能存在无法命中的情况。 如上图所示，我们使用之前的diff对比方法发现四步均无法找到可复用的节点，这个时候我们需要添加额外的处理步骤来处理这种非理想的情况。 既然两个头部和两个尾部的四个节点中都没有可复用的节点，那么我们就尝试看看非头部、非尾部的节点能否复用。、 5.6.1 拿新的一组子节点的头部节点在旧子节点中寻找可复用节点具体做法是，拿新的一组子节点中的头部节点去旧的一组子节点中寻找。 123456789101112131415161718while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if(sameVNode(oldStartVnode, newStartVnode))&#123; //省略 &#125;else if(sameVNode(oldEndVnode, newEndVnode))&#123; //省略 &#125;else if(sameVNode(oldStartVnode, newEndVnode))&#123; //省略 &#125;else if(sameVNode(oldEndVnode, newStartVnode))&#123; //省略 &#125;else &#123; // 遍历旧的一组子节点，试图寻找与 newStartVNode 拥有相同 key 值的节 // idxInOld 就是新的一组子节点的头部节点在旧的一组子节点中的索引 const idxInOld = oldCh.findIndex( node =&gt; node.key === newStartVnode.key ) &#125;&#125; 在上面这段代码中，我们遍历旧的一组子节点，尝试在其中寻找与新的一组子节点的头部节点具有相同key值的节点，并将该节点在旧的一组子节点中的索引存储到变量idxInOld中。 那么在旧的一组子节点中，找到与新的一组子节点的头部节点具有相同key值的节点意味着什么呢？ 观察上图，当我们拿新的一组子节点的头部节点P-2去旧的一组子节点中查找时，会在索引为1的位置找到可复用的节点。 这意味着，节点P-2原本不是头部节点，但在更新之后，它应该变成头部节点。 所以我们需要将节点P-2对应的真实DOM节点移动到当前旧的一组子节点的头部节点P-1所对应的真实DOM之前。 1234567891011121314151617181920212223242526272829303132while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if(sameVNode(oldStartVNode, newStartVNode))&#123; // 省略 &#125;else if(sameVNode(oldEndVNode, newEndVNode))&#123; // 省略 &#125;else if(sameVNode(oldStartVNode, newEndVNode))&#123; // 省略 &#125;else if(sameVNode(oldEndVNode, newStartVNode))&#123; // 省略 &#125;else &#123; // 遍历旧的一组子节点，试图寻找与 newStartVNode 拥有相同 key 值的节 // idxInOld 就是新的一组子节点的头部节点在旧的一组子节点中的索引 const idxInOld = oldCh.findIndex( node =&gt; node.key === newStartVNode.key ) // idxInOld 大于 0，说明找到了可复用的节点，并且需要将其对应的真实DOM移动到头部 if(idxInOld &gt; 0)&#123; // idxInOld 位置对应的 vnode 就是需要移动的节点 const vnodeToMove = oldCh[idxInOld] // 不要忘记除移动操作外还应该打补丁 patchVNode(vnodeToMove, newStartVNode) // 将 vnodeToMove.el 移动到头部节点 oldStartVNode.el 之前，因此使用后者作为锚点 api.insertBefore(parentElm,vnodeToMove.elm,oldStartVNode.elm); // 由于位置 idxInOld 处的节点所对应的真实 DOM 已经移动到了别处，因此将其设置为 undefined oldCh[idxInOld] = undefined // 最后更新 newStartIdx 到下一个位置 newStartVNode = newCh[++newStartIdx] &#125; &#125;&#125; 在上面这段代码中，首先判断idInOld是否大于0。如果条件成立，则说明找到了可复用的节点，然后将该节点对应的真实DOM移动到头部。为此，我们先要获取需要移动的节点，这里的oldCh[idxInOld]所指向的节点就是需要移动的节点。在移动节点之前，不要忘记调用patchVNode函数打补丁。接着，调用insertBefore函数，并以现在的头部节点对应的真实DOM节点oldStartVNode.el作为锚点参数来完成节点的移动操作。当节点移动完成后，还有两步工作需要做。 由于处理idxInOld处的节点已经处理过了（对应的真实DOM移到了别处），因此我们应该将oldCh[idxInOld]设置为undefined。 新的一组子节点中的头部节点已经处理完毕，因此将newStartIdx前进到下一个位置。 第一轮比较中，在索引1处找到了可以复用的节点。需要将索引1对应的DOM节点移动到旧的一组节点对应的DOM节点之前，并且向下移动相对应的指针newStartIdx。处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序是P-2、P-1、P-3、P-4。 5.6.2 处理undefined情况 如上图，我们继续接着进行diff，接着使用之前说到的双端diff比较方法进行比较。 第一步：比较旧的一组子节点的头部节点P-1与新的一组子节点的头部节点P-4，看看它们是否相同。由于两者的key不相同，因此不可以复用节点，直接跳过。 第二步：比较旧的一组子节点的尾部节点P-4与新的一组子节点的尾部节点P-3，看看它们是否相同。由于两者的key不相同，因此不可以复用节点，直接跳过。 第三步：比较旧的一组子节点的头部节点P-1与新的一组子节点的尾部节点P-3，看看它们是否相同。由于两者的key不相同，因此不可以复用节点，直接跳过。 第四步：比较旧的一组子节点的尾部节点P-4与新的一组子节点的头部节点P-4，看看它们是否相同。由于两者的key相同，因此可以复用节点。 在第四步中，我们发现旧的一组子节点的尾部节点P-4和新的一组子节点的头部节点P-4相同。根据之前学到的知识，P-1在旧的一组子节点中是在最后一位，在新的一组子节点中在第一位。因此，我们需要将旧的尾部节点所对应的DOM节点移动到旧的头部节点所对应的DOM节点之前。 处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序是P-2、P-4、P-1、P-3。 由于还没有比较完成，所以我们需要继续使用之前介绍的方法进行对比。 第一步：比较旧的一组子节点的头部节点P-1与新的一组子节点的头部节点P-1，看看它们是否相同。由于两者的key为1，因此可以复用节点。 我们之前讨论过，当在双端diff的第一步和第二步比较相同时，可以复用，不需要移动节点，但是需要调用patchVNode进行打补丁，并移动oldStartIdx和newStartIdx向后一位。 处理后的节点的状态以及真实DOM的顺序如下图所示。此时节点的顺序是P-2、P-4、P-1、P-3。 由于还没有比较完成，所以我们需要继续进行下一轮的比较。这个时候我们发现，旧的一组子节点中的头部节点是undefined。这说明该节点已经被处理过了，因此不需要再处理它了，直接跳过即可，但是不要忘记移动指针oldStartIdx。 我们需要补充这部分的逻辑实现： 123456789101112131415161718while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 增加两个判断分支，如果头尾部节点为undefined，则说明该节点已经被处理过了，直接跳到下一个位置 if(!oldStartVNode)&#123; oldStartVNode = oldCh[++oldStartIdx]; &#125;else if(!oldEndVNode)&#123; oldEndVNode = oldCh[--oldEndIdx]; &#125;else if(sameVNode(oldStartVNode, newStartVNode))&#123; // 省略代码 &#125;else if(sameVNode(oldEndVNode, newEndVNode))&#123; // 省略代码 &#125;else if(sameVNode(oldStartVNode, newEndVNode))&#123; // 省略代码 &#125;else if(sameVNode(oldEndVNode, newStartVNode))&#123; // 省略代码 &#125;else &#123; // 省略代码 &#125;&#125; 由于还没有比较完成，所以我们需要继续进行下一轮的比较。 第一步：比较旧的一组子节点的头部节点P-3和新的一组子节点的头部节点P-3，看看他们是否相同。由于两者的key为3，因此可以复用DOM节点。 第一步比较不需要移动DOM节点，但是需要调用patchVNode进行打补丁，并移动oldStartIdx和newStartIdx向后一位。 至此，双端diff所有比较已经结束，最终DOM的顺序为P-2、P-4、P-1、P-3。 5.7 添加新元素在上一节中，我们介绍了非理想情况下（在一轮比较过程中，不会命中四个步骤中的任何一步）的处理逻辑。 如上图例子所示，这一节中我们主要讨论新增新元素的情况。 首先，我们尝试进行第一轮比较，发现在四个步骤中都找不到复用的节点。于是我们尝试拿新的一组子节点中的头部节点P-4去旧的一组子节点中寻找相同key值的节点，但是在旧的一组子节点中根本就没有P-4节点，如下图所示。 5.7.1 挂载节点到正确的位置以上这说明节点P-4是一个新增节点，我们应该将它挂在到正确的位置。那么应该挂载到哪里呢？ 因为节点P-4是新的一组子节点的头部节点，所以只需要将它挂载到当前头部节点之前即可。 “当前”头部节点指的是，旧的一组子节点中的头部节点所对应的真实DOM节点P-1。 12345678910111213141516171819202122232425262728293031while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if(!oldStartVNode)&#123; // 代码省略 &#125;else if(!oldEndVNode)&#123; // 代码省略 &#125;else if(sameVNode(oldStartVNode, newStartVNode))&#123; // 代码省略 &#125;else if(sameVNode(oldEndVNode, newEndVNode))&#123; // 代码省略 &#125;else if(sameVNode(oldStartVNode, newEndVNode))&#123; // 代码省略 &#125;else if(sameVNode(oldEndVNode, newStartVNode))&#123; // 代码省略 &#125;else &#123; // 代码省略 const idxInOld = oldCh.findIndex( node =&gt; node.key === newStartVNode.key ) if(idxInOld &gt; 0)&#123; // 代码省略 &#125;else&#123; // 将 newStartVNode 作为新节点挂载到头部，使用当前头部节点oldStartVNode.el 作为锚点 api.insertBefore( parentElm, createElm(newStartVNode), oldStartVNode.elm ) &#125; newStartVNode = newCh[++newStartIdx] &#125;&#125; 如上面的代码所示，当条件idxInOld &gt; 0 不成立时，说明newStartVNode节点是全新的节点。又由于newStartVNode节点是头部节点，因此我们应该将其作为新的头部节点进行挂载。 处理后的真实节点的顺序为P-4、P-1、P-2、P-3。如下图所示： 当新节点P-4挂载完成后，会进行后续的更新，直到全部更新完成为止。 5.7.2 异常情况上一节中我们补充了新增节点时的逻辑。但是并不是完美的，我们调整一下上述例子中的新的一组子节点顺序，如下图所示： 对这个例子，我们使用双端diff算法进行第一轮的对比。 第一步：比较旧的一组子节点的头部节点P-1和新的一组子节点的头部节点P-4，看看是否相同。发现不相同，不可复用，直接跳过。 第二步：比较旧的一组子节点的尾部节点P-3和新的一组子节点的尾部节点P-3，看看是否相同。发现相同，可以复用DOM。 所以我们需要将oldEndIdx和newEndIdx都向下移动一位，并且对这2个节点进行打补丁。处理完以后节点的处理状态以及真实的DOM顺序如下图所示： 此时，真实DOM节点的顺序是：P-1、P-2、P-3。由于还没有比较完成，所以我们需要继续进行下一轮的比较。 第一步：比较旧的一组子节点的头部节点P-1和新的一组子节点的头部节点P-4，看看是否相同。发现不相同，不可复用，直接跳过。 第二步：比较旧的一组子节点的尾部节点P-2和新的一组子节点的尾部节点P-2，看看是否相同。发现相同，可以复用DOM。 所以我们需要将oldEndIdx和newEndIdx都向下移动一位，并且对这2个节点进行打补丁。处理完以后节点的处理状态以及真实的DOM顺序如下图所示： 此时，真实DOM节点的顺序是：P-1、P-2、P-3。由于还没有比较完成，所以我们需要继续进行下一轮的比较。 第一步：比较旧的一组子节点的头部节点P-1和新的一组子节点的头部节点P-4，看看是否相同。发现不相同，不可复用，直接跳过。 第二步：比较旧的一组子节点的尾部节点P-1和旧的一组子节点的尾部节点P-1，看看是否相同。发现相同，可以复用DOM。 所以我们需要将oldEndIdx和newEndIdx都向下移动一位，并且对这2个节点进行打补丁。处理完以后节点的处理状态以及真实的DOM顺序如下图所示： 当这一轮更新完毕后，由于变量oldStartIdx的值大于oldEndIdx的值，满足更新停止的条件，因此更新停止。但是我们可以观察到，节点P-4在整个更新过程中被遗漏了，没有得到任何处理，这说明我们的算法是有缺陷的。为了弥补这个缺陷，我们需要添加额外的处理逻辑。 123456789101112while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 代码省略&#125;if(newStartIdx &lt;= newEndIdx)&#123; addVnodes( parentElm, oldStartVNode.elm, newCh, newStartIdx, newEndIdx )&#125; 我们在while循环结束后增加了一个if条件语句，检查新的一组子节点的头部节点和尾部节点的索引情况。如图可知，当newStartIdx &lt;&#x3D; newEndIdx成立，说明新的一组子节点中有遗留的节点需要作为新节点挂载。哪些节点是新节点呢？索引值位于newStartIdx和newEndIdx这个区间内的节点都是新节点。于是我们调用之前定义的方法addVnodes即可进行挂载。其中锚点元素为旧节点的头部节点。 5.8 移除元素上一节中我们讨论了添加元素如何操作，现在我们讨论下如何移除元素。如下图所示： 在这个例子中，新旧两组子节点的顺序如下。 旧的一组子节点：P-1、P-2、P-3。 新的一组子节点：P-1、P-3。 可以看到，在新的一组子节点中P-2节点已经不存在了。为了弄清楚应该如何处理节点被移除的情况，我们还是按照双端Diff算法的思路执行逻辑。 第一步：比较旧的一组子节点的头部节点P-1与新的一组子节点中的头部节点P-1，看看他们是否相同。发现两者的key相同，可以复用。 在第一步的比较中找到了可复用的节点，于是执行更新。在这一轮比较过后，新旧两组子节点以及真实DOM节点的状态如下图所示： 接着，执行下一轮更新。 第一步：比较旧的一组子节点中的头部节点P-2与新的一组子节点中的头部节点P-3，两者的key值不同，不可以复用。 第二步：比较旧的一组子节点中的尾部节点P-3与新的一组子节点中的尾部节点P-3，两者的key相同，可以复用。 在第二步中找到了可复用的节点，于是进行更新。更新后的新旧两组子节点以及真实DOM节点的状态如下图所示： 此时变量newStartIdx的值大于变量newEndIdx的值，满足更新停止的条件，于是更新结束。观察上图可知，旧的一组子节点中存在未被处理的节点，应该将其移除。因此，我们需要增加额外的代码来处理它。 12345678if(oldStartIdx &lt;= oldEndIdx)&#123; removeVnodes( parentElm, oldCh, oldStartIdx, oldEndIdx )&#125; 与处理新增节点类似，我们在while循环结束后又增加了一个else…if分支，用于卸载已经不存在的节点。由图可知，索引值位于oldStartIdx和oldEndIdx这个区间内的节点都应该被卸载，于是我们需要调用之前定义的removeVnodes对他们进行逐一删除。 六、总结这篇专栏中，我们对Vue2中双端diff算法进行了详细的解释，diff算法是在Vue更新渲染时进行节点复用的算法，通过这个算法，可以避免频繁的对节点进行删除、添加造成的性能消耗。"},{"title":"🔥Vue2数据响应式原理","path":"//posts/vue2-observe.html","content":"&nbsp; 返回 专栏第八篇-数据响应式原理 上一篇中我们将初次渲染页面的流程大致的过了一遍。 当然，还有很多细节没有描述。 Vue中最核心的部分的就是数据驱动视图，所谓响应式就是当数据发生改变时，界面会同步更新。 一、数据代理的基础数据代理，有时也被称作数据劫持，是一种技术手段，它能够截获对对象属性的访问和修改操作，并在这些操作发生时执行额外的逻辑或修改返回的结果。 在 Vue.js 中，响应式系统的核心机制正是基于数据代理。 通过代理，Vue 能够在数据被访问时收集依赖，在数据被修改时更新这些依赖，这是响应式系统运作的基本理念。 而这一切都依赖于 Vue 对数据进行的拦截和代理操作。 尽管响应式特性本身并非本节的讨论重点，我们将探索数据代理在其他场景下的应用。 在深入分析之前，重要的是要理解实现数据代理的两种主要方法：Object.defineProperty和 Proxy。 这两种方法为我们提供了强大的支持，以实现对数据访问和修改行为的精细控制。 1.1 Object.definePropertyVue是通过这个API对数据进行监听的。 Object.defineProperty() 方法用于在一个对象上直接定义一个新属性，或者修改一个对象的现有属性，并返回该对象。 基本使用如下： 1Object.defineProperty(obj, prop, descriptor) 参数说明： obj：必需。目标对象props：必需。需定义或修改的属性的名字descriptor：必需。目标属性所拥有的特性 Object.defineProperty() 允许我们精确地添加或修改对象的属性。 给对象的属性添加特性描述有两种形式：1.数据描述和2.存取描述 color:orange。 数据描述和存取描述所对应的属性是不同的。 1.1.1 数据描述当修改或定义对象的某个属性的时候，给这个属性添加一些特性。 1234567891011121314151617let obj = &#123; test:&#x27;hello world&#x27;&#125;//对已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,&#123; configurable:true | false, enumerable:true | false, value:任意类型的值, writable:true | false&#125;);//对新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,&#123; configurable:true | false, enumerable:true | false, value:任意类型的值, writable:true | false&#125;); 数据描述中有四个属性，都是可选的，来看一下每一个属性的作用。 1.1.1.1 value属性对应的值，可以使用任意类型的值，默认为 undefined。 123456789101112let obj = &#123;&#125;//第一种情况：不设置value属性Object.defineProperty(obj,&quot;newKey&quot;,&#123;&#125;);console.log( obj.newKey ); //undefined----------------------------------------//第二种情况：设置value属性Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;&#125;);console.log( obj.newKey ); //hello 1.1.1.2 writable属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。 123456789101112131415161718let obj = &#123;&#125;//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false&#125;);//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey ); //hello------------------------------//第二种情况：设置value属性Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:true&#125;);//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey ); //change value 1.1.1.3 configurable是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。 这个属性起到两个作用： 目标属性是否可以使用delete删除 目标属性是否可以再次设置特性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//-----------------测试目标属性是否能被删除------------------------let obj = &#123;&#125;//第一种情况：configurable设置为false，不能被删除。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:false, configurable:false&#125;);//删除属性delete obj.newKey;console.log( obj.newKey ); //hello//第二种情况：configurable设置为true，可以被删除。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:false, configurable:true&#125;);//删除属性delete obj.newKey;console.log( obj.newKey ); //undefined//-----------------测试是否可以再次修改特性------------------------let obj = &#123;&#125;//第一种情况：configurable设置为false，不能再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:false, configurable:false&#125;);//重新修改特性//报错：Uncaught TypeError: Cannot redefine property: newKey// 因为 writable和 configurable都为 false 即无法重新配置Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:true, enumerable:true, configurable:true&#125;);//第二种情况：configurable设置为true，可以再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:false, configurable:true&#125;);//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:true, enumerable:true, configurable:true&#125;);console.log( obj.newKey ); //hello 1.1.1.4 enumerable此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。 1234567891011121314151617181920212223let obj = &#123;&#125;//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:false&#125;);//枚举对象的属性for( var attr in obj )&#123; console.log( attr ); // 打印为空&#125;//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,&#123; value:&quot;hello&quot;, writable:false, enumerable:true&#125;);//枚举对象的属性for( var attr in obj )&#123; console.log( attr ); //newKey&#125; 一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false color:orange 1.1.2 存取器描述存取器描述符也有四个属性：get、set、enumerable、configure。 1234567let obj = &#123;&#125;;Object.defineProperty(obj,&quot;newKey&quot;,&#123; get:function ()&#123;&#125; | undefined, set:function (value)&#123;&#125; | undefined configurable: true | false enumerable: true | false&#125;); 当使用了getter或setter方法，不允许使用writable和value这两个属性 1.1.2.1 getter&#x2F;setter当设置或获取对象的某个属性的值的时候，可以提供getter&#x2F;setter方法。 getter 是一种获得属性值的方法 setter是一种设置属性值的方法。 在特性中使用get&#x2F;set属性来定义对应的方法。 12345678910111213141516171819let obj = &#123;&#125;;let initValue = &#x27;hello&#x27;;Object.defineProperty(obj,&quot;newKey&quot;,&#123; get:function ()&#123; //当获取值的时候触发的函数 return initValue; &#125;, set:function (value)&#123; //当设置值的时候触发的函数,设置的新值通过参数value拿到 initValue = value; &#125;&#125;);//获取值console.log( obj.newKey ); //hello//设置值obj.newKey = &#x27;change value&#x27;;console.log( obj.newKey ); //change value 注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined configurable和enumerable同上面的用法。 属性描述符和数据描述符都是相互独立的，如果你在第三个参数中既写了 value&#x2F;writable，又写了 get&#x2F;set 则会报错。 1.1.3 兼容性 兼容性如上图所示，需要注意的是：在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。 1.1.4 困惑的问题 如上，在使用 get 方法后，无法直接看到对象上的属性，需要点击才可以。 1.2 Proxy1.2.1 defineProperty的缺点我们知道Vue2中的数据响应式处理使用的是 Object.defineProperty，而 Vue3中实现数据响应使用的是 Proxy。 Object.defineProperty虽然可以实现功能，但是无法对数组或者深层次对象进行监听处理。 1.2.1.1 数组123456789101112131415161718192021let arr = [1,2,3,4,5];arr.forEach((item,index)=&gt;&#123; Object.defineProperty(arr,index,&#123; get() &#123; console.log(&#x27;数组被getter拦截&#x27;) return item &#125;, set(value) &#123; console.log(&#x27;数组被setter拦截&#x27;) return item = value &#125; &#125;)&#125;)arr[1] = 11;console.log(arr[1]);arr.push(6)arr[10] = 10// 结果数组被setter拦截数组被getter拦截11 很显然，已知长度的数组可以通过索引进行属性的设置与访问 color:orange。 然而，数组的添加操作却无法被直接拦截。 这很容易理解：无论是通过 arr.push() 方法还是直接赋值如 arr[10] &#x3D; 10 来添加元素，新添加的索引并未被包含在预设的数据拦截机制中，因此无法实现拦截处理。 这是使用 Object.defineProperty 进行数据代理的一个局限性。 Vue 在其响应式系统中对数组方法进行了重写，从而间接地解决了此问题。 1.2.1.2 深层次对象12345678910111213141516171819202122let obj=&#123; level1:&#123; level2:&quot;第二层&quot; &#125;&#125;// 保存 level1 的原始值 避免循环引用的错误let originalLevel1 = obj.level1;Object.defineProperty(obj,&#x27;level1&#x27;,&#123; get()&#123; console.log(&quot;对象被getter拦截&quot;) return originalLevel1 &#125;, set(value)&#123; console.log(&quot;对象被setter拦截&quot;) originalLevel1 = value; &#125;&#125;)// 结果对象被setter拦截对象被getter拦截obj.level1 = &#123;level3:&quot;第三层&quot;&#125;console.log(obj.level1)// &#123;level3:&quot;第三层&quot;&#125; 可以看到更新设置的那一层是没问题的。 但是如果我们更新更深层次的对象，就无法监听到。 1234567891011121314151617181920let obj=&#123; level1:&#123; level2:&quot;第二层&quot; &#125;&#125;// 保存 level1 的原始值 避免循环引用的错误let originalLevel1 = obj.level1;Object.defineProperty(obj,&#x27;level1&#x27;,&#123; get()&#123; console.log(&quot;对象被getter拦截&quot;) return originalLevel1 &#125;, set(value)&#123; console.log(&quot;对象被setter拦截&quot;) originalLevel1 = value; &#125;&#125;) obj.level1.level2 = &#x27;第二层-复制&#x27;//结果对象被getter拦截 可以看出来并没有执行 set 方法，如果想要深层次的属性也被监听到的话，需要递归地给对象中的每一个属性添加属性描述。 1234567891011121314151617181920212223242526272829function walk(obj)&#123; // 如果不是对象 无需处理 if(!(obj instanceof Object)) return obj for(let k in obj)&#123; let val = obj[k]; walk(val); Object.defineProperty(obj,k,&#123; enumerable:true, configurable:true, get()&#123; console.log(`访问obj.$&#123;k&#125;属性触发`) return val &#125;, set(newValue) &#123; console.log(`修改obj.$&#123;k&#125;属性触发` , newValue) if (val === newValue) return; val = newValue walk(newValue) &#125; &#125;) &#125; return obj;&#125;// 递归监听所有层级对象let obj = &#123;a:&#123;b:&#123;c:&#x27;d&#x27;&#125;&#125;&#125;walk(obj)obj.aobj.a.bobj.a.b.c 1.2.2 Proxy的介绍Proxy就可以解决Object.defineProperty的这些问题。 代理是目标对象的抽象。 他可以用作目标对象的替身，但又完全独立于目标对象。 目标对象既可以直接被操作，也可以通过代理来操作。但是直接操作会绕过代理赋予的行为。 1.2.2.1 空代理最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。 代理对象上执行的所有操作都会无障碍的传播到目标对象。 123456789101112131415161718192021222324252627282930const target = &#123; id: &#x27;target&#x27;&#125;const handler = &#123;&#125;const proxy = new Proxy(target, handler)// id属性会访问同一个值console.log(target.id); // targetconsole.log(proxy.id); // target// 给目标属性赋值会反映在两个对象上// 因为两个对象访问的是同一个值target.id = &#x27;foo&#x27;;console.log(target.id); // fooconsole.log(proxy.id); // foo // 给代理属性赋值会反映在两个对象上// 因为这个赋值会转移到目标对象proxy.id = &#x27;bar&#x27;;console.log(target.id); // barconsole.log(proxy.id); // bar// Proxy.prototype 是 undefined// 因此不能使用 instanceof 操作符console.log(target instanceof Proxy); // TypeError: Function has non-object prototype console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype// 严格相等可以用来区分代理和目标console.log(target === proxy); // false 1.2.2.2 定义捕获器当然，正常使用不会给一个空代理，肯定是要通过代理对访问和修改进行捕获。 本节暂且介绍几个常用的捕获器。覆盖Vue2中使用的所有捕获器。 1.2.2.2.1 get 捕获器get捕获器会在获取属性值的操作中被调用。 12345678910111213141516const target = &#123; foo: &#x27;bar&#x27;&#125;; const handler = &#123; // 捕获器在处理程序对象中以方法名为键 get()&#123; return &#x27;handler override&#x27;; &#125;&#125;const proxy = new Proxy(target, handler)// 只有在代理对象上执行这些操作才会触发捕获器 在目标对象上执行这些操作仍然会产生正常的行为console.log(target.foo) // barconsole.log(proxy.foo) // handler override 返回值 返回值无限制。 拦截的操作 proxy.property proxy[property] Object.create(proxy)[property] Reflect.get(proxy, property, receiver) 捕获器处理程序参数 target: 目标对象 property: 引用目标对象上的字符串键属性 receiver: 代理对象或继承代理对象的对象 1.2.2.2.2 set捕获器set()捕获器会在设置属性值的操作中被调用。 123456789const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; set(target, property, value, receiver) &#123; console.log(&#x27;触发了set&#x27;); return Reflect.set(...arguments) &#125;&#125;);proxy.foo = &#x27;bar&#x27;;// 触发了set 返回值 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。 拦截的操作 proxy.property &#x3D; value proxy.[property] &#x3D; value Object.create(proxy)[property] &#x3D; value Reflect.set(proxy, property, value, receiver) 捕获器处理程序参数 target: 目标对象 property: 引用目标对象上的字符串键属性 value：要赋给属性的值。 receiver: 接收最初赋值的对象 1.2.2.2.3 has捕获器has()捕获器会在 in 操作符中被调用。 123456789const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123; has(target, property) &#123; console.log(&#x27;触发了has函数&#x27;); return Reflect.has(...arguments) &#125;&#125;);&#x27;foo&#x27; in proxy;// 触发了has函数 返回值 has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。 拦截的操作 property in proxy property in Object.create(proxy) with(proxy) {(property);} Reflect.has(proxy, property) 捕获器处理程序参数 target: 目标对象 property: 引用目标对象上的字符串键属性 1.2.3 试试深层次对象和数组上面我们说到Object.defineProperty对于数组格式和深层次对象处理不了。 那我们来试试 Proxy是否可以处理。 1.2.3.1 处理数组123456789101112131415let target = [1,2,3,4] let proxy = new Proxy(target,&#123; get()&#123; console.log(&quot;触发了获取数组&quot;) return Reflect.get(...arguments) &#125;, set()&#123; console.log(&quot;触发了设置数组&quot;) return Reflect.set(...arguments) &#125;&#125;) proxy1.push(5);console.log(proxy1[4]); 可以看到打印了多次。 但是这里有点令我困惑的是为什么会打印这么多次?。 1.2.3.2 处理深层次对象123456789101112131415let target = &#123;a:&#123;b:&#123;c:&#x27;d&#x27;&#125;&#125;&#125;let proxy = new Proxy(target,&#123; get()&#123; console.log(&quot;触发了获取对象&quot;) return Reflect.get(...arguments) &#125;, set()&#123; console.log(&quot;触发了设置对象&quot;) return Reflect.set(...arguments) &#125;&#125;) proxy.a.b.cproxy.a.b.c = &#x27;e&#x27; 二、initProxy虽然Vue2中的数据劫持并没有使用 Proxy，但是却在检测 data 时使用了Proxy。 还记得我们在前面章节专栏第四篇-初始化干了什么事中介绍了Vue实例化的时候会调用 initProxy，但是当时我们并没有对这个方法进行深度剖析，因为这个方法主要是使用 Proxy 来进行数据代理。 但是我们现在已经学习了 Proxy，所以我们这几来详细看下这块的逻辑。 1234567Vue.prototype._init = function (options) &#123; if (__DEV__) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125;&#125; 在开发环境下，调用了 initProxy。 而在生产环境下并没有调用，而是将实例本身赋值到_renderProxy属性中。 一般仅存在于开发环境中的逻辑都是一些报错提示信息，所以我们盲猜initProxy也是添加了开发时报错的提示信息。 1234567891011121314151617181920212223242526272829303132333435363738const hasHandler = &#123; has(target, key) &#123; const has = key in target const isAllowed = allowedGlobals(key) || (typeof key === &#x27;string&#x27; &amp;&amp; key.charAt(0) === &#x27;_&#x27; &amp;&amp; !(key in target.$data)) if (!has &amp;&amp; !isAllowed) &#123; if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key) &#125; return has || !isAllowed &#125;&#125;const getHandler = &#123; get(target, key) &#123; if (typeof key === &#x27;string&#x27; &amp;&amp; !(key in target)) &#123; if (key in target.$data) warnReservedPrefix(target, key) else warnNonPresent(target, key) &#125; return target[key] &#125;&#125;initProxy = function initProxy(vm) &#123; if (hasProxy) &#123; // determine which proxy handler to use const options = vm.$options const handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler vm._renderProxy = new Proxy(vm, handlers) &#125; else &#123; vm._renderProxy = vm &#125; &#125;&#125; 2.1 hasProxy首先判断当前宿主环境中是否存在Proxy，通过Proxy是否定义和是原生属性来判断。 12345export function isNative(Ctor: any): boolean &#123; return typeof Ctor === &#x27;function&#x27; &amp;&amp; /native code/.test(Ctor.toString())&#125;const hasProxy = typeof Proxy !== &#x27;undefined&#x27; &amp;&amp; isNative(Proxy) 2.2 _renderProxy在开发环境下给 vm 设置代理后，将_renderProxy设置为代理对象。代理目标为 vue实例 vm。这意味着当访问 vm时，会触发代理捕获器。 在生产环境下直接将_renderProxy设置为实例 vm。 所以可以看出来不论是在开发环境或者生产环境如何都是给 vm._renderProxy设置值。 那么这里的_renderProxy是在何时使用的呢？ 答案是在执行_render方法生成 vnode的时候，将 vm._renderProxy 当做第一个参数传入render方法中。 1vnode = render.call(vm._renderProxy, vm.$createElement) 比如我们在.vue文件的模版中编写一段代码： 1&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; 上面这段代码会被转化成一个render函数。 12345678910render = function()&#123; // 获取 this const _vm = this; // _vm._self 是 vue 实例 // _c是创建 vnode的方法 const _c = _vm._self._c // _s是转成字符串的方法 const _s = _vm._self._s return _c(&#x27;div&#x27;,_s(_vm.msg))&#125; 可以看出来 render函数的 this指向的就是vm._renderProxy，也就是 vue实例。 然后通过 vm.xxx 访问实例上的属性时就可以触发代理上的定义的捕获器逻辑。 2.3 模板渲染的几种情况在我们了解捕获器中的详细逻辑前，我们需要了解编写Vue渲染中的三种情况。 知道对应的代码处理的是哪些场景有助于我们更好的了解源码。 2.3.1 用户自定义 template 模板12345678new Vue(&#123; template:`&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; msg:&#x27;Hello World&#x27; &#125; &#125;&#125;).$mount(&quot;#app&quot;); 对template选项进行模版编译是发生在实例的挂载阶段。 所以在初始化时，选项中只有 template标签。 经过选项合并后，vm.$options上只有 template选项并没有 render方法。 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是hasHandler方法。 hasHandler方法中使用的是has捕获器，has捕获器用于处理属性的存在性检查。 vue在对template选项进行模板编译时，会将其转化为 render函数，且会被 with包裹。 而前面我们说过has捕获器可以拦截 with语句下的作用。在执行 with语句的过程中，该作用域下的变量都会触发 has钩子。这也是模版渲染时之所以会触发代理拦截的原因。 2.3.2 使用.vue文件来编写页面这也是我们编写 vue项目中最常用的写法。 1234567891011121314151617// Test.vue&lt;template&gt; &lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; msg: &quot;Hello World&quot; &#125; &#125;&#125;;&lt;/script&gt; .vue文件在webpack预编译阶段会被 vue-loader 解析成一个对象，其中模板部分会被解析成render函数。 并且在会在render方法中挂载_withStripped为true。 所以这个变量标识着当前的 render函数是使用.vue文件编写编译而来的。 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是getHandler方法。 getHandler方法中使用的是get捕获器，get捕获器用于处理对 Vue 实例属性的读取操作。 webpack + vue-loader对.vue文件进行编译时，会转化成下面这种形式。 可以看到直接使用 vm.xxx 访问的属性。所以可以使用 get捕获器进行捕获。 2.3.3 用户自定义 render方法来编写页面123456789101112131415161718// main.jsimport Fun from &quot;./Fun.js&quot;; new Vue(Fun).$mount(&quot;#app&quot;);// fun.jslet Component = &#123; render:function(h)&#123; return h(&#x27;div&#x27;,this.msg) &#125;, data()&#123; return &#123; msg:&#x27;Hello World&#x27; &#125; &#125;&#125;export default Component; 虽然这种情况在也存在 render方法，但是并没有 _withStripped 属性 所以这种情况在执行initProxy方法对目标对象实例 vm 进行代理时，注册的是hasHandler方法。 但是自定义 render的情况并没有使用 in或者 with的情况。 所以用户自定义的方法不会有报错提示。 2.4 捕获器里面的具体逻辑前面我们说到了三种情况都有对应的捕获方法。 那么这个捕获方法内部究竟做了些什么操作呢？ 主要是在开发者开发时对属性和方法的定义做提示。 当开发者在渲染内容中使用了_作为变量名的前缀时，提示不可以使用这种命名方式。因为这种方式可能会与内部的变量存在冲突。 当开发者在渲染内容中使用了未定义的变量时，提示该变量并没有在 vue实例上找到。 而前面我们说到了用户自定义的方法不会有报错提示。 我们可以实验一下： 12345678910111213141516171819// main.jsimport Fun from &quot;./Fun.js&quot;; new Vue(Fun).$mount(&quot;#app&quot;);// fun.jslet Component = &#123; render:function(h)&#123; // 使用了未定义的变量 return h(&#x27;div&#x27;,this.msg1) &#125;, data()&#123; return &#123; msg:&#x27;Hello World&#x27; &#125; &#125;&#125;export default Component; 我们在render方法中使用了一个未使用的变量 msg1。 然后打开控制台并没有报错提示。 因为此时代理使用的是has捕获器，而我们既没有使用 with，也没使用 in。 那么有没有解决办法呢？ 有，那就是在 render上挂载一个_withStripped变量，让他在 initProxy时注册 get捕获器。 12345678910111213let Component = &#123; render:function(h)&#123; return h(&#x27;div&#x27;,this.msg1) &#125;, data()&#123; return &#123; msg:&#x27;Hello World&#x27; &#125; &#125;&#125;// 在 render方法中挂载_withStripped属性Component.render._withStripped = true;export default Component; 可以看到控制台出现了报错信息。 三、实现简易版vue依赖收集因为Vue中数据响应式的代码比较多，涉及多个文件。 但是我们知道数据响应式的原理就是页面渲染访问数据时收集依赖，在数据更新时更新对应依赖的渲染内容。 123456789101112131415161718192021222324252627282930313233343536373839404142// =================== 新增点击事件更改 ===================const btnElement = document.createElement(&#x27;button&#x27;);document.body.appendChild(btnElement);btnElement.innerHTML = &#x27;点击&#x27;;btnElement.onclick = function()&#123; // 点击事件 PageA.msg = &#x27;我修改了&#x27;&#125;// =================== 增加属性监听 ===================// 存储页面的依赖let Dep = undefined;// A页面let PageA = &#123; msg:&#x27;Hello World&#x27;, render()&#123; const appElement = document.getElementById(&#x27;app&#x27;); // 当访问 msg变量时 会触发数据代理的 get方法 进行依赖收集 appElement.innerHTML = this.msg; &#125;&#125;let pageMsg = PageA.msg;Object.defineProperty(PageA,&#x27;msg&#x27;,&#123; get()&#123; //访问msg变量时执行 console.log(&quot;访问了 msg变量&quot;) // 将依赖设置为页面 A Dep = PageA; return pageMsg; &#125;, set(newVal)&#123; //设置msg变量时执行 console.log(&quot;设置了 msg变量&quot;) pageMsg = newVal; // 执行依赖的 render方法 Dep.render(); &#125;&#125;)// 执行渲染函数PageA.render(); 把上面的代码拷贝到浏览器中。 这些代码非常好理解，也非常简单，这就是 Vue中最核心的原理响应式。 如果你完全看懂并能理解以后，可以说你就掌握了 Vue的响应式核心原理。 四、初始化时增加侦听器的逻辑4.1 initData上一节中我们简单的实现了数据响应。 我们知道数据响应的前提是数据被代理了，也就是说数据被 Object.defineProperty 设置了侦听。 这样在数据被访问和设置的时候才能知晓从而触发对应的操作。 Vue选项中的 data就是在 vue实例化初始化的时候在initData中设置监听的。 123456789101112131415161718192021222324252627282930313233343536373839function initData(vm)&#123; let data = vm.$options.data; data = vm._data = isFunction(data) ? getData(data, vm) : data || &#123;&#125;; // 如果不是一个对象，进行提示 if (!isPlainObject(data)) &#123; data = &#123;&#125; __DEV__ &amp;&amp; warn( &#x27;data functions should return an object: &#x27; + &#x27;https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (__DEV__) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn(`Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; __DEV__ &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; const ob = observe(data) ob &amp;&amp; ob.vmCount++&#125; initData在 mergeOptions后面执行，所以此时可以在 vm.$options上获取到 data。 4.1.1 编写data的 2 种形式我们知道通常我们编写 data有 2 种形式： 1234567891011// 直接编写对象data:&#123; msg:&#x27;Hello World&#x27;&#125;// 编写一个函数data()&#123; return &#123; msg:&quot;Hello World&quot; &#125;&#125; 所以这里判断是否是函数用来执行不同的逻辑获取 data: 如果是函数，执行getData来获取 data 如果不是函数，这直接获取 data 12345678910111213141516let data = vm.$options.data; data = vm._data = isFunction(data) ? getData(data, vm) : data || &#123;&#125;;// 将当前依赖变成 undefined，在收集依赖时就可以判断是否是空的 如果是空的就不进行依赖收集export function getData(data: Function, vm: Component): any &#123; // #7573 disable dep collection when invoking data getters pushTarget() try &#123; return data.call(vm, vm) &#125; catch (e: any) &#123; handleError(e, vm, `data()`) return &#123;&#125; &#125; finally &#123; popTarget() &#125;&#125; 4.1.2 判断 data是否是对象123456789if (!isPlainObject(data)) &#123; data = &#123;&#125; __DEV__ &amp;&amp; warn( &#x27;data functions should return an object: &#x27; + &#x27;https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm )&#125; isPlainObject函数用于判断是否是一个对象。 如果 data不是一个对象，则提示应该返回一个对象。 4.1.3 判断不能与methods&#x2F;props重名12345678910111213141516171819202122const keys = Object.keys(data)const props = vm.$options.propsconst methods = vm.$options.methodslet i = keys.lengthwhile (i--) &#123; const key = keys[i] if (__DEV__) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn(`Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; __DEV__ &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125;&#125; 首先使用 Object.keys获取所有data的数量。 然后使用 while循环将所有 data中的key值和 props&#x2F;methods做比较。 如果有重名的则给予提示。 4.1.4 给 data中每一项都设置代理12345678910111213141516171819202122// 如果不是关键字，则对 vm._data进行保留if (!isReserved(key)) &#123; proxy(vm, `_data`, key)&#125;const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop&#125;export function proxy(target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter() &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter(val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 前面我们将data赋值给了vm._data。 所以这里代理的意思就是，每当你使用 this.xxx来访问data中的属性时，会直接在 vm._data上面进行查找返回。 这样就不用将data中的每一项都挂载到实例上了。 4.1.5 对data进行侦听接下来就是重头戏了，前面我们说到vue在初始化时会对 data中的每一项进行侦听。 就是使用 observe方法进行侦听的。 1const ob = observe(data); observe 是一个函数，用于将一个普通的 JavaScript 对象或数组转换为响应式对象。它会递归地遍历对象的所有属性，并将它们转换为 getter&#x2F;setter，以便 Vue 能够跟踪属性的变化。 可以看到observe就是实例化了一个 Observer的类。 4.2 Observer类中设置侦听1234567891011121314151617181920export function observe( value, shallow, ssrMockReactivity)&#123; if (value &amp;&amp; hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; return value.__ob__ &#125; if ( shouldObserve &amp;&amp; (ssrMockReactivity || !isServerRendering()) &amp;&amp; (isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value.__v_skip /* ReactiveFlags.SKIP */ &amp;&amp; !isRef(value) &amp;&amp; !(value instanceof VNode) ) &#123; return new Observer(value, shallow, ssrMockReactivity) &#125;&#125; 上节我们说到在initData中会调用observe方法给data设置侦听。 如上所示，observe中实际上就是实例化了 Observer类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export class Observer &#123; // 一个 Dep 实例，用于依赖收集，即跟踪哪些 watcher 依赖于该对象的数据变化。 dep: Dep // 记录有多少个 Vue 实例将这个对象作为它们的根 $data。 vmCount: number // number of vms that have this object as root $data constructor(public value: any, public shallow = false, public mock = false) &#123; // this.value = value this.dep = mock ? mockDep : new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (isArray(value)) &#123; if (!mock) &#123; if (hasProto) &#123; /* eslint-disable no-proto */ ;(value as any).__proto__ = arrayMethods /* eslint-enable no-proto */ &#125; else &#123; for (let i = 0, l = arrayKeys.length; i &lt; l; i++) &#123; const key = arrayKeys[i] def(value, key, arrayMethods[key]) &#125; &#125; &#125; if (!shallow) &#123; this.observeArray(value) &#125; &#125; else &#123; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ const keys = Object.keys(value) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock) &#125; &#125; &#125; /** * Observe a list of Array items. */ observeArray(value: any[]) &#123; for (let i = 0, l = value.length; i &lt; l; i++) &#123; observe(value[i], false, this.mock) &#125; &#125;&#125; 这个 Observer 类是 Vue.js 响应式系统的一部分，用于将普通的 JavaScript 对象或数组转换为响应式对象。 4.2.1 三个参数 value：它必须是一个数组或者对象。Observe类会将这个值转换为响应式对象，使得 Vue能够跟踪其属性的变化并更新视图。 shallow：这是一个布尔值，表示是否进行浅层响应式转换。如果 shallow 为 true，则 Observer 只会对对象的直接属性进行响应式转换，而不会递归地对其嵌套对象的属性进行响应式转换。 mock：这个参数也是布尔类型，用于指示是否在服务端渲染（SSR）环境下模拟响应式行为。当 mock 为 true 时，Observer 会使用一个特殊的 Dep 实例（mockDep），以便在服务端渲染时不会实际触发视图更新。 4.2.2 类成员 dep: Dep：每个Observer实例都有一个与之关联的Dep实例。Dep代表“Dependency”，用于存储所有依赖于该Observer实例的观察者（如计算属性或渲染函数）。 vmCount: number：表示有多少个Vue实例将此对象作为根$data对象。这有助于Vue内部管理数据的生命周期。 4.2.3 构造函数内部逻辑 初始化依赖：如果处于 ssr渲染模式下，使用传入的 mockDep，否则创建一个新的 Dep实例。 定义观测标识：def是 defineProperty的封装函数，通过def方法给value对象添加一个不可枚举的属性__ob__，其值为当前Observer实例。这是Vue内部用来判断一个对象是否已经被观测过的方式。 处理数组：如果value是一个数组且不是模拟模式： 如果环境支持__proto__，则将数组的方法指向arrayMethods，这是一个经过修改的数组原型方法集合，用于拦截数组的变异方法（如push, pop等）。 如果不支持__proto__，则手动遍历arrayKeys，并用def方法覆盖原生数组方法，使其指向arrayMethods中的对应方法。 如果不是浅层观测，则调用observeArray方法递归地观测数组中的每一个元素。 处理对象：如果value是一个对象，则遍历对象的所有键，并对每个键调用defineReactive方法来转换成getter&#x2F;setter形式，从而实现响应式。 4.3 defineReactive定义响应式调用 Observer 方法最终会调用 defineReactive方法对 data中的每一项进行添加侦听。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687export function defineReactive( obj: object, key: string, val?: any, customSetter?: Function | null, shallow?: boolean, mock?: boolean, observeEvenIfShallow = false) &#123; const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ( (!getter || setter) &amp;&amp; (val === NO_INITIAL_VALUE || arguments.length === 2) ) &#123; val = obj[key] &#125; let childOb = shallow ? val &amp;&amp; val.__ob__ : observe(val, false, mock) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; if (__DEV__) &#123; dep.depend(&#123; target: obj, type: TrackOpTypes.GET, key &#125;) &#125; else &#123; dep.depend() &#125; if (childOb) &#123; childOb.dep.depend() if (isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return isRef(value) &amp;&amp; !shallow ? value.value : value &#125;, set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val if (!hasChanged(value, newVal)) &#123; return &#125; if (__DEV__ &amp;&amp; customSetter) &#123; customSetter() &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else if (getter) &#123; // #7981: for accessor properties without setter return &#125; else if (!shallow &amp;&amp; isRef(value) &amp;&amp; !isRef(newVal)) &#123; value.value = newVal return &#125; else &#123; val = newVal &#125; childOb = shallow ? newVal &amp;&amp; newVal.__ob__ : observe(newVal, false, mock) if (__DEV__) &#123; dep.notify(&#123; type: TriggerOpTypes.SET, target: obj, key, newValue: newVal, oldValue: value &#125;) &#125; else &#123; dep.notify() &#125; &#125; &#125;) return dep&#125; 4.3.1 创建依赖首先会创建一个新的 Dep实例 dep,用于存储所有依赖于该属性的观察者。 在Observer的构造函数中，会遍历对象中的每一个属性，并对每一个属性执行defineReactive。 所以说每一个定义在 data中的每一个属性都有一个自己的依赖列表，记录着当 data变化时需要更新的依赖。 1234567891011export function defineReactive( obj: object, key: string, val?: any, customSetter?: Function | null, shallow?: boolean, mock?: boolean, observeEvenIfShallow = false) &#123; const dep = new Dep()&#125; 4.3.2 检查属性配置1234const property = Object.getOwnPropertyDescriptor(obj, key)if (property &amp;&amp; property.configurable === false) &#123; return&#125; 因为后面的逻辑是给这个对象设置代理（Object.defineProperty）。 getOwnPropertyDescriptor可以获取对象上的属性描述符。 如果该属性不可配置，就不可以再配置 Object.defineProperty了，所以如果 configurable为 false,直接返回，不做任何处理。 4.3.3 用于处理对象属性的 getter 和 setter12345678const getter = property &amp;&amp; property.getconst setter = property &amp;&amp; property.setif ( (!getter || setter) &amp;&amp; (val === NO_INITIAL_VALUE || arguments.length === 2)) &#123; val = obj[key]&#125; 尝试从对象的属性描述符（property）中获取现有的 getter 和 setter 函数。如果 property 存在且有 get 方法，则 getter 会被设置为该方法；同理，如果 property 存在且有 set 方法，则 setter 会被设置为该方法。 如果满足下列两种情况，则将 val设置为对象上当前属性的值，即 obj[key]。这意味着如果属性已经有 getter&#x2F;setter 或者没有提供初始值，Vue 将不会尝试覆盖这些属性，而是使用对象上已经存在的值。 检查是否存在 setter或者不存在 getter。如果属性已经有 setter(或者没有 getter)，这意味着属性可能已经被定义为具有自定义行为的属性，因此 Vue不会覆盖它。(前面我们使用过 proxy对 vm上的属性做过代理，而这里是对 data中的数据做代理，所以作用点不同) 检查传入的 val 是否是 NO_INITIAL_VALUE（一个特殊的值，表示没有初始值）或者调用 defineReactive 时只提供了两个参数（即没有提供 setter 值） 这段代码的目的是处理那些可能已经有预定义 getter&#x2F;setter 的属性。在 Vue 的响应式系统中，当你尝试将一个属性转换为响应式时，如果该属性已经有 getter&#x2F;setter，Vue 通常不会覆盖它们，除非你明确提供了一个新的值。这样做是为了避免破坏已经存在的属性行为。 4.3.4 观测子属性1let childOb = shallow ? val &amp;&amp; val.__ob__ : observe(val, false, mock) shallow 是一个布尔值参数，表示是否进行浅层响应式转换。如果为 true，则只对对象的直接属性进行响应式转换，而不递归地对其嵌套对象的属性进行响应式转换。默认为false，即递归的对嵌套对象的属性进行响应式转换。 val是当前正在处理的对象属性的值。 val.__ob__是一个检查，用于确定 val 是否已经被 Vue 的响应式系统转换过。如果一个对象已经被转换为响应式对象，Vue 会在该对象上添加一个 ob 属性，其值为对应的 Observer 实例。 这行代码的作用是根据 shallow 参数的值来决定是否需要对对象的值进行递归的响应式转换。如果 shallow 为 true，则只使用现有的响应式对象（如果存在），否则会创建一个新的响应式对象。这种方式允许 Vue 在不同场景下灵活地处理对象的响应式转换，同时避免了不必要的性能开销。 4.3.5 定义 getter 和 setter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; if (__DEV__) &#123; dep.depend(&#123; target: obj, type: TrackOpTypes.GET, key &#125;) &#125; else &#123; dep.depend() &#125; if (childOb) &#123; childOb.dep.depend() if (isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return isRef(value) &amp;&amp; !shallow ? value.value : value &#125;, set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val if (!hasChanged(value, newVal)) &#123; return &#125; if (__DEV__ &amp;&amp; customSetter) &#123; customSetter() &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else if (getter) &#123; // #7981: for accessor properties without setter return &#125; else if (!shallow &amp;&amp; isRef(value) &amp;&amp; !isRef(newVal)) &#123; value.value = newVal return &#125; else &#123; val = newVal &#125; childOb = shallow ? newVal &amp;&amp; newVal.__ob__ : observe(newVal, false, mock) if (__DEV__) &#123; dep.notify(&#123; type: TriggerOpTypes.SET, target: obj, key, newValue: newVal, oldValue: value &#125;) &#125; else &#123; dep.notify() &#125; &#125;&#125;) function dependArray(value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] if (e &amp;&amp; e.__ob__) &#123; e.__ob__.dep.depend() &#125; if (isArray(e)) &#123; dependArray(e) &#125; &#125; &#125; 4.3.5.1 getter函数在Vue执行渲染时，会访问 data中的属性，从而执行这里定义的 reactiveGetter方法。 如果存在原始的 getter（数据从 Object.defineProperty定义），则调用它。否则，返回属性的值 val。 Dep.Target是一个全局属性，因为每次只能同时执行一次渲染，每次渲染时都会对应一个 Watcher实例。 在每次渲染前都会将 Dep.Target设置为当前的这个 Watcher实例，然后在渲染后会将 Dep.Target设置为空。 所以这个 Dep.Target指的就是当前渲染对应的那个 Watcher实例。 此时调用dep.depend收集依赖。 如果有子属性，则调用子属性的 dep.depend方法。 如果属性值是数组，递归地依赖数组中的每个元素。 最后，如果属性值是一个 ref 对象（Vue 3 引入的响应式引用类型），并且不是浅层响应式，则返回其内部值；否则返回原始值。 4.3.5.2 setter函数当属性被重新赋值时，如 this.xxxx = xxx。会执行 reactiveSetter 方法。 如果新值与旧值相同，则不进行任何操作。 在开发模式下，如果提供了自定义的 setter，则调用它。 如果存在原始的 setter，则调用它。 如果没有 setter 但有 getter，不进行任何操作，这可能是一个只读属性。 如果属性值是 ref 对象，并且不是浅层响应式，则更新其内部值。 否则，直接更新属性的值。 因为值发生了变化，所以需要再次设置新值为响应式。 最后通知所有依赖于该属性的 watcher，属性值已改变。 然后再次执行渲染操作。 4.4 总结在前面的内容中，我们带大家看了 vue 是如何设置侦听的。 主要是通过 observe来将数据设置为响应式。 五、数据响应式的核心模块经过前面的学习，我们知道: Vue中每一个 data中都绑定了一个对应的依赖列表。 Vue中每一次 渲染都对应着一个 Watcher实例，这个 Watcher实例上存储着可以执行这次渲染的方法。 Vue实现数据响应式就是通过数据访问时在数据对应的依赖列表中增加当前渲染的 Watcher实例，然后在数据修改时通知依赖中存储的 Watcher实例需要再次执行对应的渲染方法。 其中的依赖和Watcher是单独的模块，我们这几会对这 2 个主要模块进行分析讲解。 5.1 Dep模块Dep表示依赖类，每一个 data中都会绑定一个 Dep实例 dep。 在访问数据时，会调用dep上的 depend方法进行依赖收集。 5.1.1 Dep.Target123456789101112Dep.target = nullconst targetStack: Array&lt;DepTarget | null | undefined&gt; = []export function pushTarget(target?: DepTarget | null) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget() &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 每一次渲染都对应着一个 Watcher实例，实际上渲染是 Watcher实例中的一部分。 Dep.target 是一个静态属性，用于存储当前正在执行渲染的 Watcher 实例。 每次在渲染前都会调用 pushTarget 将 Dep.Target设置为当前执行渲染的 Watcher实例。 然后在渲染完成后会调用 popTarget 将 Dep.target 设置为空。 12345678910111213class Watcher&#123; constructor()&#123; this.initRender(); &#125; initRender()&#123; // 渲染前设置Dep.target为当前 Watcher实例 pushTarget(this); // 渲染 render() // 渲染后设置Dep.target为空 popTarget(); &#125;&#125; 所以在渲染时触发数据的getter逻辑收集依赖时可以通过 Dep.target获取当前渲染对应的 Watcher实例并添加到依赖数组中。 5.1.2 subs集合Dep类维护了一个 subs集合，用于存储所有依赖于该属性的 Watcher实例。 每当用户访问数据时，因为可以通过 Dep.Target获取到本次渲染对应的 Watcher实例。 所以就可以将Watcher实例添加进 subs集合上，以便后续的使用。 5.1.3 depend方法12345678910111213141516171819202122//======================= Dep类====================depend(info?: DebuggerEventExtraInfo) &#123; // 当前渲染对应的 watcher if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;addSub(sub: DepTarget) &#123; this.subs.push(sub)&#125;//======================= Watcher类================ addDep(dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; 在数据访问时，会调用数据对应的 Dep实例上的 depend方法，进而执行 Watcher实例上的 addDep方法。 而在Watcher实例上的 addDep方法中最终又会调用 Dep实例上的 addSub方法。 然后再在Dep实例上的subs集合上添加Watcher实例。 你可能会有疑问，为什么不直接地将当前 Watcher实例添加到 subs中呢，而是要绕这么一大圈呢？ dep中不会存在重复的 watcher，同时 watcher中不会存在相同的 dep 5.1.3.1 去重机制通过 Watcher 的 addDep 方法，可以在 Watcher 级别进行去重。这样可以确保同一个 Dep 不会多次添加相同的 Watcher，从而避免不必要的重复依赖。 12345678910addDep(dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; newDepIds 和 newDeps：这两个集合用于记录当前收集周期中新添加的依赖。newDepIds 是一个 Set，用于快速查找是否已经添加过某个 Dep；newDeps 是一个数组，用于存储新添加的 Dep 实例。 depIds：这是一个 Set，用于记录已经存在的依赖。如果 depId 不在 depIds 中，说明这是第一次添加该依赖，因此调用 dep.addSub(this) 将 Watcher 添加到 Dep 的 subs 集合中。 5.1.3.2 有哪些需要去重的场景5.1.3.2.1 去重场景一：多次访问同一个响应式属性当一个组件在同一个渲染周期内多次访问同一个响应式属性时，可能会导致重复添加 Watcher。例如，在模板中多次引用同一个数据属性： 12345678910111213141516&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: &#x27;Hello, Vue!&#x27; &#125;; &#125;&#125;;&lt;/script&gt; 在这个例子中，message 被引用了两次。如果不进行去重处理，每次访问 message 都会尝试添加一个新的 Watcher。 5.1.3.2.2 去重场景二：计算属性和侦听器的多重依赖计算属性和侦听器（watch）可能会依赖多个响应式属性，如果这些属性在同一个渲染周期内被多次访问，也可能导致重复添加 Watcher。 12345678910111213computed: &#123; fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;&#125;,watch: &#123; firstName() &#123; console.log(&#x27;firstName changed&#x27;); &#125;, lastName() &#123; console.log(&#x27;lastName changed&#x27;); &#125;&#125; 如果 fullName 计算属性在同一个渲染周期内被多次访问，firstName 和 lastName 会被多次依赖，如果没有去重处理，可能会导致重复的 Watcher。 5.1.3.2.3 去重场景三：组件的生命周期钩子在组件的生命周期钩子中，如果多次访问同一个响应式属性，也可能会导致重复添加 Watcher。 1234mounted() &#123; console.log(this.message); console.log(this.message);&#125; 5.1.3.2.4 去重场景四：动态组件和条件渲染在动态组件和条件渲染中，如果同一个响应式属性在不同的条件分支中被多次访问，也可能导致重复添加 Watcher。 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;component :is=&quot;currentComponent&quot; /&gt; &lt;p v-if=&quot;showMessage&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p v-else&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; currentComponent: &#x27;ComponentA&#x27;, showMessage: true, message: &#x27;Hello, Vue!&#x27; &#125;; &#125;&#125;;&lt;/script&gt; 5.1.4 notify方法notify 方法是 Dep 类中的一个重要方法，用于在数据变化时通知所有依赖于该数据的 Watcher 实例。 这个方法确保所有相关的 Watcher 都能接收到数据变化的通知，并触发相应的更新操作。 123456789101112131415161718192021notify(info?: DebuggerEventExtraInfo) &#123; // stabilize the subscriber list first const subs = this.subs.filter(s =&gt; s) as DepTarget[] if (__DEV__ &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; const sub = subs[i] if (__DEV__ &amp;&amp; info) &#123; sub.onTrigger &amp;&amp; sub.onTrigger(&#123; effect: subs[i], ...info &#125;) &#125; sub.update() &#125;&#125; 5.1.4.1 去掉空值1const subs = this.subs.filter(s =&gt; s) as DepTarget[] 这一步是为了确保 subs 列表中没有 null 或 undefined 的值。filter(s &#x3D;&gt; s) 会过滤掉所有非真值的项。 5.1.4.2 排序订阅者（仅在开发模式下且未异步运行时）123456if (__DEV__ &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id)&#125; DEV 是一个环境变量，表示当前是否处于开发模式。 config.async 是一个配置选项，表示是否异步执行更新。 如果处于开发模式且未异步运行，subs 列表需要按 id 排序，以确保 Watcher 按正确的顺序触发更新。这是因为异步调度器会自动处理排序，而在同步模式下需要手动排序。 5.1.4.3 通知每个订阅者1234567891011for (let i = 0, l = subs.length; i &lt; l; i++) &#123; const sub = subs[i] if (__DEV__ &amp;&amp; info) &#123; sub.onTrigger &amp;&amp; sub.onTrigger(&#123; effect: subs[i], ...info &#125;) &#125; sub.update()&#125; 遍历 subs 列表，逐个通知每个 Watcher。 如果处于开发模式且提供了 info，调用 sub.onTrigger 方法，传递调试信息。 最终调用 sub.update() 方法，触发 Watcher 的更新操作。 5.2 Watcher模块5.2.1 将渲染函数挂载到实例上在上一章节中，我们初次渲染时会实例化一个 watcher实例。 然后将渲染的方法传入 watcher实例中。 然后就会执行对应的渲染方法。 所以可以想到渲染的逻辑应该是写在了 Watcher类的构造器中。 1234567891011// 初次渲染时 new Watcher(渲染函数)class Watcher&#123; constructor(渲染函数)&#123; this.渲染函数 = 渲染函数; // 执行渲染 this.渲染函数(); &#125;&#125; 当然源码中实际上不仅仅这么简单。 1234567891011// 初次渲染时 new Watcher(渲染函数)class Watcher&#123; constructor(渲染函数)&#123; this.渲染函数 = 渲染函数; // 执行渲染 this.渲染函数(); &#125;&#125; 源码中将渲染函数挂载到了 getter上。 1this.getter = expOrFn 然后在 get方法中调用 getter方法。 在 get方法中设置 Dep.target为当前的 watcher。 1234567891011121314151617181920212223get() &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e: any) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; 5.2.2 update方法在数据被访问时，会调用 dep.notify通知依赖需要更新渲染，然后调用 watcher.update。 然后会调用 run方法，最后调用 get方法重新执行渲染方法。 六、总结这一篇中我们详细解释了数据响应式相关的原理。 一句话就是在数据访问时收集依赖，在数据被修改时更新依赖"},{"title":"🔥Vue2初次渲染流程","path":"//posts/vue2-init-render.html","content":"&nbsp; 返回 专栏第七篇-初次渲染流程 上篇我们介绍了Vue渲染的基础-虚拟DOM。 在渲染阶段，Vue通过虚拟 DOM来创建元素。 一、编译时的挂载操作在专栏第四篇中，我们提到了在Vue实例化时，会执行init函数来初始化一些后续需要的选项。 通常在实例化后我们会执行挂载操作。 而搜索源码可以发现，$mount方法被定义了 2 次。 根据是否需要模版编译，存在 2 个$mount方法。 在模板编译版本的 Vue中，重写了运行时的$mount方法，其中添加了一些模板编译的方法。 模板编译意为将 template转化成 render函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; __DEV__ &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (__DEV__ &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (__DEV__) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; // @ts-expect-error template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; outputSourceRange: __DEV__, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this ) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 首先获取传入el参数，也就是挂载的节点。 然后判断挂载节点是否是body节点或者html节点，如果是则提示无法挂载并返回。 如果没有render方法，获取template选项。 如果存在 template选项： template是一个选择节点字符串(#app)，将template变量设置为节点字符串对应的HTML代码。 template是一个真实DOM节点，将template变量设置为节点对应的HTML代码。 如果都不是，则会提示无效的template选项。 如果不存在 template选项，但是有 el节点，则将template变量设置为el节点对应的 HTML代码。 获取到对应的模板，然后将这个将这个模板转换成 render函数 如果有render方法，直接执行 mount方法，也就是运行时定义的$mount方法。 二、运行时的挂载操作上面我们说到编译时的$mount方法将模板转换成了render方法。 然后调用了运行时的$mount方法。 让我们来看看$mount方法都做了什么操作。 1234567Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 我们可以看到就是获取节点，然后调用了mountComponent方法。 三、mountComponent可以看出来最终执行了mountComponent方法。 我们把目光移到mountComponent方法中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798export function mountComponent( vm: Component, el: Element | null | undefined, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; // @ts-expect-error invalid type vm.$options.render = createEmptyVNode if (__DEV__) &#123; /* istanbul ignore if */ if ( (vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el ) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ) &#125; else &#123; warn( &#x27;Failed to mount component: template or render function not defined.&#x27;, vm ) &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;) let updateComponent /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; const watcherOptions: WatcherOptions = &#123; before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125; &#125; if (__DEV__) &#123; watcherOptions.onTrack = e =&gt; callHook(vm, &#x27;renderTracked&#x27;, [e]) watcherOptions.onTrigger = e =&gt; callHook(vm, &#x27;renderTriggered&#x27;, [e]) &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher( vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */ ) hydrating = false // flush buffer for flush: &quot;pre&quot; watchers queued in setup() const preWatchers = vm._preWatchers if (preWatchers) &#123; for (let i = 0; i &lt; preWatchers.length; i++) &#123; preWatchers[i].run() &#125; &#125; // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;) &#125; return vm&#125; 将传入的节点挂载 vm.$el上。 判断是否有 render方法。如果没有render方法则会赋予render方法一个创建空 VNode的方法以及提示否则。有则继续向下执行代码。 调用 beforeMount钩子 定义updateComponent方法，其中根据是否配置性能配置在该方法中打了一个性能 tag。 传入updateComponent方法并实例化 Watcher，在实例化时会执行传入的updateComponent方法。 判断$vnode是否有值，有值则调用 mounted方法。 至此我们已经完成了挂载阶段的源码阅读。 实际上 updateComponent 就是真正渲染和挂载节点的地方。 1updateComponent = vm._update(vm._render()) 我们来画个流程图来加深巩固一下整个渲染流程。 所以，我们现在可以很清楚的看出来。 Vue渲染大体上分为 2 步： 调用vm._render方法获取 vnode。 调用vm._update将获取到的 vnode渲染到页面上。 四、调用_render方法来获取 vnode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode &amp;&amp; vm._isMounted) &#123; vm.$scopedSlots = normalizeScopedSlots( vm.$parent!, _parentVnode.data!.scopedSlots, vm.$slots, vm.$scopedSlots ) if (vm._slotsProxy) &#123; syncSetupSlots(vm._slotsProxy, vm.$scopedSlots) &#125; &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode! // render self const prevInst = currentInstance const prevRenderInst = currentRenderingInstance let vnode try &#123; setCurrentInstance(vm) currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e: any) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (__DEV__ &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call( vm._renderProxy, vm.$createElement, e ) &#125; catch (e: any) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = prevRenderInst setCurrentInstance(prevInst) &#125; // if the returned array contains only a single node, allow it if (isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (__DEV__ &amp;&amp; isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode &#125; 可以看出来_render方法就是获取选项上的render函数并执行，就可以获取vnode了。 render函数的具体逻辑在上一章中我们也了解的差不多了。 就是通过内部的 createElement 函数来创建VNode。 五、调用_update方法来进行渲染_update方法被定义在lifecycleMixin方法中。 12345678910111213141516171819202122232425262728293031323334353637Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well let wrapper: Component | undefined = vm while ( wrapper &amp;&amp; wrapper.$vnode &amp;&amp; wrapper.$parent &amp;&amp; wrapper.$vnode === wrapper.$parent._vnode ) &#123; wrapper.$parent.$el = wrapper.$el wrapper = wrapper.$parent &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook. &#125; 5.1 通过vm._vnode来判断是否是初次渲染_update方法的执行直接有 2 个：1.初次渲染、2.更新渲染。color:orange。 在每次渲染时，会将当前传入的 vnode赋值给 vm._vnode。 而在做此操作前，会获取vm._vnode意味上一次渲染的 vnode。 那么在初次渲染时，prevVnode这个值是空的。 所以就可以根据这个值来判断是否是初次渲染。 如果是初次渲染，调用__patch__函数传入的第一个参数和第二个参数分别为 vm.$el、vnode。 如果是更新渲染，调用__patch__函数传入的第一个参数和第二个参数分别为 prevVnode、vnode。 5.2 vm.$el是什么vm.$el是在 mountComponent函数中赋值的。 也就是执行$mount方法中传入的挂载的节点。 1vm.$mount(&#x27;#app&#x27;) 所以初次渲染时，vm.$el就是真实的 DOM节点。 5.3 patch该方法是通过createPatchFunction函数来创建的。 所以 createPatchFunction函数返回了一个函数。 1export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;) nodeOps是浏览器操作DOM的相关方法。如删除 DOM、添加 DOM等。 modules中存在了一些处理 DOM 属性的方法。如设置样式等。 5.4 createPatchFunction5.4.1 第一个参数oldVNode和第二个参数vnode12345function createPatchFunction()&#123; return function patch(oldVnode,vnode)&#123; // xxx &#125;&#125; 可以看到该函数的第一个参数是oldVnode，第二个参数是 vnode。 oldVnode表示旧的 vnode。 Vue在更新渲染时，会进行双端 diff对比，这个时候需要获取旧的 vnode进行对比。 因为这个函数时初次渲染和更新渲染的通用函数。 而前面我们说到在处理渲染时传递的是 vm.$el，这代表挂载的节点。 所以对于初次渲染（将虚拟节点渲染到真实节点）来说，旧节点表示真实的节点。 实际上挂载节点相当于一个索引节点，会根据他的位置进行挂载节点，挂载节点在初次渲染后就会被删除。 5.4.2 处理旧节点的销毁如果旧的虚拟节点存在，但是新的虚拟节点不存在。 则表示该节点可能由于条件渲染（v-if）被移除，这时候调用invokeDestroyHook函数，确保旧节点被正确的销毁和清理。 如果新节点不存在，则终止当前的 patch操作。 这是因为没有新的节点需要渲染，所以没有必要继续执行更新 DOM的操作。 1234if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return&#125; 5.4.3 判断旧的vnode是否是真实节点因为在初次渲染时，旧的 vnode是挂载元素，也就是一个真实 DOM。 而 patch内部的处理基本上都是基于虚拟 DOM来处理的。 所以需要将真实 DOM通过emptyNodeAt函数包装成虚拟 DOM。 123function emptyNodeAt(elm) &#123; return new VNode(nodeOps.tagName(elm).toLowerCase(), &#123;&#125;, [], undefined, elm)&#125; 将虚拟节点的elm属性指向传入的dom节点。 5.4.4 createElm创建子节点初次渲染时，我们无需关心更新的逻辑。 只需要将最新的 vnode渲染到页面上即可。 直接调用 createElm方法。 5.4.4.1 创建DOM元素1234567891011121314151617181920212223export function createElm( vnode, parentElm, refElm)&#123; const tag = vnode.tag; const children = vnode.children; if(isDef(tag))&#123; vnode.elm = nodeOps.createElement(tag); createChildren(vnode, children); &#125;&#125;export function createChildren(vnode, children)&#123; if(isArray(children))&#123; createElm( children[i], vnode.elm, null ) &#125;&#125; 可以看到createElm方法中调用了document.createElement创建了 DOM元素并将创建的元素赋值给虚拟节点的 elm属性中。 5.4.4.2 执行 inset方法将创建的 DOM挂载到父节点上12345678910111213insert(parentElm, vnode.elm, refElm)function insert(parent, elm, ref) &#123; if (isDef(parent)) &#123; if (isDef(ref)) &#123; if (nodeOps.parentNode(ref) === parent) &#123; nodeOps.insertBefore(parent, elm, ref) &#125; &#125; else &#123; nodeOps.appendChild(parent, elm) &#125; &#125;&#125; 如果有 ref节点，则调用 insetBefore插入 ref节点之前。 否则调用 appendChild 直接插入数组最后面。 5.4.4.3 初次渲染时需要删除旧节点节点初次挂载后，需要将旧的节点给删除掉。 123456// destroy old nodeif (isDef(parentElm)) &#123; removeVnodes([oldVnode], 0, 0)&#125; else if (isDef(oldVnode.tag)) &#123; invokeDestroyHook(oldVnode)&#125; 六、总结我们这篇中简单介绍了初次挂载时的大概流程。 实际上就是通过浏览器的一些 API如createElement、appendChild来创建真实 DOM。 其中涉及到的一些细节并没有做详细阐述，比如说组件的处理，样式事件属性的注册等。 在后面的文章中我们会一一给大家解答。"},{"title":"🔥Vue2渲染基础-虚拟DOM","path":"//posts/vue2-vnode.html","content":"&nbsp; 返回 专栏第六篇-虚拟节点以及createElement函数 在前面的文章中，我们介绍了Vue初始化的一系列操作。 可以Vue终归只是为了画页面。 后面的章节就带着大家来解析渲染相关的逻辑，一步一步解析Vue是如何将模板挂载到页面上的。 但是在解析渲染之前，我们先来了解一下Vue框架渲染的基础-虚拟 DOM。 一、渲染器的渲染流程在讨论虚拟节点之前，我们先来了解一下浏览器渲染的流程。 当浏览器接收到一个 HTML 文件后，JavaScript 引擎与浏览器的渲染引擎随即开始运行。 从渲染引擎的角度来看，它首先会把 HTML 文件解析为一个 DOM 树。 与此同时，浏览器会识别并加载 CSS 样式，然后将其与 DOM 树合并，形成一个渲染树。 在有了渲染树之后，渲染引擎会计算所有元素的位置信息，最后通过绘制操作，在屏幕上呈现出最终的内容。 JavaScript 引擎和渲染引擎虽然处于两个独立的线程之中，然而 JavaScript 引擎却能够触发渲染引擎开始工作。 当我们借助脚本去更改元素的位置或者外观时，JavaScript 引擎会运用与 DOM 相关的 API 方法来操作 DOM 对象。 此时渲染引擎便开始运作，渲染引擎会触发回流或者重绘操作。 我们来了解下回流以及重绘的概念： 回流：当我们对DOM的修改引发了元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制出来，这个过程称为回流。 重绘：当我们对DOM的修改只单纯改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程称为重绘。 很显然，回流比起重绘更加消耗性能。 通过了解浏览器基本的渲染机制，我们不难联想到，当不断地通过 JavaScript 修改 DOM 时，很容易在不经意间触发渲染引擎的回流或者重绘，而这种操作所带来的性能开销是非常巨大的。 因此，为了降低性能开销，我们需要做的是尽可能地减少对 DOM 的操作。 虚拟节点就是在这种情况下孕育而生。 二. 缓冲层-虚拟DOM虚拟 DOM （Virtual DOM 以下简称 VDOM）是为了解决频繁操作 DOM 所引发的性能问题而产生的产物。 VDOM是把页面的状态抽象成 JS 对象的形式呈现。 从本质上来说，它处于 JS 与真实 DOM 之间，起着中间层的作用。 当我们需要使用 JS 脚本进行大批量的 DOM 操作时，会优先在虚拟 VDOM 这个 JS 对象上进行操作。 最后，通过对比找出将要改动的部分，并将这些改动通知并更新到真实的 DOM 上。 尽管最终仍然是对真实的 DOM 进行操作，然而虚拟 DOM 能够将多个改动合并为一个批量操作。 这样做可以减少 DOM 重排的次数，进而缩短生成渲染树以及进行绘制所花费的时间。 我们来看一下一个真实的 DOM 具体包含了哪些内容。 浏览器将真实的 DOM 设计得极为复杂。 它不但包含了自身的属性描述，如大小、位置等定义，还囊括了 DOM 所拥有的浏览器事件等内容。 正是由于其如此复杂的结构，我们频繁地去操作 DOM 或多或少会给浏览器带来性能方面的问题。 而作为数据与真实 DOM 之间的一层缓冲，虚拟 DOM 只是用于映射到真实 DOM 进行渲染，所以并不需要包含操作 DOM 的方法。 它只需在对象中重点关注几个属性就可以了。 三、 VNode12345678910111213141516171819// 真实DOM&lt;div id=&quot;app&quot;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;// 真实DOM对应的JS对象(VNode)&#123; tag:&#x27;div&#x27;, data:&#123; id:&#x27;app&#x27; &#125;, children:[&#123; tag:&#x27;span&#x27;, children:[ &#123; tag:undefined, text:&#x27;Hello World&#x27; &#125; ] &#125;]&#125; 通过上面的例子我们可以看出来每一个 DOM节点 都可以使用一个 VNode 来表示。 在 Vue内部，使用 VNode 这个构造函数去描述一个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export default class VNode &#123; tag?: string data: VNodeData | undefined children?: Array&lt;VNode&gt; | null text?: string elm: Node | undefined ns?: string context?: Component // rendered in this component&#x27;s scope key: string | number | undefined componentOptions?: VNodeComponentOptions componentInstance?: Component // component instance parent: VNode | undefined | null // component placeholder node // strictly internal raw: boolean // contains raw HTML? (server only) isStatic: boolean // hoisted static node isRootInsert: boolean // necessary for enter transition check isComment: boolean // empty comment placeholder? isCloned: boolean // is a cloned node? isOnce: boolean // is a v-once node? asyncFactory?: Function // async component factory function asyncMeta: Object | void isAsyncPlaceholder: boolean ssrContext?: Object | void fnContext: Component | void // real context vm for functional nodes fnOptions?: ComponentOptions | null // for SSR caching devtoolsMeta?: Object | null // used to store functional render context for devtools fnScopeId?: string | null // functional scope id support isComponentRootElement?: boolean | null // for SSR directives constructor( tag?: string, data?: VNodeData, children?: Array&lt;VNode&gt; | null, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child(): Component | void &#123; return this.componentInstance &#125;&#125; 我们可以使用 new 关键字来创建一个 VNode。 12345678// 创建一个div的 vnodenew VNode(&#x27;div&#x27;,&#123;&#125;,&#x27;Hello World&#x27;)// 创建一个有子节点的 vnodenew VNode(&#x27;div&#x27;,&#123;&#125;,[ new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;1&#x27;), new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;2&#x27;), new VNode(&#x27;span&#x27;,&#123;&#125;,&#x27;3&#x27;)]) VNode这个构造函数上有非常多的属性，这里我们先列举四个常用的属性：tag、data、children、text。 其余属性在我们后面的解析中会一一进行解析。 3.1 tag属性tag表示创建的虚拟节点的标签名称。 决定了最终会渲染成什么样的 DOM元素。 tag可以是 HTML 元素，比如字符串span、'div'。 也可以是一个组件引用，同样可以是一个动态标签。 123456789101112// 编译前（普通节点）&lt;div&gt;&lt;/div&gt; // 编译后VNode &#123; tag:&quot;div&quot;&#125;// 编译前（组件节点）&lt;CustomComponent&gt;&lt;/CustomComponent&gt; // 编译后VNode &#123; tag:&quot;CustomComponent&quot;&#125; 3.2 data属性data 参数通常是一个对象，包含了用于描述 VNode 的各种属性和配置信息。 data 参数可以由以下几种构成： attrs:表示元素的上静态属性，如src、alt等。 staicClass:表示元素上的静态css类。 style:表示元素上的内联样式。 on:表示元素上的事件监听器。 slot:表示作用域插槽或普通插槽的位置。 props:表示传递组件的 props 数据。 directives:表示添加的自定义的行为，如 v-model、v-show等。 key:表示组件唯一标识。 3.3 childrenchildren 参数是指定一个 VNode（虚拟节点）的子节点内容。 这个参数可以包含多种类型的数据，用于描述子节点的结构和内容。 3.4 text我们知道并不是每个节点都有tag的，比如文字节点就没有tag。 在Vue中，文字也代表一个vnode。 123456// 编译前&quot;我是&quot; // 编译后VNode &#123; text:&quot;我是&quot;&#125; 3.1.5 elm我们知道在渲染时会根据 VNode 创建DOM元素。 渲染后每个VNode节点都有对应的真实 DOM元素。 而这个 elm 就指向这个真实 DOM元素。 四. createElement函数经过上面的学习，我们知道虚拟DOM就是一个JS对象，只不过他有很多属性。 所示说创建一个虚拟DOM也绝不是什么难事，但是 Vue 框架给我们提供了一个函数createElement。 这个函数可以更方便的帮我们生成虚拟 DOM，在其中磨平了一些细节。 它被定义在 src/core/vdom/create-element.js 中： 4.1 createElement在开发时的使用场景了解createElement的使用场景有哪些对看源码是有一定的帮助的。 有场景带入源码才知道对应的逻辑是在做什么，否则你光看源码，对于一些逻辑你是无法看懂的。 4.1.1 webpack编译时使用Vue框架底层渲染时会调用实例上的_render方法，这个 render方法实际上就是调用了实例选项上的 render方法。 1vm._render =&gt; vm.$options.render 你可能会有些困惑，因为平时我们都是使用.vue文件进行单页面开发，没有写过什么 render方法啊，那这个 render方法是怎么来的呢？ 其实我们平时编写的 template模板标签在 webpack预编译阶段会变成一个创建vnode的函数。 比如我们在模版中编写一个简单的字符串： 123&lt;template&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/template&gt; .vue文件在webpack预编译时会解析成一个对象，而模板部分则会编译成 render函数。 所以平时我们import Test from &quot;./Test&quot;，这里的Test打印出来是一个对象。 我们再看一下这里编译的 render方法，发现没有使用 createElement函数来创建节点，而使用了_c。 那么这里的_c代表什么？ _c实际上是在 vue初始化时在initRender方法中注入的，本质上也就是调用了 createElement。 12// 第六个参数代表是否需要规范化子节点 这里表示不需要 因为 webpack 预编译时会编译子节点vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 4.1.2 用户自定义render方法我们知道.vue文件会被解析成一个对象的形式。 所以我们也可以自己写一个 js文件，自己定义 render方法。Vue提供了这种能力。 我们一般会这么自定义函数。 1234567&#123; render:(h)=&gt;&#123; return &#123; h(&#x27;div&#x27;,&#x27;hello world&#x27;) &#125; &#125;&#125; 而源码中会将 vm.$createElement传入 render方法中。 12345try &#123; vnode = render.call(vm._renderProxy, vm.$createElement)&#125; catch (e: any) &#123; ///&#125; 所以这里的 vm.$createElement就是h函数，也就是创建 VNode的函数。 $createElement和_c一样也是在vue初始化时在initRender方法中注入的。 12// 第六个参数是 true 表示需要处理子节点为 VNode节点vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) _c和$createElement的不同之处是$createElement中对于 createElement的第六个参数传递的值不同。 4.2 createElement函数解析123456789101112131415161718export function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType)&#125; createElement的参数分别是： 第一个参数为context：表示上下文，一般这里传递的是vue实例vm。 第二个参数为 tag：表示创建的虚拟节点的标签。 第三个参数为 data：表示创建的虚拟节点的数据。 第四个参数为 children：表示虚拟节点的子节点。 第五个参数为 normalizationType：这个参数决定规范化的类型。 第六个参数为 alwaysNormalize：表示是否规范化子节点。 createElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 _createElement。 4.2.1 对第二个参数做兼容1234// 存在 data的情况createElement(context,&#x27;div&#x27;,&#123;style:&#123;color:&quot;red&quot;&#125;&#125;,&#x27;hello world&#x27;) // 不存在 data的情况createElement(context,&#x27;div&#x27;,null,&#x27;hello world&#x27;) 如上，第三个参数表示 data，第四个参数表示children。 而很多时候，我们不需要传递 data属性，但是由于参数顺序的原因，依旧需要传递一个空对象来进行占位。 这个时候函数内部对这个参数进行了兼容处理。 判断如果第三个参数是数组或者原始类型（字符串，数字等），则将其第三个参数视为是传递的子节点。 同时将data置为undefined，normalizationType使用第四个参数。 因此我们可以这么调用，不用再使用一个占位符了。 12// 不存在 data的情况 不需要传递 data进行占位createElement(context,&#x27;div&#x27;,&#x27;hello world&#x27;) 4.2.2 对children的规范化由于VNode实际上是一个树状结构，每一个VNode可能会有若干个子节点，这些子节点应该也是 VNode 的类型。 _createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。 normalizationType的值有 2 种： SIMPLE_NORMALIZE：值为 1，表示简单处理子节点 ALWAYS_NORMALIZE：值为 2，表示递归处理所有子节点 需要注意的是对于用户手动创建render方法，normalizationType一直为ALWAYS_NORMALIZE。表示需要规范处理子节点。 因为用户有可能不是很熟悉 createElement的使用方式和 Vue的渲染机制导致一些错误情况的发生，如下： 12345678// 如果不进行处理，在渲染过程中极有可能会产生问题render(h)&#123; return h(&#x27;ul&#x27;,[ &quot;苹果&quot;, &quot;香蕉&quot;, &quot;梨&quot; ])&#125; 这里根据 normalizationType 的不同，分别调用了normalizeChildren(children) 和 simpleNormalizeChildren(children)方法。 它们的定义都在 src/core/vdom/helpers/normalzie-children.js 中： 4.2.2.1 simpleNormalizeChildren1234567891011121314151617181920// The template compiler attempts to minimize the need for normalization by// statically analyzing the template at compile time.//// For plain HTML markup, normalization can be completely skipped because the// generated render function is guaranteed to return Array&lt;VNode&gt;. There are// two cases where extra normalization is needed:// 1. When the children contains components - because a functional component// may return an Array instead of a single root. In this case, just a simple// normalization is needed - if any child is an Array, we flatten the whole// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep// because functional components already normalize their own children.export function simpleNormalizeChildren(children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (isArray(children[i])) &#123; return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125; 当 normalizationType 为 SIMPLE_NORMALIZE 时，才会调用simpleNormalizeChildren方法。 那么 normalizationType 何时才会是 SIMPLE_NORMALIZE呢？ 我们知道用户自定义 render函数的时候，normalizationType恒为ALWAYS_NORMALIZE，所以只有是在编译的时候在_c中才会将值变成 SIMPLE_NORMALIZE。 理论上编译生成的children都已经是 VNode类型了，不需要处理了才对。 但是有一种情况需要考虑，就是函数组件返回的是一个数组而不是一个根节点， 1234567export default &#123; functional: true, props: [&#x27;items&#x27;], render(h, &#123; props &#125;) &#123; return props.items.map(item =&gt; h(&#x27;li&#x27;, item)); &#125;&#125;; 此时需要将数组打平成一级。 4.2.2.2 normalizeChildren递归处理子节点1234567export function normalizeChildren(children: any): Array&lt;VNode&gt; | undefined &#123; return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : undefined&#125; normalizeChildren用在用户自定义render时对 children进行规范化，因为编译时已经将 children 都规范化为了createElement创建函数。 Vue允许用户把children写成基础类型用来创建单个简单的文本节点，对应这种场景，vue会调用 createTextVNode创建一个文本节点的 VNode，并且会转化成数组的形式。 1234567891011121314151617// 用户自定义 render函数export default &#123; render:function(h)&#123; return h(&#x27;div&#x27;,&#x27;Hello World&#x27;) &#125;&#125;// 生成的 VNodeVNode &#123; tag:&#x27;div&#x27;, // 将文字转化成了children数组 children:[ VNode &#123; tag: undefined, text: &#x27;Hello World&#x27; &#125; ]&#125; 如果 children是一个数组，需要递归处理 children，遍历每一个子节点，将每一个子节点转化为标准的 VNode，其中这个转化操作是使用normalizeArrayChildren函数来完成的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function normalizeArrayChildren( children: any, nestedIndex?: string): Array&lt;VNode&gt; &#123; const res: VNode[] = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) &#123; c = children[i] if (isUndef(c) || typeof c === &#x27;boolean&#x27;) continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (isArray(c)) &#123; if (c.length &gt; 0) &#123; c = normalizeArrayChildren(c, `$&#123;nestedIndex || &#x27;&#x27;&#125;_$&#123;i&#125;`) // merge adjacent text nodes if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) &#123; res[lastIndex] = createTextVNode(last.text + c[0].text) c.shift() &#125; res.push.apply(res, c) &#125; &#125; else if (isPrimitive(c)) &#123; if (isTextNode(last)) &#123; // merge adjacent text nodes // this is necessary for SSR hydration because text nodes are // essentially merged when rendered to HTML strings res[lastIndex] = createTextVNode(last.text + c) &#125; else if (c !== &#x27;&#x27;) &#123; // convert primitive to vnode res.push(createTextVNode(c)) &#125; &#125; else &#123; if (isTextNode(c) &amp;&amp; isTextNode(last)) &#123; // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) &#125; else &#123; // default key for nested array children (likely generated by v-for) if ( isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex) ) &#123; c.key = `__vlist$&#123;nestedIndex&#125;_$&#123;i&#125;__` &#125; res.push(c) &#125; &#125; &#125; return res&#125; 该函数的主要逻辑就是遍历children数组，获取每一项的数据类型，然后做相应处理。 如果是未定义&#x2F;null&#x2F;布尔值，直接跳过，不进行处理。 如果是数组类型，则递归调用normalizeArrayChildren。 如果是基础类型，则通过 createTextVNode方法转换成 VNode类型。 如果不是上面三种类型，则表示已经是 VNode类型了。 需要注意的是在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 text 节点，会把它们合并成一个 text 节点。 4.2.2.3 总结经过对 children的统一处理，现在 VNode已经是一个规范化的 VNode节点了。 4.3 VNode的创建经过兼容处理和 children规范化处理后，就可以创建VNode了。 4.3.1 非组件 VNode当 tag为字符串，且不是注册组件，则直接调用 VNode来创建 VNode。 tag是字符串一般有 2 种情况： 普通的HTML标签 1234567// 模板编译前&lt;template&gt; &lt;div&gt;Hello World&lt;/div&gt;&lt;/template&gt;// 模板编译后// _v表示createTextVNode 用作创建子节点_c(&#x27;div&#x27;,[_v(&#x27;Hello World&#x27;)]) 组件类型 1234567// 模板编译前&lt;template&gt; &lt;Component /&gt;&lt;/template&gt;// 模板编译后// _v表示createTextVNode 用作创建子节点_c(&#x27;Component&#x27;) 4.3.2 组件 VNode当 tag不是字符串或者字符串是注册组件的关键字，则表示需要创建一个组件VNode。此时调用 createComponent来创建组件VNode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110export function createComponent( Ctor: typeof Component | Function | ComponentOptions | void, data: VNodeData | undefined, context: Component, children?: Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor as typeof Component) &#125; // if at this stage it&#x27;s not a constructor or an async component factory, // reject. if (typeof Ctor !== &#x27;function&#x27;) &#123; if (__DEV__) &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component let asyncFactory // @ts-expect-error if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder(asyncFactory, data, context, children, tag) &#125; &#125; data = data || &#123;&#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor as typeof Component) // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; // @ts-expect-error transformModel(Ctor.options, data) &#125; // extract props // @ts-expect-error const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component // @ts-expect-error if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent( Ctor as typeof Component, propsData, data, context, children ) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier // so it gets processed during parent component patch. data.on = data.nativeOn // @ts-expect-error if (isTrue(Ctor.options.abstract)) &#123; // abstract components do not keep anything // other than props &amp; listeners &amp; slot // work around flow const slot = data.slot data = &#123;&#125; if (slot) &#123; data.slot = slot &#125; &#125; // install component management hooks onto the placeholder node installComponentHooks(data) // return a placeholder vnode // @ts-expect-error const name = getComponentName(Ctor.options) || tag const vnode = new VNode( // @ts-expect-error `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`, data, undefined, undefined, undefined, context, // @ts-expect-error &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode&#125; 创建组件 VNode时，会在 VNode新增一些组件特有的属性： 使用 Vue.extend生成一个子类构造器，会挂载到 VNode的componentsOptions属性的 Ctor上。 处理异步组件 处理 model 注入一些 hooks 等 4.4 createElement函数的优势createElement函数的意义在于它提供了一种更方便、更简洁且更具可读性的方式来创建vnode，相比直接编写 VNode 具有以下好处： 4.4.1 直观的参数形式使用createElement函数可以通过直观的参数来描述虚拟节点的属性。 相比之下，直接编写 VNode 对象时，需要手动构建一个包含多个属性的 JavaScript 对象，可能会导致代码较为冗长和复杂，降低了可读性和可维护性。 4.4.2 统一的创建方式在项目中使用createElement函数可以确保虚拟节点的创建方式一致。 直接编写 VNode 对象可能会导致不同的开发者采用不同的方式来构建虚拟节点，从而降低了代码的一致性和可维护性。 4.4.3 动态属性和条件判断createElement函数可以接收动态的参数，允许在运行时根据条件来决定虚拟节点的属性。例如，可以根据数据的变化动态地添加或修改属性，或者根据条件判断来决定是否创建某个子节点。 直接编写 VNode 对象时，要实现类似的动态行为可能需要更多的代码和逻辑处理，增加了代码的复杂性。 五、总结为了避免重复操作真实 DOM 所带来的性能消耗，vue框架引入了虚拟 DOM。 虚拟 DOM本质上就是一个具有特有属性的一个 JS对象。 为了实现创建虚拟 DOM 的一致性，vue提供了一个方法 createElement 用来方便快捷的生成虚拟 DOM。"},{"title":"🔥Vue2初始化时都干了什么事","path":"//posts/vue2-init.html","content":"&nbsp; 返回 专栏第四篇-初始化干了什么事 &emsp;&emsp;上一节中我们知道 Vue就是一个构造函数，在使用 Vue的时候需要实例化 Vue，这一章我们就来看看在实例化的时候内部做了一些什么操作。 零、调用了_init方法123456function Vue()&#123; if(!this instanceof Vue)&#123; return warn(&quot;必须使用 new 关键字来实例化&quot;) &#125; this._init();&#125; 除了在构造函数内部对是否使用 new 关键字进行判断。 还在校验过后调用了_init方法。 从 init 这个名字不难看出，肯定在内部做了一些初始化的操作。 该方法是在Vue被引入时调用 initMixin 方法在Vue上注入的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let uid = 0;export function initMixin(Vue)&#123; Vue.prototype._init = function (options?: Record&lt;string, any&gt;) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to mark this as a Vue instance without having to do instanceof // check vm._isVue = true // avoid instances from being observed vm.__v_skip = true // effect scope vm._scope = new EffectScope(true /* detached */) // #13134 edge case where a child component is manually created during the // render of a parent component vm._scope.parent = undefined vm._scope._vm = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options as any) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (__DEV__) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;, undefined, false /* setContext */) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) /* istanbul ignore if */ if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 接下来我们会详细解释下每一步中具体都做了什么。 一、vm._uid12345let uid = 0;Vue.prototype.init=function()&#123; vm._uid = uid++&#125; 在_init方法的第一行可以看到在实例上挂载了一个vm._uid属性。 每个Vue实例都会有一个唯一的_uid（Unique Identifier，唯一标识符。 这个标识符是在 Vue 实例创建时由一个递增的计数器生成的，其主要用途是在内部处理中提供唯一性。 尤其是在涉及到实例间的比较或者跟踪的时候。 二、追踪初始化消耗时间123456789101112// _init 函数刚执行时let startTag, endTagif (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag)&#125;// _init 函数初始化逻辑完成if (__DEV__ &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(endTag) measure(`vue $&#123;vm._uid&#125; init`, startTag, endTag)&#125; 2.1 覆盖默认配置我们知道在 Vue 可以覆盖默认配置。 12// 开启 vue性能配置Vue.config.performance = true; 那么 vue 是如何做到的呢？ core/config.js文件是vue的默认配置文件。 12345// core/config.jsexport default &#123; // 默认不开启perf performance: false&#125; Vue被引入时，在 initGlobalAPI方法中给 Vue设置了 config属性。 12345678910111213141516import config from &#x27;../config&#x27;export function initGlobalAPI(Vue)&#123; // 省略部分代码 const configDef = &#123;&#125;; configDef.get = () =&gt; config; if (__DEV__) &#123; configDef.set = () =&gt; &#123; warn( &#x27;不要替换Vue.配置对象，而是设置单独的字段&#x27; ) &#125; &#125; Object.defineProperty(Vue,&#x27;config&#x27;,configDef);&#125; 而引入的config就是Vue的默认配置文件，其导出内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293export default &#123; /** * Option merge strategies (used in core/util/options) */ // $flow-disable-line optionMergeStrategies: Object.create(null), /** * Whether to suppress warnings. */ silent: false, /** * Show production mode tip message on boot? */ productionTip: __DEV__, /** * Whether to enable devtools */ devtools: __DEV__, /** * Whether to record perf */ performance: false, /** * Error handler for watcher errors */ errorHandler: null, /** * Warn handler for watcher warns */ warnHandler: null, /** * Ignore certain custom elements */ ignoredElements: [], /** * Custom user key aliases for v-on */ // $flow-disable-line keyCodes: Object.create(null), /** * Check if a tag is reserved so that it cannot be registered as a * component. This is platform-dependent and may be overwritten. */ isReservedTag: no, /** * Check if an attribute is reserved so that it cannot be used as a component * prop. This is platform-dependent and may be overwritten. */ isReservedAttr: no, /** * Check if a tag is an unknown element. * Platform-dependent. */ isUnknownElement: no, /** * Get the namespace of an element */ getTagNamespace: noop, /** * Parse the real tag name for the specific platform. */ parsePlatformTagName: identity, /** * Check if an attribute must be bound using property, e.g. value * Platform-dependent. */ mustUseProp: no, /** * Perform updates asynchronously. Intended to be used by Vue Test Utils * This will significantly reduce performance if set to false. */ async: true, /** * Exposed for legacy reasons */ _lifecycleHooks: LIFECYCLE_HOOKS&#125; as unknown as Config 根据上面的配置可以知道 Vue.config获取的就是config文件中中配置的内容。 export或export default一个对象时，对象本身在外部脚本中是不能修改的。但是对象的属性在外部脚本中都是可以修改的。 所以你可以通过Vue.config.xxx = xxx 来设置配置或者覆盖默认的配置。 2.2 mark函数 &amp; measure函数mark函数 和 measure函数是vue中进行性能检测的函数。 函数位于core/util/perf文件中。 123456789101112131415161718192021222324// 判断是否在浏览器中import &#123; inBrowser &#125; from &#x27;./env&#x27;export let markexport let measure// 只有在开发环境中才会设置 mark 和 measureif (__DEV__) &#123; const perf = inBrowser &amp;&amp; window.performance if ( perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures ) &#123; mark = tag =&gt; perf.mark(tag) measure = (name, startTag, endTag) =&gt; &#123; perf.measure(name, startTag, endTag) perf.clearMarks(startTag) perf.clearMarks(endTag) &#125; &#125;&#125; 实际上就是调用了window.performance相关的 api： performance.mark：主要用于创建标记 performance.measure： 主要用于记录两个标记的时间间隔 performance.clearMarks： 用于清除标记 123456789window.performance.mark(&quot;_start&quot;)for(let i=0;i&lt;10000;i++)&#123; console.log();&#125;window.performance.mark(&quot;_end&quot;)window.performance.measure(&quot;timestamp&quot;,&quot;_start&quot;,&quot;_end&quot;)// 可以获取直接间隔window.performance.getEntriesByName(&quot;timestamp&quot;)[0] 可以使用getEntriesByName获取两个标记期间代码执行的时间。 从而这里通过这个方法可以获取到初始化_init函数执行的时机。 2.3 总结在 _init 函数开始时打一个名为“vue-perf-start”的标记。 然后在逻辑处理结束后打一个名为“vue-perf-end”的标记。 最后通过measure函数设置一个 measure 对象，里面包含两个标记之间的间隔时间。 这个间隔时间就可以看成这个实例初始化花费的时间，以此来评测性能。 三. vm._isVue123Vue.prototype.init=function()&#123; vm._isVue = true&#125; 每个 vue实例 在初始时都会设置_isVue变量。 这个变量可以在内部&#x2F;扩展插件中判断当前对象是否是一个有效的 vue实例。 四、vm.__v_skip123Vue.prototype.init=function()&#123; vm.__v_skip = true&#125; 在初始化时将该变量设置为 true。 这个变量用于指示Vue的相应是系统跳过对该对象的观测。 当一个对象被标记为 __v_skip &#x3D; true 时，Vue 不会对这个对象进行深度观测，这意味着对象内部的属性变化将不会触发视图更新。 五、合并选项123456789101112if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options as any)&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm )&#125; 第五步是执行合并 options的操作，那么这个 options是什么呢？可以说 Vue中的大部分内容都是基于 options来完成的，这个 options中存储了用户传入的选项以及一些内置的 Vue选项。 由于options在 Vue中比较重要，关于这一块我们后面会专门开一篇文章来详细解释。 在这篇专栏中具体说明了合并选项：第五篇专栏 六、设置数据代理检测12345if (__DEV__) &#123; initProxy(vm)&#125;else &#123; vm._renderProxy = vm&#125; 这里的目的是在开发环境下给vm设置代理，从而达到开发时提示的功能，这个我们后续也会单开一篇文章进行说明。 七、vm._self &#x3D; vm123Vue.prototype.init=function()&#123; vm._self = vm&#125; 将_self属性指向自身这个实例。 可以确保在任何情况下都能正确引用当前实例。 八、执行一些初始化操作后面我们会执行一些用于初始化的操作。 内部具体做了什么我们咱不考虑，在后面的章节中我们会一一进行讨论。 123456789101112// 初始化生命周期initLifeCycle(vm);// 初始化事件中心initEvents(vm)// 初始化渲染initRender(vm)// 初始化 injectinitInjections(vm)// 初始化 props、data、computed 等initState(vm)// 初始化 providerinitProvide(vm) 这些函数基本上都是在实例上挂载了一些方法，比如渲染执行的_update就是在 initLifecycle中定义的、跟渲染相关的_render函数就是在 initRender中定义的。 九、执行一些生命钩子在执行 initRender 后，会调用 beforeCreate 钩子。这表示beforeCreate 钩子 调用的时机为Vue实例化 data数据前，所以此时获取 data是无法获取到的，因为这时候还没有初始化 data。 在执行完最后一个初始化函数initProvide后，会调用 created钩子。这表示created钩子 调用的时机为Vue实例初始化后。 123456// 省略initRender(vm)callHook(vm, &#x27;beforeCreate&#x27;, undefined, false /* setContext */)// 省略initProvide(vm) // resolve provide after data/propscallHook(vm, &#x27;created&#x27;) 十、执行挂载123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; 判断是否有vm上是否有$options选项，如果存在$options选项，则执行挂载方法。 十一、总结在 init函数内部，主要是执行一些初始化操作，比如设置基础的代理。初始化data、给实例上设置_update、_render方法等。"},{"title":"🔥Vue2丰富的选项合并策略","path":"//posts/vue2-merge-options.html","content":"&nbsp; 返回 专栏第五篇-丰富的选项合并策略 一、实例化时合并选项在上一篇文章中执行Vue初始化的时候，我们说到了选项合并。 那什么是选项呢？ 在 new Vue(选项)中，Vue构造函数中传入的数据就是选项，代表传入的选项，一般以对象形式传入。 在Vue源码中使用变量options表示选项，在源码中你经常能看到 options的身影。 在实例化时需要将实例对应的构造函数上的选项和传入的选项合并到实例的选项上。 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) 上面 mergeOptions 则是用于合并 2 个 options，resolveConstructorOptions用于获取构造函数上的options。 在前面的文章 Vue的原型设计中，我们知道 vm.constructor 就是指的 Vue构造函数 二、Vue构造函数的默认选项前面我们知道 vm.$options 中会合并Vue构造函数的 options。 那么 Vue.options 有值吗？ 实际上Vue构造函数本身会自带一些默认的选项。 在Vue被引入时，会执行多个方法给Vue.options注入属性。 2.1 initGlobalAPI方法创建 Vue.optionsinitGlobalAPI方法在Vue被引入时执行。 1234567891011121314151617// core/global-api/index.tsconst ASSET_TYPES = [&#x27;component&#x27;,&#x27;directive&#x27;,&#x27;filter&#x27;];const builtInComponents = &#123; KeepAlive&#125;export function initGlobalAPI(Vue)&#123; // Object.create用于创建一个对象 该对象没有原型 Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &#x27;s&#x27;] = Object.create(null) &#125;); Vue.options._base = Vue; extend(Vue.options.components, builtInComponents) &#125; 可以看到，installGlobalAPI方法中创建了 Vue.options为一个纯净的空对象，然后在options上面注入了一些属性。 _base就是 Vue构造函数。每个Vue组件都是通过_base属性获取到Vue构造函数，然后使用Vue.extend来生成对应的 VueComponent构造函数。 extend方法是vue中的一个通用方法。用于将第二个参数的值合并到第一个参数中，返回第一个参数。第二个参数的值直接覆盖进第一个参数 extend函数源码1234567891011export function extend( to, _from)&#123; // 用于合并第二个参数到第一个参数中 for (const key in _from) &#123; // 覆盖参数属性 to[key] = _from[key] &#125; return to&#125; 2.2 合并指令 &amp; 内置组件1234567891011121314// platforms/web/runtime/indexconst platformDirectives = &#123; model, show&#125;const platformComponents = &#123; Transition, TransitionGroup&#125;extend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents) 该段逻辑也是在 Vue被引入时执行，扩展了一些跟 web平台相关的指令和组件。 2.3 总结经过我们的研究发现，Vue构造函数的默认选项有： _base： 代表Vue构造函数，后续用来创建组件的构造函数VueComponent。 directive：代表需要注册的指令，默认的提供了 v-model、v-show的内置指令。 components：代表需要注册的组件选项，默认提供了 KeepAlive、Transition、TransitionGroup的内置组件。 filter ：代表需要注册的过滤器，默认没有提供默认值。 三、子类构造函数的 options学习完上节我们知道在Vue被引入时，在Vue构造函数上注入了一些默认选项。 在专栏第三篇中，我们介绍了 Vue.extend函数。 在render阶段生成虚拟节点时，会调用 Vue.extend 生成组件构造函数VueComponent，并存在 vnode上。 然后在update阶段开始挂载节点时，会调用组件构造函数 VueComponent来创建组件实例，再进行后续组件实例初始化、渲染等操作。 那么VueComponent构造函数作为Vue构造函数的子类，是不是也继承了它的默认选项呢？ 我们再次打开 Vue.extend 的源码一探究竟。 1234567891011Vue.extend = function(extendOptions)&#123; extendOptions = extendOptions || &#123;&#125; // 新增_Ctor属性 const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) const Super = this; const Sub = function VueComponent()&#123; this._init(); &#125; // mergeOptions用于合并2个选项返回一个合并选项 Sub.options = mergeOptions(Super.options, extendOptions)&#125; 虽然我们不知道 mergeOptions的具体逻辑，但是我们很容易看出来，VueComponent构造函数上的 options属性合并了“父类“构造函数上的options属性以及extend方法传入的选项。 在 VueComponent构造函数上新增了一个_Ctor属性，可以避免每次重新创建子类，提高性能，后面我们会专门说这里，这里不进行展开。 所以我们可以得出一个结论：子类构造函数的选项继承了其父类构造函数的选项。 举个例子： 123const VueComponent = Vue.extend(&#123; template:`&lt;div&gt;我是子类构造函数&lt;/div&gt;`&#125;); 此时 VueComponent.options 上既包含了自身传入的 template 选项，也包含了继承自Vue构造函数上的属性。 这里需要注意的是，在合并父类构造函数的 options时，不同 option的合并策略不同，对于components、filter、directives等内置选项会合并到原型链中。 我们知道，VueComponent构造函数本身是具有再次扩展的能力的。 1234567const VueComponentChild = VueComponent.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChildConstructor&quot; &#125; &#125;&#125;) 同理，VueComponentChildConstructor是VueComponent的子类，所以VueComponentChildConstructor就继承了VueComponent的 options。 四、获取构造函数上的 options在Vue初始化操作执行时，使用 resolveConstructorOptions 函数来获取构造函数上的 options。 1234567891011121314151617181920212223export function resolveConstructorOptions(Ctor)&#123; let options = Ctor.options; if (Ctor.super) &#123; const superOptions = resolveConstructorOptions(Ctor.super) const cachedSuperOptions = Ctor.superOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed, // need to resolve new options. Ctor.superOptions = superOptions // check if there are any late-modified/attached options (#4976) const modifiedOptions = resolveModifiedOptions(Ctor) // update base extend options if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options;&#125; 看到这么多代码，想必大家也是极其懵逼的。 因为我们之前说过： Vue构造函数的选项是在初始化时注入的。 VueComponent构造函数及其扩展子类的选项则是在extend方法中进行注入的。 那直接使用.options获取构造函数的选项不就行了，为什么还有这么一大段逻辑呢？ 12Vue.options // 获取Vue构造函数的选项VueComponent.options // 获取VueComponent构造函数的选项 其实这一段逻辑主要是应对父类构造函数上选项变化的情况。 4.1 Ctor.super可以看到只有 Ctor.super 存在时才会走这一大段逻辑。 那么 Ctor.super 指的是什么呢？ 在使用 extend生成子类构造函数时，会在子类构造函数上新增了一个 super属性，指向它的父类。 123456789Vue.extend = function()&#123; let Sub = function VueComponent()&#123; this._init &#125; let Super = this; // 省略部分代码 // super即代表它的父类 Sub[&#x27;super&#x27;] = Super;&#125; 所以如果存在 super 属性，则代表现在这里的 Ctor使用的是extend生成的VueComponent构造函数。所以这里分为 2 种情况： 没有super属性，代表这是 Vue构造函数，直接返回 Vue.options 即可。 如果存在super属性，代表这是extend生成的 VueComponent构造函数，需要进行进一步判断。 因为 VueComponent.options的值是在 extend时合并了父类选项和extend传入选项的全新选项。 所以如果后续Vue.options变化了无法获取最新的选项。 4.2 判断父类构造函数上的 options 是否变化那么有哪些操作可以修改父类构造函数上的 options呢？ 比如使用 Vue.mixin api，这个 api就修改了Vue.options选项。 这个时候就需要有一些逻辑可以更新 VueComponent上的 options。 我们来看下 Vue是怎么更新的。 12345const superOptions = resolveConstructorOptions(Ctor.super)const cachedSuperOptions = Ctor.superOptionsif (superOptions !== cachedSuperOptions) &#123; // 进入这个逻辑说明 Vue.options变化了&#125; 上面代码中如果 superOptions 不等于 cachedSuperOptions，即表示父类构造函数发生了变化。 所以我们需要搞明白这 2 个值分别表示什么？ superOptions是在resolveConstructorOptions中递归向上查找的，就是表示父类构造函数的最新选项。 cachedSuperOptions 是指的构造函数上的 superOptions属性，这个属性是在 extend中定义的： 12345678Vue.extend = function()&#123; let Super = this; let Sub = function VueComponent()&#123; this._init(); &#125; // 这里存储的就是父类构造函数的 options Sub.superOptions = Super.options&#125; 所以这 2 个值都是指的父类构造函数，指向的是同一块内存地址，那么为什么会有不一样的情况呢？ 在 Vue 旧版本中曾经有一个相关的 bug。我们先来了解一下这个 bug： 4.2.1 Vue旧版本的 buggithub issue #4976 这个bug的大概意思就是说：先生成VueComponent构造函数，然后再在构造函数上的 options 添加属性，在resolveComponentOptions函数执行后，后添加的属性消失了。 这是复现链接：options消失。 我们这里看一下代码： 123456789101112131415161718192021222324252627const Test = Vue.extend(&#123; foo: &#x27;Foo&#x27;&#125;)// Inject options later// vue-loader and vue-hot-reload-api are doing like thisTest.options.computed = &#123; $style: &#123; test: &#x27;abcde&#x27; &#125; &#125;Test.options.beforeCreate = [ () =&gt; &#123; console.log(&#x27;Should be printed&#x27;) &#125;]Test.options.render = function (h) &#123; return h(&#x27;div&#x27;, &#x27;$style: &#x27; + this.$style)&#125;// Update super constructor&#x27;s optionsVue.mixin(&#123;&#125;)new Vue(&#123;\trender: h =&gt; h(Test)&#125;).$mount(&#x27;#app&#x27;)// This is retainedconsole.log(Test.options.foo)// Should be appear but notconsole.log(Test.options.computed)console.log(Test.options.beforeCreate) 可以看到首先使用 Vue.extend 生成了一个 Test构造函数。 然后在 Test的 options上新增了 2 个属性。 执行完Vue.mixin后，先前定义的computed、beforeCreate2个属性不见了。 4.2.2 Vue.mixin那么这个 Vue.mixin究竟是干了啥呢？ 1234Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this&#125; 可以看到mixin函数仅仅是改变了构造函数上的options。 但是 mergeOptions 会返回一个新的对象，导致构造函数的 options 发生了变化。 也就导致了前面说的 superOptions !== cachedSuperOptions 情况的发生。 因为 superOptions 获取的是当前最新的选项，也就是 mixin 执行过的合并选项。 而 cachedSuperOptions 则是在执行 Vue.extend 时当时的父类构造函数的选项。 4.2.3 旧版本Vue中 resolveConstructorOptions 的逻辑是什么？但是 Vue.mixin 仅仅是更改了 Vue.options。 应该不会将VueComponent构造函数自身添加的属性清除。 所以应该是 Vue内部对其做了一些特殊处理。 我们打开 Vue 2.1.10 版本的相关源码。 1234567891011121314151617181920export function resolveConstructorOptions (Ctor) &#123; let options = Ctor.options if (Ctor.super) &#123; const superOptions = Ctor.super.options const cachedSuperOptions = Ctor.superOptions const extendOptions = Ctor.extendOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed Ctor.superOptions = superOptions extendOptions.render = options.render extendOptions.staticRenderFns = options.staticRenderFns extendOptions._scopeId = options._scopeId options = Ctor.options = mergeOptions(superOptions, extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125; 获取了父构造函数的当前的 options：const superOptions = Ctor.super.options。 获取了父构造函数执行extend时的options：const cachedSuperOptions = Ctor.superOptions。 获取了子构造函数 extend时传入的选项extendOptions。 因为执行了mixin，导致父构造函数中的 options发生了变化，即superOptions !== cachedSuperOptions，然后继续执行内部的逻辑。 1options = Ctor.options = mergeOptions(superOptions, extendOptions) 可以看到它是将获取到的父构造函数 options和当初 extend传入的 options合并，然后重新赋值给了 Ctor.options。 所以后添加的computed、beforeCreate就消失了，因为指向了不同的内存空间。 4.2.4 总结通过上面几节的学习，我们知道了为什么需要判断父类构造函数的变化。 我们系统提供了全局注入的 API：Vue.mixin。 使用这个函数可以向全局注入一些选项。 而实际上就是通过改变Vue构造函数上的option，再通过这里的变更逻辑重新赋值到 VueComponent.options上，这样生成的实例就可以访问到 Vue.mixin注入的属性了。 4.3 使用resolveModifiedOptions获取更改的属性应对上面说的这个 bug，Vue官方也对这resolveConstructorOptions方法进行了调整。 针对VueComponent构造函数上可能存在的options更改进行了处理。 首先在 Vue.extends中保存了VueComponent的当时的options。 12345Vue.extend = function()&#123; // 省略部分代码 // 存储了当时的 options Sub.sealedOptions = extend(&#123;&#125;, Sub.options)&#125; 使用resolveModifiedOptions查找修改的option部分 123456789101112function resolveModifiedOptions(Ctor)&#123; let modified const latest = Ctor.options const sealed = Ctor.sealedOptions for (const key in latest) &#123; if (latest[key] !== sealed[key]) &#123; if (!modified) modified = &#123;&#125; modified[key] = latest[key] &#125; &#125; return modified&#125; 将修改的 options合进 extendOptions 123if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions)&#125; 合并 extendOptions以及 superOptions extendOptions是最新的子类构造函数 options。 superOptions是最新的父类构造函数 options。 将两者合并就不会有问题了。 1options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) 5.4 总结这个函数可以获取到构造函数上最新的options。 同时可以更新子类构造函数和父类构造函数上的superOptions、extendOptions以及 options。 五、mergeOptions的合并场景mergeOptions在实例化时用于合并构造函数的 options和传入的 options。 mergeOptions 是实现继承和实例化的核心函数。 123456function mergeOptions(parent,child,vm)&#123; // parent代表合并父类 // child代表合并子类 // vm代表当前的 vm实例 // 如果vm实例存在，则表示这是在实例化时调用的&#125; mergeOptions函数不仅仅用于生成实例的$options属性。 也可以用于子类构造函数和父类构造函数的选项合并。 在多个场景都是用了这个函数。 5.1 Vue.extend1234Vue.extend = function(extendOptions)&#123; // 省略部分代码 Sub.options = mergeOptions(Super.options,extendOptions)&#125; 前面我们已经多次提及这个方法了。 这里的 mergeOptions 用于合并父类构造函数选项和传入的选项，生成子类构造函数的选项。 在这里：父类构造函数的选项相当于父类，而传入的选项相当于子类。不传入vm实例。 5.2 Vue.mixin1234Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this&#125; 前面我们也多次提到这个方法，这个方法主要是用于合并构造函数的options，和传入mixin选项，生成全新的构造函数的 options。 在这里：构造函数的选项相当于父类，而传入的 mixin选项相当于子类。不传入vm实例。 5.3 vm.$options12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm) 该方法用于在实例化的时候生成实例的$options属性。这个方法主要用于合并实例对应的构造函数的选项和传入的选项，生成一个完整地实例选项。 在这里：构造函数的选项相当于父类，而实例化时传入的 mixin选项相当于子类`。`此时传入vm实例。 六、合并策略在实例化的时候，会将构造函数上的选项和用户传入的选项进行合并，将最终的合并选项注入到实例中。 12345vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor as any), options || &#123;&#125;, vm) mergeOptions函数用于合并2个选项，并返回一个新的选项。 123456789101112131415161718function mergeOptions(parent,child)&#123; // 省略部分代码 let key const options = &#123;&#125;; for(key in parent)&#123; mergeField(key) &#125; for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125; &#125; function mergeField(key)&#123; const strat = strats[key] || defaultStrat; options[key] = strat(parent[key], child[key], vm, key) &#125; return options;&#125; 大家可以先思考一下合并2个对象需要注意些什么呢？ 假设构造函数的options和传入的options中都存在data，这个时候合并的是： 直接覆盖？ 如果覆盖的话是使用构造函数的data还是传入的data? 还是将data中的内容再进行合并呢？ 实际上不同的选项中的都存在自己的合并逻辑。 比如data选项和生命周期钩子选项合并策略肯定是不同的。 6.1 自定义策略在Vue中，可以自己定义不同的合并策略。 1234// 可以配置合并策略Vue.config.optionMergeStrategies = &#123; customArray:[]&#125;; 配置完以后，就可以在optionMergeStrategies获取用户配置的策略。 12// 源码中定义策略变量首先获取optionMergeStrategies 如果没有配置 optionMergeStrategies 默认是一个空对象const strats = config.optionMergeStrategies 然后再在 strats这个对象上添加属性，定义不同的策略。 123456789101112// data的合并策略strats.data = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125;// props的合并策略strats.props = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125;// computed的合并策略strats.computed = (parentVal,ChildVal,vm)=&gt;&#123; // xxx&#125; 由于strats是一个对象，所以你如果定义了和内部定义的策略相同的选项，会被覆盖掉。也就意味着你无法重新定义 data、computed、props等内部策略 但是你可以自定义自己的选项。 12345678910111213import Vue from &quot;vue/dist/vue.esm.browser&quot; import Test from &quot;./Test.vue&quot; Vue.mixin(&#123; customArray:[1,3,5,8,9]&#125;) const vm = new Vue(&#123; render: h=&gt;h(Test), customArray: [1,4,5,7]&#125;).$mount(&quot;#app&quot;) console.log(vm); 比如你想要实现你自定义的 customArray选项 数组内容合并并且去重，可以使用使用optionMergeStrategies: 123456// parentVal代表构造函数上的选项值， childVal代表传入的选项值Vue.config.optionMergeStrategies.customArray = (parentVal,childVal)=&gt;&#123; // 其他Vue组件没有定义不进行处理 if(!childVal) return []; return Array.from(new Set([...parentVal,...childVal]))&#125; 我们打印一下这个实例，可以发现已经成功了。 6.2 默认的合并策略由于可以选项高度可自定义，所以 Vue中内置了一套默认的合并策略。 主要应对没有设置对应策略的合并情况。 123const defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal&#125; 可以看出来默认的合并策略是传入的options直接对构造函数的options进行强制覆盖（如果存在的话）。 6.3 el、propsData的合并策略可以看出来 el、propsData的合并策略和默认策略一样，只是多了一个开发环境的报错提示。 12345678910111213141516if (__DEV__) &#123; strats.el = strats.propsData = function ( parent: any, child: any, vm: any, key: any ) &#123; if (!vm) &#123; warn( `option &quot;$&#123;key&#125;&quot; can only be used during instance ` + &#x27;creation with the `new` keyword.&#x27; ) &#125; return defaultStrat(parent, child) &#125;&#125; 那么这个报错是什么意思呢？ 策略函数的的第三个参数vm代表vue实例。 而这个vm同时也是mergeOptions的第三个参数。 而 mergeOptions作为一个通用函数，不仅只是在实例初始化的时候被调用，同时也在Vue.extend、Vue.mixin等多个方法中被使用，这个时候还没有生成 vm实例，所以 vm为空。而 el属性、propsData属性是属于跟实例相关的属性，所以如果在Vue.mixin等方法中注入 el属性，则会报错。 综上所述，这行报错的意思就是禁止在除了实例化之外的地方注入 el选项。 比如调用： 123Vue.mixin(&#123; el:&quot;#select&quot;&#125;) 控制台就会报错： 6.4 data的合并策略data选项在 Vue中无疑是使用最频繁的选项之一。 所以它的合并策略相当复杂。 12345678910111213141516171819202122strats.data = function ( parentVal: any, childVal: any, vm?: Component): Function | null &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123; __DEV__ &amp;&amp; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &#x27;that returns a per-instance value in component &#x27; + &#x27;definitions.&#x27;, vm ) return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125; 6.4.1 在定义时报错我们知道通常在组件中，建议将 data定义成函数，因为如果将 data定义成普通对象，在该组件被引入到多处时，由于 extend函数内部会缓存这个构造函数，所以 data中的数据可能会被多个组件共享，导致 bug的产生。 childVal在这里代表传入的选项，即在组件中定义的选项。 所以会提示你需要将 data定义成函数，并且依旧调用 mergeDataOrFn。 在执行构造函数时创建子类构造函数时，虽然已经有了 vm了，但是并没有传入 mergeOptions。 123Vue.extend = function()&#123; Sub.options = mergeOptions(Super.options, extendOptions);&#125; 所以这个报错是在创建子类构造函数时进行提示的。 6.4.2 mergeDataOrFn1234567891011121314151617181920export function mergeDataOrFn( parentVal, childVal, vm) &#123; return function mergedInstanceDataFn() &#123; // instance merge const instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal const defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125;&#125; 该函数生成了一个合并函数。 当这个合并函数执行的时候将获取构造函数的上的data和传入的data 当传入的选项中存在 data，则调用mergeData合并 2 个data并返回。 当传入的选项中不存在 data时，则直接返回构造函数上的 data。 6.4.3 mergeData当构造函数的选项和传入的选项都存在 data时，需要调用 mergeData对 2 个选项进行合并。 123456789101112131415161718192021222324252627282930function mergeData( to, from, recursive = true)&#123; if (!from) return to let key, toVal, fromVal const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from) for (let i = 0; i &lt; keys.length; i++) &#123; key = keys[i] // in case the object is already observed... if (key === &#x27;__ob__&#x27;) continue toVal = to[key] fromVal = from[key] if (!recursive || !hasOwn(to, key)) &#123; set(to, key, fromVal) &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal) &#125; &#125; return to&#125; 这个函数的主要作用是合并两个对象的属性，可以用于初始化组件的数据对象，或者在组件的 created 钩子中合并父组件和子组件的数据。通过 recursive 参数，它可以灵活地进行浅合并或深度合并。 由于其中涉及到响应式数据的内容，所以不在这里深入讨论。 后面会单独出响应式数据的内容。 6.5 生命周期的合并策略1234567891011121314151617181920212223242526272829303132333435363738394041424344export const LIFECYCLE_HOOKS = [ &#x27;beforeCreate&#x27;, &#x27;created&#x27;, &#x27;beforeMount&#x27;, &#x27;mounted&#x27;, &#x27;beforeUpdate&#x27;, &#x27;updated&#x27;, &#x27;beforeDestroy&#x27;, &#x27;destroyed&#x27;, &#x27;activated&#x27;, &#x27;deactivated&#x27;, &#x27;errorCaptured&#x27;, &#x27;serverPrefetch&#x27;, &#x27;renderTracked&#x27;, &#x27;renderTriggered&#x27;]LIFECYCLE_HOOKS.forEach(hook =&gt; &#123; strats[hook] = mergeLifecycleHook&#125;)// 生命周期的合并策略export function mergeLifecycleHook( parentVal, childVal)&#123; const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal return res ? dedupeHooks(res) : res&#125;function dedupeHooks(hooks) &#123; const res = [] for (let i = 0; i &lt; hooks.length; i++) &#123; if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]) &#125; &#125; return res&#125; 上面这个三元表达式还是比较复杂的。 如果子类和父类都拥有相同的钩子选项，则将子类选项和父类选项合并。 如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项。 当子类不存在钩子选项时，则以父类选项返回。 子父合并时，是将子类选项放在数组的末尾，这样在执行钩子时，永远是父类选项优先于子类选项执行。 简单总结一下：对于生命周期钩子选项，子类和父类相同的选项将合并成数组，这样在执行子类钩子函数时，父类钩子选项也会执行，并且父会优先于子执行。 6.6 组件、指令、过滤器的合并策略12345678910111213141516171819export const ASSET_TYPES = [&#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;]ASSET_TYPES.forEach(function (type) &#123; strats[type + &#x27;s&#x27;] = mergeAssets&#125;)function mergeAssets( parentVal, childVal, vm, key) &#123; const res = Object.create(parentVal || null) if (childVal) &#123; return extend(res, childVal) &#125; else &#123; return res &#125;&#125; 很明显 组件、指令、过滤器的合并策略就是直接对构造函数的选项进行覆盖。 Object.create()方法创建一个新对象，使用创建的对象来提供新创建的对象的__proto__。 这意味着这个合并策略让内置的一些资源选项变成了原型链的形式。 这样子类必须通过原型链才能查找并使用内置的组件和内置指令。 6.7 watch的合并策略在使用 Vue 进行开发时，我们经常需要对数据变化做出响应，尤其是当涉及到需要执行异步操作或计算成本较高的任务时，watch 选项就显得尤为高效。 关于 watch 选项的合并策略，它与生命周期钩子的合并有相似之处：如果父组件和子组件有相同的观察字段，它们的 watch 选项将被合并为一个数组。 当监测到字段变化时，父类和子类的监听代码将被同时触发。 与生命周期钩子的处理方式不同，watch 选项在合并后的数组中可以呈现多种形式：它们可以是包含选项的对象，也可以是回调函数，或者是方法名的字符串。 这种灵活性使得 watch 选项能够适应更多的使用场景，无论是简单的数据变化监听还是复杂的异步操作处理。 通过这种方式，Vue 允许开发者在组件和混入中灵活地定义和合并 watch 选项，从而实现精细化的数据监控和管理。 12345678910111213141516171819202122232425262728strats.watch = function (parentVal,childVal,vm,key) &#123; //火狐浏览器在Object的原型上拥有watch方法，这里对这一现象做了兼容 // var nativeWatch = (&#123;&#125;).watch; if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125; if (childVal === nativeWatch) &#123; childVal = undefined; &#125; // 没有子，则默认用父选项 if (!childVal) &#123; return Object.create(parentVal || null) &#125; &#123; // 保证watch选项是一个对象 assertObjectType(key, childVal, vm); &#125; // 没有父则直接用子选项 if (!parentVal) &#123; return childVal &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; // 父的选项先转换成数组 if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret&#125;; 下面结合具体的例子看合并结果： 1234567891011121314151617181920212223242526var Parent = Vue.extend(&#123; watch: &#123; &#x27;test&#x27;: function() &#123; console.log(&#x27;parent change&#x27;) &#125; &#125;&#125;)var Child = Parent.extend(&#123; watch: &#123; &#x27;test&#x27;: &#123; handler: function() &#123; console.log(&#x27;child change&#x27;) &#125; &#125; &#125;, data() &#123; return &#123; test: 1 &#125; &#125;&#125;)var vm = new Child().$mount(&#x27;#app&#x27;);vm.test = 2;// 输出结果parent changechild change 简而言之:Vue 在处理 watch 选项的合并时，会将子组件与父组件的 watch 选项合并成一个数组。这个数组中的成员可以是回调函数、包含配置的对象，或者是指向函数的方法名。这样的设计提供了灵活的选项，以适应不同的数据监控需求。 6.8 props methods inject computed合并在 Vue 的源码设计中，props、methods、inject 和 computed 这些选项被归为一类，并且它们遵循相同的合并策略。 12345678910111213141516171819strats.props = strats.methods = strats.inject = strats.computed = function ( parentVal, childVal, vm, key) &#123; if (childVal &amp;&amp; __DEV__) &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = Object.create(null) extend(ret, parentVal) if (childVal) extend(ret, childVal) return ret&#125; 简而言之。 父类没有相应的选项，则直接使用子类的选项 当父组件和子组件都提供了这些选项时，子组件的选项会覆盖父组件的选项。这种策略确保了组件能够继承和扩展行为，同时允许子组件通过提供自己的选项来覆盖继承自父组件或混入的选项。 举个例子： 12345678910111213141516171819202122232425262728var Parent = Vue.extend(&#123; methods:&#123; handleClick:function()&#123; console.log(&quot;父类点击事件&quot;) &#125;, getParentName:function()&#123; console.log(&quot;获取父类名称&quot;) &#125; &#125;&#125;)var Child = Parent.extend(&#123; methods:&#123; handleClick:function()&#123; console.log(&quot;子类点击事件&quot;) &#125;, getChildName:function()&#123; console.log(&quot;获取父类名称&quot;) &#125; &#125;&#125;)var vm = new Child().$mount(&#x27;#app&#x27;);console.log(vm.$options.methods);// 合并子类和父类，遇到相同的属性，使用子类覆盖父类&#123; getChildName:f(), getParentName:f(), handleClick:f(),&#125; 6.9 provide合并确保了子组件的 provide 选项可以覆盖父组件的同名选项，同时保留了父组件的其他选项。这种设计允许组件在继承和扩展 provide 数据时有更多的灵活性。通过这种方式，Vue 允许开发者在组件树中有效地传递数据，而无需通过每个层级的组件显式地传递 props。 123456789101112131415strats.provide = function (parentVal, childVal) &#123; if (!parentVal) return childVal return function () &#123; const ret = Object.create(null) mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal) if (childVal) &#123; mergeData( ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive ) &#125; return ret &#125;&#125;"},{"title":"🔥Vue2的基本使用和原型设计","path":"//posts/vue2-constructor.html","content":"&nbsp; 返回 专栏第三篇-基本使用和原型设计 &emsp;&emsp;在前面两篇文章中，我们熟悉了源码的目录结构以及构建方式。 &emsp;&emsp;今天我们继续来说下Vue的原型设计。 一、Vue的基础使用官方推荐 Vue 的使用方式主要有两种：通过 CDN 和 NPM。 使用 CDN，我们可以通过在 HTML 中添加 &lt;script&gt; 标签直接引入打包好的 vue.js 文件，这是一种快速且简便的方法。 12// CDN方式&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; 而 NPM 方式则涉及到与模块打包工具如 webpack 或 Browserify 的集成，通过执行 npm install vue 命令来安装 Vue，这通常是我们在开发大型应用时的首选方式。 12// NPM方式import Vue from &#x27;vue&#x27;; 当Vue被引入时，通常我们会在入口文件中去 new 一个Vue实例。 然后再利用实例上的$mount方法将对应的模版内容挂载到浏览器中#app节点的位置上。 12345678// NPM方式// Nodejs版本import Vue from &#x27;vue/dist/vue.common&#x27;;// 需要实例化 Vuenew Vue(&#123; template:`&lt;div&gt;Hello World&lt;/div&gt;`&#125;).$mount(&quot;#app&quot;); 二、为什么Vue不是一个类上一节我们说了使用 Vue 需要 new 一下。 所以你可能会习惯性的认为 Vue 是一个类。 但是我们打开Vue被定义的core/instance/index.js文件。 123456function Vue(options) &#123; if (__DEV__ &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; 会发现Vue是使用函数定义的。 那么Vue源码中为什么不使用类呢？ 在Vue中有大量的扩展实例属性的操作如：Vue.prototype.$mount=xxx。 其实本质上类只是function的语法糖。 虽然说使用类也可以进行扩展： 123456class Animate&#123;&#125;Animate.prototype.eat = function()&#123; console.log(&quot;动物吃东西&quot;)&#125;new Animate().eat();// 动物吃东西 但是用类和原型这么混合使用，难免会让人感到不适，也算是一种开发规范和习惯吧。 大部分开源库依旧使用的是构造函数function的方式。 三、必须使用new关键字来调用可以看到在Vue构造函数内部存在一个判断 this instanceof Vue，那么这行代码应该如何理解呢？ 我们知道通过 instanceof可以顺着原型链向上查找对应的构造函数。 所以这个判断的意思就是检查当前上下文（this）是否是一个 Vue实例。 如果不是一个实例，就会给你一个警告。 这要告知开发者Vue应该要作为一个构造函数来使用。 123456// instance/index.jsfunction Vue(options) &#123; if(__DEV__ &amp;&amp; !this instanceof Vue)&#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125;&#125; 假设你这么使用 Vue： 1const vm = Vue() 那么你将会在控制台看到一条报错信息。 四、Vue的原型设计Vue是一个基于原型设计的前端框架。 在Vue被引入 import Vue from vue时，会通过多个函数在Vue原型上添加上一系列的方法。 123456// 该函数在 Vue被引入时执行export function lifecycleMixin(Vue)&#123; Vue.prototype._update = ()=&gt;&#123; // xxxx &#125;&#125; 那么在Vue.prototype上定义方法有什么作用呢？ 前面2节，我们说到 Vue本质上是一个构造函数： 123function Vue()&#123; //xxx&#125; 所以我们可以通过 new关键字来创建一个 vue实例。 1const vm = new Vue(); 构造函数与原型对象：每个构造函数都有一个 prototype属性，指向一个对象。这个对象被叫做原型对象，包含了由该构造函数创建的实例共享属性和方法。 实例对象的 __proto__ 属性：每个实例对象都有一个 __proto__ 属性，指向构造函数的原型对象。 所以我们可以得出结论：Vue构造函数的显式原型（Vue.prototype）和基于它创建的实例的隐式原型（vm.__proto__）指向的是同一块内存空间。 当 Vue实例访问某个属性时，如果在自身属性中找不到，则会沿着__proto__属性指向的原型对象进行查找。 所以通过 vm 可以访问到定义在 Vue.prototype 的属性和方法。 通用这种方式，可以很方便的扩展方法，并不用显示的在 vm 上设置方法，做到了相对隔离。 五、Vue.extend利用原型链继承生成“子类“构造函数Vue.extend是定义在Vue这个构造函数上的方法。 该方法主要用于创建Vue构造函数的“子类“，该“子类“继承 Vue构造函数上的原型方法和原型属性。 虽然Vue在技术上不是传统意义上的类，但是Vue.extend提供了一种类似于面向对象编程中继承的方式来定义组件。 123456789101112131415// 对原函数进行了一些简化 只保留了核心Vue.extend = function()&#123; // this 为 Vue构造函数 const Super = this; // Sub 为 VueComponent构造函数，代表组件构造函数 const Sub = function VueComponent(this)&#123; // 和 Vue构造函数一样 会调用_init方法 this._init(options); &#125;; // 基于 Vue.prototype 创建一块新的内存，共享其属性和方法。 Sub.prototype = Object.create(Super.prototype); // 修正 constructor指向 Sub.prototype.constructor = Sub; return Sub;&#125; 我们简单的分析一下这几行代码。 声明了Super变量和 Sub变量分别指向Vue构造函数和 VueComponent构造函数。 5.1 使用场景在Vue源码内部和使用Vue编写业务代码时都可以使用 Vue.extend这个 api。 5.1.1 内部创建组件每一个Vue组件都对应着一个实例。 而这些实例都是通过 extend 方法创建的 VueComponent构造函数 生成的。 在render阶段，也就是在生成组件的vnode的时候会通过 extend 方法创建VueComponent构造函数。 并赋值到 vnode 中的 componentOptions属性中。 1234567891011// 创建组件的 vnode 的方法export function createComponent(Ctor,context)&#123; // _base在引入时被设置为 Vue // 这里的options后面我们会详细说明 const base = context.$options._base; // 创建Vue子类构造函数 Ctor = base.extend(); return new Vnode( &#123;componentOptions:&#123;Ctor&#125;&#125; )&#125; 这里的_base实际上就是 Vue。 这里的 context是vm实例，vm.$options是在实例化构造函数时通过 mergeOptions函数生成的。 然后在update阶段（渲染页面），会基于Ctor生成对应的实例，执行相应的初始化、渲染方法等。 12345// 每个组件都会调用这个方法来创建对应的实例// 这里的 componentOptions.Ctor 就是对应的VueComponent构造函数export function createComponentInstanceForVnode(vnode)&#123; return new vnode.componentOptions.Ctor()&#125; 5.1.2 在业务中的实际应用场景在实际业务场景中，有很多地方都可以利用 extend 来扩展组件。 包括创建可复用的组件、动态组件、全局和局部注册、临时组件、自定义指令和插件。 我们常用的 Element框架内部就利用了 Vue.extend 来扩展某些临时性的组件，例如模态对话框、提示信息等。 通过 Vue.extend 创建的组件构造函数可以按需创建和销毁，适合这类临时组件的管理。 123456789101112131415161718const Main = &#123; template:&#x27;&lt;div&gt;hello main&lt;/div&gt;&#x27;&#125;const NotificationConstructor = Vue.extend(Main);let instance;const Notification = function() &#123; // 通过VueComponent创建组件实例 instance = new NotificationConstructor(); // 使用$mount可以创建一个DOM节点 并挂载到instance.$el上 instance.$mount(); document.body.appendChild(instance.$el); return instance;&#125; Notification(); $mount方法如果没有传参不会挂载，但是依旧可以生成 DOM节点，并赋值在 vm.$el上。 在 element 中的 Notification组件 就使用了 extend 进行扩展。 5.1.3 使用VueComponent继续扩展它的“子类”构造函数需要关注的是在Vue.extend中，将Vue.extend方法同时赋值给了 VueComponent。 意味着赋予了 VueComponent继续扩展的能力： 12345678Vue.extend = function()&#123; const Super = this; const Sub = function VueComponent()&#123; this._init(); &#125; // 省略部分代码 Sub.extend = Super.extend;&#125; 这意味着我们可以无限的基于 VueComponent和它的“子类”扩展子类。 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from &quot;@/my-vue2/platforms/web/entry-runtime-with-compiler-esm&quot;// 基于Vue构造函数创建的基础构造函数const VueComponentConstructor = Vue.extend(&#123; template:`&lt;div&gt;&#123;&#123; name &#125;&#125;我是构造函数&lt;/div&gt;`, data()&#123; return &#123; name:&quot;VueComponentConstructor&quot; &#125; &#125;&#125;);// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild1Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild1Constructor&quot; &#125; &#125;&#125;)// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild2Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild2Constructor&quot; &#125; &#125;&#125;)function addNode()&#123; const vm1 = new VueComponentConstructor(); const vm2 = new VueComponentChild1Constructor(); const vm3 = new VueComponentChild2Constructor(); vm1.$mount() vm2.$mount() vm3.$mount() document.body.appendChild(vm1.$el) document.body.appendChild(vm2.$el) document.body.appendChild(vm3.$el)&#125;addNode(); 上述代码中，VueComponentConstructor 是通过 Vue.extend 创建的一个基础组件构造函数。 在这个基础构造函数中传入了模板选项，我们之后创建的构造函数就可以复用 template选项，避免编写重复的模板。 我们这里只是简单的举了一个例子，通过这个例子我们了解到了extend的重要意义。真实的复用结构肯定更为复杂。 不过在实际开发中，一般我们应用中基本只存在 Vue构造函数和它的直接构造函数 VueComponent。 在组件库等基础库中可能会存在这种子类继续扩展子类的情况。 六、为什么Vue实例被叫做 vm源码中你会看到大量的 vm。 使用 new Vue() 创建的Vue实例通常被叫做 vm。 Vue被称为VM，是因为它是一个基于MVVM（Model-View-ViewModel）架构的前端框架。 在MVVM架构中，VM代表ViewModel，负责管理视图（View）和数据模型（Model）之间的通信和交互。 七、引入时基于原型挂载方法Vue是基于原型设计的前端框架。 后续的操作都是在调用原型上定义的方法。 那么 Vue是在什么时候对这些方法进行挂载的呢？ 一部分是在 Vue引入的时候挂载的，一部分是在 Vue实例化的时候进行挂载的。 那么 Vue是如何在引入的时候进行挂载呢？ 我们打开入口文件可以看到 Vue 被有层次的导入多个文件中，然后在文件中添加上对应的原型方法。 比如在: 在platforms/web/runtime-with-compiler.js文件中： Vue上扩展了定义了Vue.compile 重写了 Vue.prototype.$mount 在platforms/web/runtime/index.js文件中： 定义了Vue.prototype.$mount 定义了Vue.prototype.patch 扩展了扩展 Vue.config一些属性 扩展 Vue.options.directive 扩展 Vue.options.components 在core/index.js文件中： 使用了initGlobalAPI定义了一些全局方法 如 mixin 定义了Vue.prototype.$isServer 定义了Vue.prototype.$ssrContext 定义了Vue.FunctionalRenderContext 定义了Vue.version 在core/instance/index文件中： 使用 initMixin 注入了 初始化有关的属性如：Vue.prototype.$init 使用 stateMixin 注入了 跟状态有关的属性如：Vue.prototype.$set、Vue.prototype.$watch、Vue.prototype.$delete 使用 eventsMixin 注入了 跟事件有关的属性如：Vue.prototype.$on、Vue.prototype.$off、Vue.prototype.$once 使用 lifecycleMixin 注入了 跟整个 vue生命周期更新有关的属性如：Vue.prototype.$update 使用 renderMixin 注入了 跟渲染相关的属性如：Vue.prototype._render 可以发现 Vue源码中是一层一层进行导入。 那么Vue为什么要这么设计目录结构呢？ 我们可以看到每个模块都对 Vue对象做了相应的处理，比如说扩展属性、扩展实例属性等。 Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有。 这种技巧便于后期Vue的维护和迭代。"},{"title":"🔥Vue2源码构建","path":"//posts/vue2-core-build.html","content":"&nbsp; 返回 专栏第二篇-源码构建 &emsp;&emsp;在上一篇文章中，我们大概了解了Vue的目录结构是怎么样的。 &emsp;&emsp;在这一篇文章中，我们会知晓 Vue 是如何构建的。 一、Vue的构建1.1 根据使用场景打包在上一篇专栏文章中，我们熟悉了 Vue源码中的代码结构。 其中我们介绍了几个入口文件： entry-runtime.ts entry-runtime-with-compiler.ts entry-runtime-esm.ts entry-runtime-with-compiler-esm.ts 在我们开发项目结束后，需要进行打包并部署到线上。 通常我们项目打包时需要一个入口文件， webpack通过这个入口文件递归文件进行依赖分析然后打包。 其实框架打包也一样，同样需要一个入口文件进行递归依赖分析打包生成 js文件方便我们进行使用。 和项目不一样的是，项目往往只有一个入口文件，而框架会根据不同的情况采用不同的入口文件进行打包，上面的这四个文件就是Vue框架的入口文件。 Vue是使用rollup进行打包的。 为了方便用户进行使用，Vue在使用rollup进行打包时根据开发环境&#96;和开发模式打包出了不同功能的文件，以适用于不同的使用场景。 构建的rollup打包脚本的代码在scripts/config.js文件中。 1234567891011121314151617const builds = &#123; &#x27;runtime-cjs-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.dev.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;development&#x27;, banner &#125;, &#x27;runtime-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, banner &#125;, // 省略&#125; 总共打包生成 12 个文件，这些文件可以适用于不同的场景。 根据是否带编译器的角度上分为Full和Runtime-Only 2个版本。Full版本包含编译器和运行时的全部功能。Runtime-Only 仅含运行时功能。 打包的文件根据使用场景分为 esm、cjs、umd三个版本。其中umd可以通过&lt;script&gt;标签引入直接在浏览器中使用，Vue会暴露一个全局变量 Windows.Vue。而 CommonJS适配const Vue &#x3D; require(‘vue’)这种 node式的模块系统。ES则适配import Vue from ‘vue’这种es6格式。 打包的文件根据环境分为 dev&#x2F;prod，在开发环境中可以使用 dev版本的 js文件，而部署到客户生产环境就可以使用 prod版本的 js文件。 dev版本的文件有一些提示，会在开发者开发时便于调试。 1.2 Full版本的Vue到底是什么意思？ 平时我们开发中只使用了 runtime-only 版本。 而 Full版本中不仅有 runtime-only部分，还包括编译器部分。 所谓编译器，就是在Vue内部的编译器可以将模板转化为对应的render函数。 在Vue内部渲染就是调用的 render方法生成 vnode。 因为编译器代码体积比较大，而且如果在运行的时候进行模板编译，极大可能会消耗性能。 所以我们一般在开发项目时，使用 runtime-only版本。 在 webpack预编译阶段，就将.vue文件编译成render函数，在运行时直接运行 render函数就可以获取到对应的 vnode。 通过 runtime-only 和 esm很容易推测出来我们项目在开发阶段中使用的是vue.runtime.esm.js 1.3 使用 Full 还是用 Runtime-Only版本这需要依据具体情况进行具体分析。 倘若你需要用到 Vue 所提供的 html 模板功能，那就选用 Full 版本。 反之，最好采用 Runtime-only 版本，原因在于它比 Full 版本的文件体积大约小 30%。 *.vue 单文件组件会被 vue-loader 直接构建成为 JavaScript，并未使用到 Vue 的编译器，所以可以使用 Runtime-only 版本。 二、神奇的“__DEV__”在前面我们说到，在打包成开发环境的包时，往往会存在很多提示信息。 而源码中判断开发环境通常都是使用__DEV__来进行判断。 2.1 __DEV__的本质在Vue源码中，到处都能看到__DEV__变量的身影。 但是你看不到__DEV__被 import 引入，甚至你都找不到在哪里定义了这个变量。 这个变量在 Vue 中代表开发环境。 当你在源码中看见 if(__DEV__) 代表这个if中的逻辑只有在开发环境才进入执行。 vue的构建工具是rollup，在rollup打包的时候会使用@rollup/plugin-replace 插件来替换源代码中的__DEV__变量，如下： 123456789101112......const replace = require(&#x27;@rollup/plugin-replace&#x27;)......// built-in varsconst vars = &#123; ...... __DEV__: `process.env.NODE_ENV !== &#x27;production&#x27;`, ......&#125;......config.plugins.push(replace(vars))...... 所以__DEV__的本质就是 proess.env.NODE_ENV!== &#39;production&#39; 。 2.2 约定俗成的“process.env.NODE_ENV!&#x3D;&#x3D;’production”将 DEV 变量转换为 process.env.NODE_ENV !== &#39;production&#39; 这样的条件表达式在现代前端构建工具中是一种常见的约定和实践。 原因有以下几点： 环境区分：通过 process.env.NODE_ENV 可以方便地在代码中区分开发环境（development）与生产环境（production）。例如，在开发环境中启用特定的警告、日志记录或者热加载功能；而在生产环境中则禁用这些功能以优化性能。 Tree-shaking 和 UglifyJS：当打包工具如 Rollup 或 webpack 遇到 process.env.NODE_DEV !== &#39;production&#39; 包裹的代码块时，在生产环境下会自动去除（tree-shake）其中仅在开发环境中需要的代码，因为该条件表达式最终会被编译器或压缩工具识别为始终为 false，因此包裹的代码不会被打包进最终产物。 标准化：许多框架和库都采用了这种模式来处理环境相关的逻辑，这样开发者可以统一遵循这个约定，减少配置和理解成本。 灵活配置：由于构建工具支持 .env 文件或其他方式来设置 NODE_ENV 的值，这使得项目配置更加灵活，团队成员可以根据实际需求快速切换不同环境下的行为。 跨平台兼容性：process.env.NODE_ENV 作为一个标准 Node.js 环境变量接口，已经被广泛接受，并且在各种打包工具中都有相应的机制将其映射到最终浏览器执行的代码中，确保了跨平台的一致性。 一般项目在开发环境中将process.env.NODE_ENV设置为development，在生产环境中设置为production。 所以通过process.env.NODE_ENV !== &#39;production就可以判断现在是处于什么环境下。 2.3 在本地环境配置__DEV__因为我们这门课程是写一个完整版的vue2。 所以我们也会使用__DEV__这个变量代表开发环境。 我们本地的项目是使用 vue-cli 搭建的。 可以在 webpack配置文件 vue.config.js 文件新增一个配置达到这个目的。 1234567891011121314// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, configureWebpack: &#123; plugins: [ new webpack.DefinePlugin(&#123; __DEV__: process.env.NODE_ENV === &#x27;development&#x27;, &#125;), ], &#125;,&#125;) DefinePlugin 插件的主要作用是在编译时将预定义的值替换到源代码中的特定变量。 我们执行yarn start启动这个项目打印一下__DEV__为 true即为成功。 1console.log(__DEV__); // true"},{"title":"🔥Vue2目录结构窥探","path":"//posts/vue2-catalog.html","content":"&nbsp; 返回 专栏第一篇-目录结构窥探 &emsp;&emsp;因为 Vue 框架是在十多年前产生的一个开源前端框架，经过一些迭代修复，目前已经趋于稳定。 &emsp;&emsp;Vue2框架在可维护性、性能、TypeScript支持等方面有一些痛点，所以尤雨溪推出了 Vue3版本。 &emsp;&emsp;不过目前大部分公司因为成本等方面的原因，还是使用在 Vue2 版本，所以我们这个专栏就来探讨一下 Vue2 的源码部分。 一、非核心Vue源码目录大致结构 我们看的Vue源码版本2.7.16是Vue2的最新版本 我们打开Vue2的github源码地址。 可以看到其中有很多个目录文件，但是其实 Vue2 源码核心的都是在 src文件夹中的。 我们这章大概介绍一下除了 src 下面的一些目录，了解一下大体的作用是什么。 1.1 .github该文件夹用于存放与 gitHub 相关的配置文件或者脚本。 1.2 benchmarks该文件夹用于存放性能基准测试的相关文件和脚本。 性能基准测试是一种用来评估软件性能的方法，它通过模拟真实世界中的使用场景来测量软件在不同条件下的表现。 可以确保新功能不会降低框架的整体性能，同时也可以用来优化现有代码，使其更加高效。 1.3. compiler-sfc该文件夹下的内容逻辑就可以协助 webpack进行解析处理单文件组件（SFC）。 通常我们开发时会借助webpack将vue文件转化为一个JS对象。 可以查看他的 index.js文件 发现实际上就是导出了@vue/compiler-sfc这个包。 1module.exports = require(&#x27;@vue/compiler-sfc&#x27;) 1.4. dist该文件夹为打包文件存放的地方。 1.5. examples该文件夹用于存放示例应用程序或代码片段，目的是展示 Vue.js 的基本用法和功能。 1.6 packages该文件夹主要用于组织 Vue.js 的各个子包或模块。 随着 Vue.js 项目的复杂度增加，将不同的功能模块拆分成独立的子包已经成为了一种常见的做法。 这样不仅有利于模块化开发，还能方便依赖管理和发布。 该目录下有三个目录。 1.6.1 compiler-sfc该文件夹下的内容主要用于处理单文件组件。 1.6.2 server-renderer该文件夹下的内容和服务端渲染相关的内容。 1.6.3 template-compiler该文件夹下的内容存放模板编译相关的逻辑。 1.7 scripts该文件夹主要用于存放各种自动化脚本。 这些脚本通常用于辅助项目的构建、测试、发布和其他开发任务。 1.8 src该文件夹是存放 vue框架核心源码的地方。 1.9 test该文件夹主要用于存放各种类型的测试文件，这些测试文件用于验证 Vue.js 框架的功能是否按预期工作。 1.10 types该文件夹主要用于存放 TypeScript 类型定义文件。 这些类型定义文件为 Vue.js 提供了类型支持，使得在使用 Vue.js 时可以享受静态类型检查的好处，从而提高代码质量和开发效率。 1.11 .editorconfig该文件用于指定编辑器应该遵循的一系列编码和格式化规则。 1.12 .git-blame-ignore-revs该文件用于告诉 Git 在执行 git blame 命令时忽略某些特定的提交记录。 1.13 .gitignore该文件用于指定 Git 应该忽略哪些文件或目录，即不将这些文件或目录纳入版本控制。 1.14 .prettierrc该文件用于配置 Prettier。 Prettier是一个流行的代码格式化工具，旨在帮助开发者保持代码风格的一致性。 Prettier 可以自动格式化代码，使其符合预设的编码规范，从而提高代码的可读性和一致性。 1.15 BACKERS.md该文件主要用于记录和支持 Vue.js 项目的赞助者或贡献者。 这份文件通常列出了那些通过资金或其他形式支持 Vue.js 发展的个人或组织。 1.16 CHANGELOG.md该文件主要用于记录项目的版本变更历史，包括每个版本的新增功能、改进、修复的错误以及其他重要的变更信息。 1.17 LICENSE该文件用来定义和声明项目使用的许可协议的文件 1.18 README.md该文件为项目的入口文档文件。 文件提供了关于项目的概述、安装步骤、使用方法、贡献指南等关键信息。 1.19 api-extractor.json该文件用于配置 API Extractor 工具（这是一种用于生成 TypeScript 类型定义文档和 API 报告的工具） API Extractor 通常用于大型 TypeScript 项目中，帮助开发者生成详细的 API 文档，并确保类型定义的一致性和准确性。 1.20 api-extractor.tsconfig.json该文件用于配置 TypeScript 编译选项，以配合 API Extractor 工具生成 API 文档和类型定义文件。 这个文件通常包含了一些特定的 TypeScript 配置，确保 API Extractor 能够正确地解析和处理源代码。 1.21 package.json该文件是项目的核心配置文件，用于描述项目的元数据以及项目依赖关系和构建脚本。 1.22 pnpm-lock.yaml该文件是由 pnpm 包管理器生成的锁定文件。 用于记录项目中所有依赖项的具体版本信息，以及它们是如何被安装的。 pnpm 是一种替代 npm 和 yarn 的高性能包管理器，它具有更快的速度和更少的磁盘空间占用。 1.23 pnpm-workspace.yaml该文件用于配置 pnpm 工作区（workspace）。 pnpm 支持多项目的工作区模式，这种模式允许多个相关项目共享依赖，并且可以方便地管理这些项目的依赖关系和构建流程。 1.24 tsconfig.json该文件是 TypeScript 编译配置文件，用于定义 TypeScript 编译器在编译源代码时应遵循的选项和规则。 1.25 vitest.config.ts该文件用于配置 Vitest 的测试框架配置文件。 Vitest 是一个现代化的 JavaScript 和 TypeScript 测试框架，它提供了快速的测试运行速度和丰富的功能集，适用于前端和后端开发。 二、src目录下有什么？上一章节我们简单介绍了一下非 src文件夹下面的一些文件内容。 这些都是在一个工程化的框架项目中必不可少的部分。 那么本节的内容就是看下 src 文件夹下包含哪些内容。 下面这个目录结构去除了 ts相关的声明文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147src├─shared| ├─constants.ts| └util.ts├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 三、shared文件夹 1234src├─shared| ├─constants.ts| └util.ts 这个文件夹包含了一些在不同环境下都需要共享的工具函数或者常量。 这个工具函数与平台无关。 既可以在客户端使用，也可以在服务端使用，因为它们不依赖于任何特定的环境特性（例如 DOM）。 constants.ts文件中定义了一些在整个框架内频繁使用的常量，比如特殊的字符串标识符、配置键名等。 util.ts文件中定义了一些基础的工具函数，比如 isString、isObject和其他一些常用的功能，如深拷贝、警告输出等。 这些文件的主要目的是为了提高代码的可维护性和复用性。 通过将这些功能抽象出来，Vue.js 能够保持核心逻辑的简洁，并且确保不同部分之间的兼容性。 这样做的好处是减少了重复代码，使得代码更容易理解和维护。 四、platforms文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152src├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts 4.1 为什么会有这么一个platforms目录呢？platforms 翻译成中文表示“平台“。 vue作为一个跨平台的框架，不仅支持传统的web浏览器环境，还支持其他平台，如服务器渲染（SSR），甚至是非浏览器环境。 因此，将 Web 平台相关的代码单独放在一个目录中，有助于保持代码的清晰度和可维护性。 Web平台有许多特定的功，比如 DOM操作、CSS动画、事件处理等。这些功能在 Vue的 Web版本中是必需的，但是在其他平台上则不一定适用。将这些代码组织在一起，可以确保它们只在 Web平台上生效，而不会影响到其他平台的构建。 当然目前仅仅只有一个web平台，所以平台下只有一个 web目录。 4.2 几个入口文件entry-*文件主要用于定义不同构建配置下的入口点。 web目录下有entry-compiler.ts、entry-runtime-esm.ts、entry-runtime-with-compiler-esm.ts、entry-runtime-with-compiler、entry-runtime.ts五个入口文件。 在vue源码scripts/config.js中有打包相关的配置，其中就利用了这几个入口文件。 4.2.1 entry-compiler.ts该文件是一个提供编译 html 模板相关接口的模块，通常用于为 Vue 编写的构建插件，比如 vue-loader。 1234567891011// scripts/config.jslet builds = &#123; compiler: &#123; entry: resolve(&#x27;web/entry-compiler.ts&#x27;), dest: resolve(&#x27;packages/template-compiler/build.js&#x27;), format: &#x27;cjs&#x27;, external: Object.keys( require(&#x27;../packages/template-compiler/package.json&#x27;).dependencies ) &#125;,&#125; 4.2.2 entry-runtime.ts &amp; entry-runtime-esm.ts这两个文件都用于构建仅包含运行时的文件，不具备编译 html 模板功能。区别是一个是 esm格式，一个不是。 12345678910111213141516// scripts/config.jslet builds = &#123; &#x27;runtime-esm&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.esm.js&#x27;), format: &#x27;es&#x27;, banner &#125;, &#x27;runtime-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.min.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;production&#x27;, banner &#125;,&#125; 4.2.3 entry-runtime-with-compiler.ts &amp; entry-runtime-with-compiler-esm.ts这两个文件都用于构建同时包含编译器和运行时的全功能文件。 区别是一个是 esm格式，一个不是。 下面的full-cjs-prod可以看出来这个全版本，有 vue的全部功能。 1234567891011121314151617181920// scripts/config.jslet builds = &#123; &#x27;full-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.ts&#x27;), dest: resolve(&#x27;dist/vue.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, &#x27;full-esm-browser-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.esm.browser.min.js&#x27;), format: &#x27;es&#x27;, transpile: false, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;,&#125; 4.3 runtime-with-compiler.ts之前我们了解到 Vue分为 runtime 和 compiler两个部分。 而 runtime-with-compiler.ts文件就是既有 runtime部分 也有 compiler部分。 上面的entry-runtime-with-compiler.ts和entry-runtime-with-compiler-esm.ts就是基于这个文件进行打包的。只是分别扩展了vue的一些功能。 4.4 util目录该目录包含了 Vue在 Web平台上常用的工具函数和使用工具。 这些工具主要用于处理与 Web平台相关的各种细节。 4.5 runtime目录4.5.1 components目录该目录下存放着 vue web平台中使用的组件如 transition、transition-group组件等，借助这些组件可以实现过渡动画。 4.5.2 directives目录该目录下的主要存放是 vue的内部指令文件，如v-model、v-show指令。 4.5.3 modules目录该目录下的主要存放的是vue在 web平台上常见的 DOM操作和特性处理。 4.5.3.1 attrs.ts这个文件实现了处理元素属性的模块，它负责更新和管理元素的属性。例如，当数据模型中的属性值发生变化时，需要更新 DOM 中相应的属性值。 4.5.3.2 class.ts这个文件实现了处理元素类的模块，它负责更新和管理元素的类名。例如，根据数据模型中的条件动态添加或移除类名。 4.5.3.3 dom-props.ts这个文件实现了处理 DOM 属性的模块，它负责同步和更新 DOM 属性，如 value, checked 等。这在处理表单控件时尤为重要。 4.5.3.4 events.ts这个文件实现了处理事件绑定的模块，它负责在 DOM 元素上添加、更新和移除事件监听器。这使得 Vue.js 可以响应用户的交互行为，并触发相应的事件处理函数。 4.5.3.5 style.ts这个文件实现了处理内联样式的模块，它负责更新和管理元素的内联样式。例如，根据数据模型中的条件动态设置或移除内联样式。 4.5.3.6 transition.ts这个文件实现了处理过渡动画的模块，它负责应用过渡类，管理过渡状态，并确保过渡效果正确地应用于元素。 4.5.4 transition-util.ts该文件包含了 Vue.js 在 Web 平台上与过渡动画相关的实用工具函数。 这些工具函数为 &lt;transition&gt; 和 &lt;transition-group&gt; 组件提供了底层的支持，使得 Vue.js 能够管理和控制元素的过渡效果。 4.5.5 patch.ts该文件是 Vue.js 在 Web 平台上负责 DOM 更新的核心模块。 这个文件定义了 patch 函数，它是 Vue.js 渲染引擎的关键部分之一，用于将虚拟 DOM（Virtual DOM）更新到实际的 DOM 上。 他实际上引用了core/vdom/patch目录下的 createPatchFunction函数。 4.5.6 node-ops.ts该文件包含了 Vue.js 在 Web 平台上进行 DOM 操作的具体实现。 这个文件定义了一组方法，这些方法是 Vue.js 渲染引擎在更新 DOM 时使用的具体操作。如添加节点、删除节点等。 4.5.7 class-util.ts该文件包含了 vue 在 web平台上与元素类相关的使用工具函数。 这些工具函数用于处理元素的类名，包括添加、删除和切换类名等操作。 4.6 compiler目录该目录包含了 Vue.js 在 Web 平台上进行模板编译的相关实现。 这个目录中的文件和模块负责将 Vue 模板字符串转换为可以被 Vue 渲染引擎执行的渲染函数。 其中 directives目录下的文件 定义了一些内置指令如v-html、v-text。 modules目录中存放了对应处理模板编译时需要的一些通用处理方法。 其余文件为通用工具等。 五、core文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071src├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts core文件夹是存储这 vue的核心逻辑。 5.1 components目录该目录下存放了一些内置组件如 keep-alive。 5.2 global-api目录该目录包含了 Vue.js在核心层面提供的全局 API的实现。 如Vue.mixin、Vue.use、Vue.extend等。 5.3 instance目录该目录包含了 vue实例相关的主要实现。 其中:render.js负责渲染相关的逻辑、lifecycle.js负责管理 vue实例的生命周期钩子、events.js负责处理 vue实例上的事件、state.js负责管理 vue实例的数据状态等。 5.4 observe目录该目录包含了 Vue.js 中用于实现响应式系统的核心模块。 这部分代码负责将数据对象转换为可观察的对象，使得数据的变化能够被追踪，并自动更新依赖于该数据的视图。 5.5 vdom目录该目录包含了Vue.js 处理虚拟 DOM (Virtual DOM) 的相关实现。 虚拟 DOM 是 Vue.js 渲染机制的核心部分，它通过内存中的 JavaScript 对象来表示真实的 DOM 节点。 六、compiler文件夹该目录存放了vue模板编译的相关内容。 1234567891011121314151617181920212223src├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 七、总结我们这章大概的介绍了 vue的大体目录结构。"},{"path":"/css/extra.css","content":"/** 设置侧边栏底部 **/ .social-wrap { display: block; } .social-wrap .social:hover { background-color: #d7beb6 } /** 设置右边栏 **/ /** 右边栏目录高度设置 **/ .l_right .widgets .widget-wrapper.toc .widget-body .toc{ /* max-height: calc(100vh - 500px); */ } .widget-wrapper.toc+.widget-wrapper{ padding-top: 0px; }"}]