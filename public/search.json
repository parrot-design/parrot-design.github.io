[{"title":"🔥Vue2的基本使用和原型设计","path":"//posts/vue2-constructor.html","content":"&emsp;&emsp;在前面两篇文章中，我们熟悉了源码的目录结构以及构建方式。 &emsp;&emsp;今天我们继续来说下Vue的原型设计。 一、Vue的基础使用官方推荐 Vue 的使用方式主要有两种：通过 CDN 和 NPM。 使用 CDN，我们可以通过在 HTML 中添加 &lt;script&gt; 标签直接引入打包好的 vue.js 文件，这是一种快速且简便的方法。 12// CDN方式&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; 而 NPM 方式则涉及到与模块打包工具如 webpack 或 Browserify 的集成，通过执行 npm install vue 命令来安装 Vue，这通常是我们在开发大型应用时的首选方式。 12// NPM方式import Vue from &#x27;vue&#x27;; 当Vue被引入时，通常我们会在入口文件中去 new 一个Vue实例。 然后再利用实例上的$mount方法将对应的模版内容挂载到浏览器中#app节点的位置上。 12345678// NPM方式// Nodejs版本import Vue from &#x27;vue/dist/vue.common&#x27;;// 需要实例化 Vuenew Vue(&#123; template:`&lt;div&gt;Hello World&lt;/div&gt;`&#125;).$mount(&quot;#app&quot;); 二、为什么Vue不是一个类上一节我们说了使用 Vue 需要 new 一下。 所以你可能会习惯性的认为 Vue 是一个类。 但是我们打开Vue被定义的core/instance/index.js文件。 123456function Vue(options) &#123; if (__DEV__ &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; 会发现Vue是使用函数定义的。 那么Vue源码中为什么不使用类呢？ 在Vue中有大量的扩展实例属性的操作如：Vue.prototype.$mount=xxx。 其实本质上类只是function的语法糖。 虽然说使用类也可以进行扩展： 123456class Animate&#123;&#125;Animate.prototype.eat = function()&#123; console.log(&quot;动物吃东西&quot;)&#125;new Animate().eat();// 动物吃东西 但是用类和原型这么混合使用，难免会让人感到不适，也算是一种开发规范和习惯吧。 大部分开源库依旧使用的是构造函数function的方式。 三、必须使用new关键字来调用可以看到在Vue构造函数内部存在一个判断 this instanceof Vue，那么这行代码应该如何理解呢？ 我们知道通过 instanceof可以顺着原型链向上查找对应的构造函数。 所以这个判断的意思就是检查当前上下文（this）是否是一个 Vue实例。 如果不是一个实例，就会给你一个警告。 这要告知开发者Vue应该要作为一个构造函数来使用。 123456// instance/index.jsfunction Vue(options) &#123; if(__DEV__ &amp;&amp; !this instanceof Vue)&#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125;&#125; 假设你这么使用 Vue： 1const vm = Vue() 那么你将会在控制台看到一条报错信息。 四、Vue的原型设计Vue是一个基于原型设计的前端框架。 在Vue被引入 import Vue from vue时，会通过多个函数在Vue原型上添加上一系列的方法。 123456// 该函数在 Vue被引入时执行export function lifecycleMixin(Vue)&#123; Vue.prototype._update = ()=&gt;&#123; // xxxx &#125;&#125; 那么在Vue.prototype上定义方法有什么作用呢？ 前面2节，我们说到 Vue本质上是一个构造函数： 123function Vue()&#123; //xxx&#125; 所以我们可以通过 new关键字来创建一个 vue实例。 1const vm = new Vue(); 构造函数与原型对象：每个构造函数都有一个 prototype属性，指向一个对象。这个对象被叫做原型对象，包含了由该构造函数创建的实例共享属性和方法。实例对象的 __proto__ 属性：每个实例对象都有一个 __proto__ 属性，指向构造函数的原型对象。 所以我们可以得出结论：Vue构造函数的显式原型（Vue.prototype）和基于它创建的实例的隐式原型（vm.__proto__）指向的是同一块内存空间。 当 Vue实例访问某个属性时，如果在自身属性中找不到，则会沿着__proto__属性指向的原型对象进行查找。所以通过 vm 可以访问到定义在 Vue.prototype 的属性和方法。 通用这种方式，可以很方便的扩展方法，并不用显示的在 vm 上设置方法，做到了相对隔离。 五、Vue.extend利用原型链继承生成“子类“构造函数Vue.extend是定义在Vue这个构造函数上的方法。 该方法主要用于创建Vue构造函数的“子类“，该“子类“继承 Vue构造函数上的原型方法和原型属性。 虽然Vue在技术上不是传统意义上的类，但是Vue.extend提供了一种类似于面向对象编程中继承的方式来定义组件。 123456789101112131415// 对原函数进行了一些简化 只保留了核心Vue.extend = function()&#123; // this 为 Vue构造函数 const Super = this; // Sub 为 VueComponent构造函数，代表组件构造函数 const Sub = function VueComponent(this)&#123; // 和 Vue构造函数一样 会调用_init方法 this._init(options); &#125;; // 基于 Vue.prototype 创建一块新的内存，共享其属性和方法。 Sub.prototype = Object.create(Super.prototype); // 修正 constructor指向 Sub.prototype.constructor = Sub; return Sub;&#125; 我们简单的分析一下这几行代码。 声明了Super变量和 Sub变量分别指向Vue构造函数和 VueComponent构造函数。 5.1 使用场景在Vue源码内部和使用Vue编写业务代码时都可以使用 Vue.extend这个 api。 5.1.1 内部创建组件每一个Vue组件都对应着一个实例。 而这些实例都是通过 extend 方法创建的 VueComponent构造函数 生成的。 在render阶段，也就是在生成组件的vnode的时候会通过 extend 方法创建VueComponent构造函数。 并赋值到 vnode 中的 componentOptions属性中。 1234567891011// 创建组件的 vnode 的方法export function createComponent(Ctor,context)&#123; // _base在引入时被设置为 Vue // 这里的options后面我们会详细说明 const base = context.$options._base; // 创建Vue子类构造函数 Ctor = base.extend(); return new Vnode( &#123;componentOptions:&#123;Ctor&#125;&#125; )&#125; 这里的_base实际上就是 Vue。这里的 context是vm实例，vm.$options是在实例化构造函数时通过 mergeOptions函数生成的。 然后在update阶段（渲染页面），会基于Ctor生成对应的实例，执行相应的初始化、渲染方法等。 12345// 每个组件都会调用这个方法来创建对应的实例// 这里的 componentOptions.Ctor 就是对应的VueComponent构造函数export function createComponentInstanceForVnode(vnode)&#123; return new vnode.componentOptions.Ctor()&#125; 5.1.2 在业务中的实际应用场景在实际业务场景中，有很多地方都可以利用 extend 来扩展组件。 包括创建可复用的组件、动态组件、全局和局部注册、临时组件、自定义指令和插件。 我们常用的 Element框架内部就利用了 Vue.extend 来扩展某些临时性的组件，例如模态对话框、提示信息等。 通过 Vue.extend 创建的组件构造函数可以按需创建和销毁，适合这类临时组件的管理。 123456789101112131415161718const Main = &#123; template:&#x27;&lt;div&gt;hello main&lt;/div&gt;&#x27;&#125;const NotificationConstructor = Vue.extend(Main);let instance;const Notification = function() &#123; // 通过VueComponent创建组件实例 instance = new NotificationConstructor(); // 使用$mount可以创建一个DOM节点 并挂载到instance.$el上 instance.$mount(); document.body.appendChild(instance.$el); return instance;&#125; Notification(); $mount方法如果没有传参不会挂载，但是依旧可以生成 DOM节点，并赋值在 vm.$el上。 在 element 中的 Notification组件 就使用了 extend 进行扩展。 5.1.3 使用VueComponent继续扩展它的“子类”构造函数需要关注的是在Vue.extend中，将Vue.extend方法同时赋值给了 VueComponent。 意味着赋予了 VueComponent继续扩展的能力： 12345678Vue.extend = function()&#123; const Super = this; const Sub = function VueComponent()&#123; this._init(); &#125; // 省略部分代码 Sub.extend = Super.extend;&#125; 这意味着我们可以无限的基于 VueComponent和它的“子类”扩展子类。 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from &quot;@/my-vue2/platforms/web/entry-runtime-with-compiler-esm&quot;// 基于Vue构造函数创建的基础构造函数const VueComponentConstructor = Vue.extend(&#123; template:`&lt;div&gt;&#123;&#123; name &#125;&#125;我是构造函数&lt;/div&gt;`, data()&#123; return &#123; name:&quot;VueComponentConstructor&quot; &#125; &#125;&#125;);// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild1Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild1Constructor&quot; &#125; &#125;&#125;)// 可以复用父类构造函数VueComponentConstructor上的属性const VueComponentChild2Constructor = VueComponentConstructor.extend(&#123; data()&#123; return &#123; name:&quot;VueComponentChild2Constructor&quot; &#125; &#125;&#125;)function addNode()&#123; const vm1 = new VueComponentConstructor(); const vm2 = new VueComponentChild1Constructor(); const vm3 = new VueComponentChild2Constructor(); vm1.$mount() vm2.$mount() vm3.$mount() document.body.appendChild(vm1.$el) document.body.appendChild(vm2.$el) document.body.appendChild(vm3.$el)&#125;addNode(); 上述代码中，VueComponentConstructor 是通过 Vue.extend 创建的一个基础组件构造函数。 在这个基础构造函数中传入了模板选项，我们之后创建的构造函数就可以复用 template选项，避免编写重复的模板。 我们这里只是简单的举了一个例子，通过这个例子我们了解到了extend的重要意义。真实的复用结构肯定更为复杂。 不过在实际开发中，一般我们应用中基本只存在 Vue构造函数和它的直接构造函数 VueComponent。 在组件库等基础库中可能会存在这种子类继续扩展子类的情况。 六、为什么Vue实例被叫做 vm源码中你会看到大量的 vm。 使用 new Vue() 创建的Vue实例通常被叫做 vm。 Vue被称为VM，是因为它是一个基于MVVM（Model-View-ViewModel）架构的前端框架。 在MVVM架构中，VM代表ViewModel，负责管理视图（View）和数据模型（Model）之间的通信和交互。 七、引入时基于原型挂载方法Vue是基于原型设计的前端框架。 后续的操作都是在调用原型上定义的方法。 那么 Vue是在什么时候对这些方法进行挂载的呢？ 一部分是在 Vue引入的时候挂载的，一部分是在 Vue实例化的时候进行挂载的。 那么 Vue是如何在引入的时候进行挂载呢？ 我们打开入口文件可以看到 Vue 被有层次的导入多个文件中，然后在文件中添加上对应的原型方法。 比如在: 在platforms/web/runtime-with-compiler.js文件中： Vue上扩展了定义了Vue.compile 重写了 Vue.prototype.$mount 在platforms/web/runtime/index.js文件中： 定义了Vue.prototype.$mount 定义了Vue.prototype.patch 扩展了扩展 Vue.config一些属性 扩展 Vue.options.directive 扩展 Vue.options.components 在core/index.js文件中： 使用了initGlobalAPI定义了一些全局方法 如 mixin 定义了Vue.prototype.$isServer 定义了Vue.prototype.$ssrContext 定义了Vue.FunctionalRenderContext 定义了Vue.version 在core/instance/index文件中： 使用 initMixin 注入了 初始化有关的属性如：Vue.prototype.$init 使用 stateMixin 注入了 跟状态有关的属性如：Vue.prototype.$set、Vue.prototype.$watch、Vue.prototype.$delete 使用 eventsMixin 注入了 跟事件有关的属性如：Vue.prototype.$on、Vue.prototype.$off、Vue.prototype.$once 使用 lifecycleMixin 注入了 跟整个 vue生命周期更新有关的属性如：Vue.prototype.$update 使用 renderMixin 注入了 跟渲染相关的属性如：Vue.prototype._render 可以发现 Vue源码中是一层一层进行导入。 那么Vue为什么要这么设计目录结构呢？ 我们可以看到每个模块都对 Vue对象做了相应的处理，比如说扩展属性、扩展实例属性等。 Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有。 这种技巧便于后期Vue的维护和迭代。"},{"title":"🔥Vue2源码构建","path":"//posts/vue2-core-build.html","content":"&emsp;&emsp;在上一篇文章中，我们大概了解了Vue的目录结构是怎么样的。 &emsp;&emsp;在这一篇文章中，我们会知晓 Vue 是如何构建的。 一、Vue的构建1.1 根据使用场景打包在上一篇专栏文章中，我们熟悉了 Vue源码中的代码结构。 其中我们介绍了几个入口文件： entry-runtime.ts entry-runtime-with-compiler.ts entry-runtime-esm.ts entry-runtime-with-compiler-esm.ts 在我们开发项目结束后，需要进行打包并部署到线上。 通常我们项目打包时需要一个入口文件， webpack通过这个入口文件递归文件进行依赖分析然后打包。 其实框架打包也一样，同样需要一个入口文件进行递归依赖分析打包生成 js文件方便我们进行使用。 和项目不一样的是，项目往往只有一个入口文件，而框架会根据不同的情况采用不同的入口文件进行打包，上面的这四个文件就是Vue框架的入口文件。 Vue是使用rollup进行打包的。 为了方便用户进行使用，Vue在使用rollup进行打包时根据开发环境&#96;和开发模式打包出了不同功能的文件，以适用于不同的使用场景。 构建的rollup打包脚本的代码在scripts/config.js文件中。 1234567891011121314151617const builds = &#123; &#x27;runtime-cjs-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.dev.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;development&#x27;, banner &#125;, &#x27;runtime-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, banner &#125;, // 省略&#125; 总共打包生成 12 个文件，这些文件可以适用于不同的场景。 根据是否带编译器的角度上分为Full和Runtime-Only 2个版本。Full版本包含编译器和运行时的全部功能。Runtime-Only 仅含运行时功能。 打包的文件根据使用场景分为 esm、cjs、umd三个版本。其中umd可以通过&lt;script&gt;标签引入直接在浏览器中使用，Vue会暴露一个全局变量 Windows.Vue。而 CommonJS适配const Vue &#x3D; require(‘vue’)这种 node式的模块系统。ES则适配import Vue from ‘vue’这种es6格式。 打包的文件根据环境分为 dev&#x2F;prod，在开发环境中可以使用 dev版本的 js文件，而部署到客户生产环境就可以使用 prod版本的 js文件。 dev版本的文件有一些提示，会在开发者开发时便于调试。 1.2 Full版本的Vue到底是什么意思？ 平时我们开发中只使用了 runtime-only 版本。 而 Full版本中不仅有 runtime-only部分，还包括编译器部分。 所谓编译器，就是在Vue内部的编译器可以将模板转化为对应的render函数。 在Vue内部渲染就是调用的 render方法生成 vnode。 因为编译器代码体积比较大，而且如果在运行的时候进行模板编译，极大可能会消耗性能。 所以我们一般在开发项目时，使用 runtime-only版本。 在 webpack预编译阶段，就将.vue文件编译成render函数，在运行时直接运行 render函数就可以获取到对应的 vnode。 通过 runtime-only 和 esm很容易推测出来我们项目在开发阶段中使用的是vue.runtime.esm.js 1.3 使用 Full 还是用 Runtime-Only版本这需要依据具体情况进行具体分析。 倘若你需要用到 Vue 所提供的 html 模板功能，那就选用 Full 版本。 反之，最好采用 Runtime-only 版本，原因在于它比 Full 版本的文件体积大约小 30%。 *.vue 单文件组件会被 vue-loader 直接构建成为 JavaScript，并未使用到 Vue 的编译器，所以可以使用 Runtime-only 版本。 二、神奇的“__DEV__”在前面我们说到，在打包成开发环境的包时，往往会存在很多提示信息。 而源码中判断开发环境通常都是使用__DEV__来进行判断。 2.1 __DEV__的本质在Vue源码中，到处都能看到__DEV__变量的身影。 但是你看不到__DEV__被 import 引入，甚至你都找不到在哪里定义了这个变量。 这个变量在 Vue 中代表开发环境。 当你在源码中看见 if(__DEV__) 代表这个if中的逻辑只有在开发环境才进入执行。 vue的构建工具是rollup，在rollup打包的时候会使用@rollup/plugin-replace 插件来替换源代码中的__DEV__变量，如下： 123456789101112......const replace = require(&#x27;@rollup/plugin-replace&#x27;)......// built-in varsconst vars = &#123; ...... __DEV__: `process.env.NODE_ENV !== &#x27;production&#x27;`, ......&#125;......config.plugins.push(replace(vars))...... 所以__DEV__的本质就是 proess.env.NODE_ENV!== &#39;production&#39; 。 2.2 约定俗成的“process.env.NODE_ENV!&#x3D;&#x3D;’production”将 DEV 变量转换为 process.env.NODE_ENV !== &#39;production&#39; 这样的条件表达式在现代前端构建工具中是一种常见的约定和实践。 原因有以下几点： 环境区分：通过 process.env.NODE_ENV 可以方便地在代码中区分开发环境（development）与生产环境（production）。例如，在开发环境中启用特定的警告、日志记录或者热加载功能；而在生产环境中则禁用这些功能以优化性能。 Tree-shaking 和 UglifyJS：当打包工具如 Rollup 或 webpack 遇到 process.env.NODE_DEV !== &#39;production&#39; 包裹的代码块时，在生产环境下会自动去除（tree-shake）其中仅在开发环境中需要的代码，因为该条件表达式最终会被编译器或压缩工具识别为始终为 false，因此包裹的代码不会被打包进最终产物。 标准化：许多框架和库都采用了这种模式来处理环境相关的逻辑，这样开发者可以统一遵循这个约定，减少配置和理解成本。 灵活配置：由于构建工具支持 .env 文件或其他方式来设置 NODE_ENV 的值，这使得项目配置更加灵活，团队成员可以根据实际需求快速切换不同环境下的行为。 跨平台兼容性：process.env.NODE_ENV 作为一个标准 Node.js 环境变量接口，已经被广泛接受，并且在各种打包工具中都有相应的机制将其映射到最终浏览器执行的代码中，确保了跨平台的一致性。 一般项目在开发环境中将process.env.NODE_ENV设置为development，在生产环境中设置为production。所以通过process.env.NODE_ENV !== &#39;production就可以判断现在是处于什么环境下。 2.3 在本地环境配置__DEV__因为我们这门课程是写一个完整版的vue2。 所以我们也会使用__DEV__这个变量代表开发环境。 我们本地的项目是使用 vue-cli 搭建的。 可以在 webpack配置文件 vue.config.js 文件新增一个配置达到这个目的。 1234567891011121314// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, configureWebpack: &#123; plugins: [ new webpack.DefinePlugin(&#123; __DEV__: process.env.NODE_ENV === &#x27;development&#x27;, &#125;), ], &#125;,&#125;) DefinePlugin 插件的主要作用是在编译时将预定义的值替换到源代码中的特定变量。 我们执行yarn start启动这个项目打印一下__DEV__为 true即为成功。 1console.log(__DEV__); // true"},{"title":"🔥Vue2目录结构窥探","path":"//posts/vue2-catalog.html","content":"&emsp;&emsp;本专栏旨在通过用丰富的图文详解来帮助你全面深入的了解 Vue2 源码。这是本专栏的第一篇文章。 &emsp;&emsp;因为 Vue 框架是在十多年前产生的一个开源前端框架，经过一些迭代修复，目前已经趋于稳定。 &emsp;&emsp;Vue2框架在可维护性、性能、TypeScript支持等方面有一些痛点，所以尤雨溪推出了 Vue3版本。 &emsp;&emsp;不过目前大部分公司因为成本等方面的原因，还是使用在 Vue2 版本，所以我们这个专栏就来探讨一下 Vue2 的源码部分。 一、非核心Vue源码目录大致结构我们看的Vue源码版本2.7.16是Vue2的最新版本 我们打开Vue2的github源码地址。 可以看到其中有很多个目录文件，但是其实 Vue2 源码核心的都是在 src文件夹中的。 我们这章大概介绍一下除了 src 下面的一些目录，了解一下大体的作用是什么。 1.1 .github该文件夹用于存放与 gitHub 相关的配置文件或者脚本。 1.2 benchmarks该文件夹用于存放性能基准测试的相关文件和脚本。 性能基准测试是一种用来评估软件性能的方法，它通过模拟真实世界中的使用场景来测量软件在不同条件下的表现。可以确保新功能不会降低框架的整体性能，同时也可以用来优化现有代码，使其更加高效。 1.3. compiler-sfc该文件夹下的内容逻辑就可以协助 webpack进行解析处理单文件组件（SFC）。 通常我们开发时会借助webpack将vue文件转化为一个JS对象。 可以查看他的 index.js文件 发现实际上就是导出了@vue/compiler-sfc这个包。 1module.exports = require(&#x27;@vue/compiler-sfc&#x27;) 1.4. dist该文件夹为打包文件存放的地方。 1.5. examples该文件夹用于存放示例应用程序或代码片段，目的是展示 Vue.js 的基本用法和功能。 1.6 packages该文件夹主要用于组织 Vue.js 的各个子包或模块。 随着 Vue.js 项目的复杂度增加，将不同的功能模块拆分成独立的子包已经成为了一种常见的做法。 这样不仅有利于模块化开发，还能方便依赖管理和发布。 该目录下有三个目录。 1.6.1 compiler-sfc该文件夹下的内容主要用于处理单文件组件。 1.6.2 server-renderer该文件夹下的内容和服务端渲染相关的内容。 1.6.3 template-compiler该文件夹下的内容存放模板编译相关的逻辑。 1.7 scripts该文件夹主要用于存放各种自动化脚本。 这些脚本通常用于辅助项目的构建、测试、发布和其他开发任务。 1.8 src该文件夹是存放 vue框架核心源码的地方。 1.9 test该文件夹主要用于存放各种类型的测试文件，这些测试文件用于验证 Vue.js 框架的功能是否按预期工作。 1.10 types该文件夹主要用于存放 TypeScript 类型定义文件。 这些类型定义文件为 Vue.js 提供了类型支持，使得在使用 Vue.js 时可以享受静态类型检查的好处，从而提高代码质量和开发效率。 1.11 .editorconfig该文件用于指定编辑器应该遵循的一系列编码和格式化规则。 1.12 .git-blame-ignore-revs该文件用于告诉 Git 在执行 git blame 命令时忽略某些特定的提交记录。 1.13 .gitignore该文件用于指定 Git 应该忽略哪些文件或目录，即不将这些文件或目录纳入版本控制。 1.14 .prettierrc该文件用于配置 Prettier。 Prettier是一个流行的代码格式化工具，旨在帮助开发者保持代码风格的一致性。Prettier 可以自动格式化代码，使其符合预设的编码规范，从而提高代码的可读性和一致性。 1.15 BACKERS.md该文件主要用于记录和支持 Vue.js 项目的赞助者或贡献者。 这份文件通常列出了那些通过资金或其他形式支持 Vue.js 发展的个人或组织。 1.16 CHANGELOG.md该文件主要用于记录项目的版本变更历史，包括每个版本的新增功能、改进、修复的错误以及其他重要的变更信息。 1.17 LICENSE该文件用来定义和声明项目使用的许可协议的文件 1.18 README.md该文件为项目的入口文档文件。 文件提供了关于项目的概述、安装步骤、使用方法、贡献指南等关键信息。 1.19 api-extractor.json该文件用于配置 API Extractor 工具（这是一种用于生成 TypeScript 类型定义文档和 API 报告的工具） API Extractor 通常用于大型 TypeScript 项目中，帮助开发者生成详细的 API 文档，并确保类型定义的一致性和准确性。 1.20 api-extractor.tsconfig.json该文件用于配置 TypeScript 编译选项，以配合 API Extractor 工具生成 API 文档和类型定义文件。 这个文件通常包含了一些特定的 TypeScript 配置，确保 API Extractor 能够正确地解析和处理源代码。 1.21 package.json该文件是项目的核心配置文件，用于描述项目的元数据以及项目依赖关系和构建脚本。 1.22 pnpm-lock.yaml该文件是由 pnpm 包管理器生成的锁定文件。 用于记录项目中所有依赖项的具体版本信息，以及它们是如何被安装的。 pnpm 是一种替代 npm 和 yarn 的高性能包管理器，它具有更快的速度和更少的磁盘空间占用。 1.23 pnpm-workspace.yaml该文件用于配置 pnpm 工作区（workspace）。 pnpm 支持多项目的工作区模式，这种模式允许多个相关项目共享依赖，并且可以方便地管理这些项目的依赖关系和构建流程。 1.24 tsconfig.json该文件是 TypeScript 编译配置文件，用于定义 TypeScript 编译器在编译源代码时应遵循的选项和规则。 1.25 vitest.config.ts该文件用于配置 Vitest 的测试框架配置文件。 Vitest 是一个现代化的 JavaScript 和 TypeScript 测试框架，它提供了快速的测试运行速度和丰富的功能集，适用于前端和后端开发。 二、src目录下有什么？上一章节我们简单介绍了一下非 src文件夹下面的一些文件内容。 这些都是在一个工程化的框架项目中必不可少的部分。 那么本节的内容就是看下 src 文件夹下包含哪些内容。 下面这个目录结构去除了 ts相关的声明文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147src├─shared| ├─constants.ts| └util.ts├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 三、shared文件夹 1234src├─shared| ├─constants.ts| └util.ts 这个文件夹包含了一些在不同环境下都需要共享的工具函数或者常量。 这个工具函数与平台无关。 既可以在客户端使用，也可以在服务端使用，因为它们不依赖于任何特定的环境特性（例如 DOM）。 constants.ts文件中定义了一些在整个框架内频繁使用的常量，比如特殊的字符串标识符、配置键名等。 util.ts文件中定义了一些基础的工具函数，比如 isString、isObject和其他一些常用的功能，如深拷贝、警告输出等。 这些文件的主要目的是为了提高代码的可维护性和复用性。 通过将这些功能抽象出来，Vue.js 能够保持核心逻辑的简洁，并且确保不同部分之间的兼容性。 这样做的好处是减少了重复代码，使得代码更容易理解和维护。 四、platforms文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152src├─platforms| ├─web| | ├─entry-compiler.ts| | ├─entry-runtime-esm.ts| | ├─entry-runtime-with-compiler-esm.ts| | ├─entry-runtime-with-compiler.ts| | ├─entry-runtime.ts| | ├─runtime-with-compiler.ts| | ├─util| | | ├─attrs.ts| | | ├─class.ts| | | ├─compat.ts| | | ├─element.ts| | | ├─index.ts| | | └style.ts| | ├─runtime| | | ├─class-util.ts| | | ├─index.ts| | | ├─node-ops.ts| | | ├─patch.ts| | | ├─transition-util.ts| | | ├─modules| | | | ├─attrs.ts| | | | ├─class.ts| | | | ├─dom-props.ts| | | | ├─events.ts| | | | ├─index.ts| | | | ├─style.ts| | | | └transition.ts| | | ├─directives| | | | ├─index.ts| | | | ├─model.ts| | | | └show.ts| | | ├─components| | | | ├─index.ts| | | | ├─transition-group.ts| | | | └transition.ts| | ├─compiler| | | ├─index.ts| | | ├─options.ts| | | ├─util.ts| | | ├─modules| | | | ├─class.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └style.ts| | | ├─directives| | | | ├─html.ts| | | | ├─index.ts| | | | ├─model.ts| | | | └text.ts 4.1 为什么会有这么一个platforms目录呢？platforms 翻译成中文表示“平台“。 vue作为一个跨平台的框架，不仅支持传统的web浏览器环境，还支持其他平台，如服务器渲染（SSR），甚至是非浏览器环境。 因此，将 Web 平台相关的代码单独放在一个目录中，有助于保持代码的清晰度和可维护性。 Web平台有许多特定的功，比如 DOM操作、CSS动画、事件处理等。这些功能在 Vue的 Web版本中是必需的，但是在其他平台上则不一定适用。将这些代码组织在一起，可以确保它们只在 Web平台上生效，而不会影响到其他平台的构建。 当然目前仅仅只有一个web平台，所以平台下只有一个 web目录。 4.2 几个入口文件entry-*文件主要用于定义不同构建配置下的入口点。 web目录下有entry-compiler.ts、entry-runtime-esm.ts、entry-runtime-with-compiler-esm.ts、entry-runtime-with-compiler、entry-runtime.ts五个入口文件。 在vue源码scripts/config.js中有打包相关的配置，其中就利用了这几个入口文件。 4.2.1 entry-compiler.ts该文件是一个提供编译 html 模板相关接口的模块，通常用于为 Vue 编写的构建插件，比如 vue-loader。 1234567891011// scripts/config.jslet builds = &#123; compiler: &#123; entry: resolve(&#x27;web/entry-compiler.ts&#x27;), dest: resolve(&#x27;packages/template-compiler/build.js&#x27;), format: &#x27;cjs&#x27;, external: Object.keys( require(&#x27;../packages/template-compiler/package.json&#x27;).dependencies ) &#125;,&#125; 4.2.2 entry-runtime.ts &amp; entry-runtime-esm.ts这两个文件都用于构建仅包含运行时的文件，不具备编译 html 模板功能。区别是一个是 esm格式，一个不是。 12345678910111213141516// scripts/config.jslet builds = &#123; &#x27;runtime-esm&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.esm.js&#x27;), format: &#x27;es&#x27;, banner &#125;, &#x27;runtime-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.ts&#x27;), dest: resolve(&#x27;dist/vue.runtime.min.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;production&#x27;, banner &#125;,&#125; 4.2.3 entry-runtime-with-compiler.ts &amp; entry-runtime-with-compiler-esm.ts这两个文件都用于构建同时包含编译器和运行时的全功能文件。 区别是一个是 esm格式，一个不是。 下面的full-cjs-prod可以看出来这个全版本，有 vue的全部功能。 1234567891011121314151617181920// scripts/config.jslet builds = &#123; &#x27;full-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.ts&#x27;), dest: resolve(&#x27;dist/vue.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, &#x27;full-esm-browser-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler-esm.ts&#x27;), dest: resolve(&#x27;dist/vue.esm.browser.min.js&#x27;), format: &#x27;es&#x27;, transpile: false, env: &#x27;production&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;,&#125; 4.3 runtime-with-compiler.ts之前我们了解到 Vue分为 runtime 和 compiler两个部分。 而 runtime-with-compiler.ts文件就是既有 runtime部分 也有 compiler部分。 上面的entry-runtime-with-compiler.ts和entry-runtime-with-compiler-esm.ts就是基于这个文件进行打包的。只是分别扩展了vue的一些功能。 4.4 util目录该目录包含了 Vue在 Web平台上常用的工具函数和使用工具。 这些工具主要用于处理与 Web平台相关的各种细节。 4.5 runtime目录4.5.1 components目录该目录下存放着 vue web平台中使用的组件如 transition、transition-group组件等，借助这些组件可以实现过渡动画。 4.5.2 directives目录该目录下的主要存放是 vue的内部指令文件，如v-model、v-show指令。 4.5.3 modules目录该目录下的主要存放的是vue在 web平台上常见的 DOM操作和特性处理。 4.5.3.1 attrs.ts这个文件实现了处理元素属性的模块，它负责更新和管理元素的属性。例如，当数据模型中的属性值发生变化时，需要更新 DOM 中相应的属性值。 4.5.3.2 class.ts这个文件实现了处理元素类的模块，它负责更新和管理元素的类名。例如，根据数据模型中的条件动态添加或移除类名。 4.5.3.3 dom-props.ts这个文件实现了处理 DOM 属性的模块，它负责同步和更新 DOM 属性，如 value, checked 等。这在处理表单控件时尤为重要。 4.5.3.4 events.ts这个文件实现了处理事件绑定的模块，它负责在 DOM 元素上添加、更新和移除事件监听器。这使得 Vue.js 可以响应用户的交互行为，并触发相应的事件处理函数。 4.5.3.5 style.ts这个文件实现了处理内联样式的模块，它负责更新和管理元素的内联样式。例如，根据数据模型中的条件动态设置或移除内联样式。 4.5.3.6 transition.ts这个文件实现了处理过渡动画的模块，它负责应用过渡类，管理过渡状态，并确保过渡效果正确地应用于元素。 4.5.4 transition-util.ts该文件包含了 Vue.js 在 Web 平台上与过渡动画相关的实用工具函数。 这些工具函数为 &lt;transition&gt; 和 &lt;transition-group&gt; 组件提供了底层的支持，使得 Vue.js 能够管理和控制元素的过渡效果。 4.5.5 patch.ts该文件是 Vue.js 在 Web 平台上负责 DOM 更新的核心模块。 这个文件定义了 patch 函数，它是 Vue.js 渲染引擎的关键部分之一，用于将虚拟 DOM（Virtual DOM）更新到实际的 DOM 上。 他实际上引用了core/vdom/patch目录下的 createPatchFunction函数。 4.5.6 node-ops.ts该文件包含了 Vue.js 在 Web 平台上进行 DOM 操作的具体实现。 这个文件定义了一组方法，这些方法是 Vue.js 渲染引擎在更新 DOM 时使用的具体操作。如添加节点、删除节点等。 4.5.7 class-util.ts该文件包含了 vue 在 web平台上与元素类相关的使用工具函数。 这些工具函数用于处理元素的类名，包括添加、删除和切换类名等操作。 4.6 compiler目录该目录包含了 Vue.js 在 Web 平台上进行模板编译的相关实现。 这个目录中的文件和模块负责将 Vue 模板字符串转换为可以被 Vue 渲染引擎执行的渲染函数。 其中 directives目录下的文件 定义了一些内置指令如v-html、v-text。 modules目录中存放了对应处理模板编译时需要的一些通用处理方法。 其余文件为通用工具等。 五、core文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071src├─core| ├─config.ts| ├─index.ts| ├─vdom| | ├─create-component.ts| | ├─create-element.ts| | ├─create-functional-component.ts| | ├─patch.ts| | ├─vnode.ts| | ├─modules| | | ├─directives.ts| | | ├─index.ts| | | └template-ref.ts| | ├─helpers| | | ├─extract-props.ts| | | ├─get-first-component-child.ts| | | ├─index.ts| | | ├─is-async-placeholder.ts| | | ├─merge-hook.ts| | | ├─normalize-children.ts| | | ├─normalize-scoped-slots.ts| | | ├─resolve-async-component.ts| | | └update-listeners.ts| ├─util| | ├─debug.ts| | ├─env.ts| | ├─error.ts| | ├─index.ts| | ├─lang.ts| | ├─next-tick.ts| | ├─options.ts| | ├─perf.ts| | └props.ts| ├─observer| | ├─array.ts| | ├─dep.ts| | ├─index.ts| | ├─scheduler.ts| | ├─traverse.ts| | └watcher.ts| ├─instance| | ├─events.ts| | ├─index.ts| | ├─init.ts| | ├─inject.ts| | ├─lifecycle.ts| | ├─proxy.ts| | ├─render.ts| | ├─state.ts| | ├─render-helpers| | | ├─bind-dynamic-keys.ts| | | ├─bind-object-listeners.ts| | | ├─bind-object-props.ts| | | ├─check-keycodes.ts| | | ├─index.ts| | | ├─render-list.ts| | | ├─render-slot.ts| | | ├─render-static.ts| | | ├─resolve-filter.ts| | | ├─resolve-scoped-slots.ts| | | └resolve-slots.ts| ├─global-api| | ├─assets.ts| | ├─extend.ts| | ├─index.ts| | ├─mixin.ts| | └use.ts| ├─components| | ├─index.ts| | └keep-alive.ts core文件夹是存储这 vue的核心逻辑。 5.1 components目录该目录下存放了一些内置组件如 keep-alive。 5.2 global-api目录该目录包含了 Vue.js在核心层面提供的全局 API的实现。 如Vue.mixin、Vue.use、Vue.extend等。 5.3 instance目录该目录包含了 vue实例相关的主要实现。 其中:render.js负责渲染相关的逻辑、lifecycle.js负责管理 vue实例的生命周期钩子、events.js负责处理 vue实例上的事件、state.js负责管理 vue实例的数据状态等。 5.4 observe目录该目录包含了 Vue.js 中用于实现响应式系统的核心模块。 这部分代码负责将数据对象转换为可观察的对象，使得数据的变化能够被追踪，并自动更新依赖于该数据的视图。 5.5 vdom目录该目录包含了Vue.js 处理虚拟 DOM (Virtual DOM) 的相关实现。 虚拟 DOM 是 Vue.js 渲染机制的核心部分，它通过内存中的 JavaScript 对象来表示真实的 DOM 节点。 六、compiler文件夹该目录存放了vue模板编译的相关内容。 1234567891011121314151617181920212223src├─compiler| ├─codeframe.ts| ├─create-compiler.ts| ├─error-detector.ts| ├─helpers.ts| ├─index.ts| ├─optimizer.ts| ├─to-function.ts| ├─parser| | ├─entity-decoder.ts| | ├─filter-parser.ts| | ├─html-parser.ts| | ├─index.ts| | └text-parser.ts| ├─directives| | ├─bind.ts| | ├─index.ts| | ├─model.ts| | └on.ts| ├─codegen| | ├─events.ts| | └index.ts 七、总结我们这章大概的介绍了 vue的大体目录结构。"},{"title":"二、Java语言发展历史","path":"//posts/Java语言发展历史.html","content":"1、Java语言发展历史 发行版本 发行时间 备注 Java 1995.05.23 SUN公司在 Sun world会议上正式发布 Java和 HotJava浏览器 Java1.0 1996.01.23 SUN公司发部了 Java的第一个开发工具包 Java1.1 1997.02.19 Java1.2 1998.12.08 拆分成：J2SE(标准版)、J2EE(企业级)、J2ME(小型版) Java1.3 2000.05.08 Java1.4 2004.02.06 Java5.0 2004.09.30 1.版本号从 1.4 直接更新至 5.0； 2.平台更名为JavaSE、JavaEE、JavaME Java6.0 2006.12.11 2009.04.20 Oracle宣布收购 SUN公司 Java7.0 2011.07.02 Java8.0 2014.03.18 LTS版本 Java9.0 2017.09.22 1.每半年更新一次 2.Java9.0开始不再支持 window32位系统 Java10.0 2018.03.21 Java11.0 2018.09.25 1.JDK安装包取消独立 JRE安装包；2.LTS版本 Java12.0 2019.03.19 Java13.0 2019.09.17 Java14.0 2020.03.17 Java15.0 2020.09.16 Java16.0 2021.03.16 Java17.0 2021.09.14 LTS版本 LTS（Long Term Support）:长期支持版本，下一个 LTS版本为 Java17.0","tags":["blog"],"categories":["Java","Java基础"]},{"title":"一、计算机语言介绍","path":"//posts/计算机语言介绍.html","content":"1、计算机语言是什么？所谓计算机编程语言，就是人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 比如打游戏等就是输入指令让计算机执行。 2、计算机语言发展 第一代：机器语言 例如：0101 不直观 第二代：汇编语言 例如：加入了单词 第三代：高级语言 面向过程语言 面向对象语言 3、计算机语言排行榜下面是 2024 年 2 月最受欢迎的 10 种编程语言。 4、计算机语言走势","tags":["blog"],"categories":["Java","Java基础"]},{"path":"/css/extra.css","content":"/** 设置侧边栏底部 **/ .social-wrap { display: block; } .social-wrap .social:hover { background-color: #d7beb6 } /** 设置右边栏 **/ /** 右边栏目录高度设置 **/ .l_right .widgets .widget-wrapper.toc .widget-body .toc{ /* max-height: calc(100vh - 500px); */ } .widget-wrapper.toc+.widget-wrapper{ padding-top: 0px; }"}]